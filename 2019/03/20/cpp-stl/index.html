<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Kevin W build this air-castle to collect infos &amp; photos"><title>cpp_stl | MonoShow</title><link rel="stylesheet" type="text/css" href="../../../../css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="../../../../favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="../../../../favicon.ico"><link rel="apple-touch-icon" href="../../../../apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="../../../../apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="../../../../atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">cpp_stl</h1><a id="logo" href="../../../../.">MonoShow</a><p class="description">Monologue from Kevin_W</p></div><div id="nav-menu"><a class="current" href="../../../../."><i class="fa fa-home"> 时间线</i></a><a href="../../../../archives/"><i class="fa fa-archive"> 档案袋</i></a><a href="../../../../photo/"><i class="fa fa-camera"> Ins摄影集</i></a><a href="../../../../categories/language-learning/"><i class="fa fa-book"> 看原著了嘛</i></a><a href="../../../../categories/github-repo/"><i class="fa fa-github"> 码代码了嘛</i></a><a href="../../../../categories/paper/"><i class="fa fa-file-text"> 翻译论文了嘛</i></a><a href="../../../../about/"><i class="fa fa-user"> 自己的碎碎念</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">cpp_stl</h1><div class="post-meta">Mar 20, 2019<span> | </span><span class="category"><a href="../../../../categories/study/">study</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 13</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Template（模板）"><span class="toc-number">1.</span> <span class="toc-text">Template（模板）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数模板"><span class="toc-number">1.1.</span> <span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类模板"><span class="toc-number">1.2.</span> <span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板参数"><span class="toc-number">1.3.</span> <span class="toc-text">模板参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string类"><span class="toc-number">2.</span> <span class="toc-text">string类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basic-string"><span class="toc-number">2.1.</span> <span class="toc-text">basic_string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string函数"><span class="toc-number">2.2.</span> <span class="toc-text">string函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string构造和析构函数"><span class="toc-number">2.3.</span> <span class="toc-text">string构造和析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5种序列容器"><span class="toc-number">3.</span> <span class="toc-text">5种序列容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常用函数成员"><span class="toc-number">3.1.</span> <span class="toc-text">常用函数成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#具体使用"><span class="toc-number">3.2.</span> <span class="toc-text">具体使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器"><span class="toc-number">3.3.</span> <span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3种容器适配器"><span class="toc-number">4.</span> <span class="toc-text">3种容器适配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4种map容器"><span class="toc-number">5.</span> <span class="toc-text">4种map容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set容器"><span class="toc-number">6.</span> <span class="toc-text">set容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#随机数"><span class="toc-number">7.</span> <span class="toc-text">随机数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流迭代器"><span class="toc-number">8.</span> <span class="toc-text">流迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值、时间和复数"><span class="toc-number">9.</span> <span class="toc-text">数值、时间和复数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-常用算法和algorithm库"><span class="toc-number">10.</span> <span class="toc-text">C++常用算法和algorithm库</span></a></li></ol></div></div><div class="post-content"><p>C++ STL接触(loading…)<br>在学习C++，数据结构基础上，STL是基础和进阶的分水岭，要多尝试用STL实现常用的算法和数据结构<br><a id="more"></a></p>
<h2 id="Template（模板）"><a href="#Template（模板）" class="headerlink" title="Template（模板）"></a>Template（模板）</h2><p>模板（Template）指C++程序设计设计语言中采用类型作为参数的程序设计，支持通用程序设计。C++ 的标准库提供许多有用的函数大多结合了模板的观念，如STL以及IO Stream。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>可以实现不同类型的函数代码的复用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt; swap(t &amp;t1, t &amp;t2)&#123;</span><br><span class="line">  t tmpT;</span><br><span class="line">  tmpT = t1;</span><br><span class="line">  t1 = t2;</span><br><span class="line">  t2 = tmpT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板实例化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">float</span> num3 = <span class="number">1.0</span>, num4 = <span class="number">2.0</span>;</span><br><span class="line">  swap&lt;<span class="keyword">int</span>&gt;(num1, num2);</span><br><span class="line">  swap&lt;<span class="keyword">float</span>&gt;(num3, num4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>可以实现不同类型的类的复用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">t</span>&gt; <span class="title">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Stack()&#123;</span><br><span class="line">      maxSize = <span class="number">100</span>;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      p = <span class="keyword">new</span> t[maxSize];</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Stack()&#123;</span><br><span class="line">      <span class="keyword">delete</span> p[];</span><br><span class="line">      p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(t num)</span></span>&#123;</span><br><span class="line">      size++;</span><br><span class="line">      p[size<span class="number">-1</span>] = num;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">t <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">      t num = p[size<span class="number">-1</span>];</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    t *p;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板实例化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Stack&lt;<span class="keyword">int</span>&gt; intStack;</span><br><span class="line">  Stack&lt;<span class="keyword">float</span>&gt; floatStack;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  intStack.push(<span class="number">1</span>);</span><br><span class="line">  intStack.push(<span class="number">2</span>);</span><br><span class="line">  intStack.push(<span class="number">3</span>);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!intStack.isEmpty())&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,intStack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>模板可以有常规的类型参数，也可以有默认模板参数<br><code>template&lt;class t, int maxSize = 100&gt; class stack{}</code></p>
<p>一个类没有模板参数，但是成员函数有模板参数，是可行的</p>
<p>有些特殊的参数可以使用模板专门化<br><code>template&lt;&gt; void swap(std::vector&lt;int&gt;&amp; t1, std::vector&lt;int&gt;&amp; t2){}</code></p>
<h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p>使用指针 ++ 和 – 操作符来遍历字符串，无论 ASCII 码字符串还是 Unicode 字符串，使用指针均能够正确无误地返回要寻求的字符位置。使用数组处理字符串中的字符也非常方便。</p>
<p>STL 中只有一个字符串类，即 basic_string。类 basic_string 实现管理以 \0 结尾的字符数组，字符类型由模板参数决定。basic_string 有两个预定义类型：包含 char 的 string 类型和包含 wchar 的 wstring 类型。</p>
<p>string 作为类出现，其集成的操作函数足以完成多数情况下的需要。可以使用 “=” 进行赋值，使用 “==” 进行等值比较，使用 “+” 做串联。</p>
<p>string 类包含了 6 个构造函数。string 类支持 cin 方式和 getline() 方式两种输入方式。</p>
<h3 id="basic-string"><a href="#basic-string" class="headerlink" title="basic_string"></a>basic_string</h3><p>basic_string是一个类模板，包括string，wstring，u16stirng和u32string<br><code>typedef basic_string &lt;char&gt; string;</code><br><code>typedef basic_string &lt;wchar&gt; wstring;</code>  //wstring 类是为了便于使用宽字符集，例如 Unicode 或某些欧洲字符集</p>
<h3 id="string函数"><a href="#string函数" class="headerlink" title="string函数"></a>string函数</h3><p>string 类提供的各种操作函数大致分为八类：构造器和析构器、大小和容量、元素存取、字 符串比较、字符串修改、字符串接合、I/O 操作以及搜索和查找。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名称</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">构造函数</td>
<td style="text-align:left">产生或复制字符串</td>
</tr>
<tr>
<td style="text-align:left">析构函数</td>
<td style="text-align:left">销毁字符串</td>
</tr>
<tr>
<td style="text-align:left">=，assign</td>
<td style="text-align:left">赋以新值</td>
</tr>
<tr>
<td style="text-align:left">Swap</td>
<td style="text-align:left">交换两个字符串的内容</td>
</tr>
<tr>
<td style="text-align:left"><strong>+ =，append( )，push_back()</strong></td>
<td style="text-align:left">添加字符</td>
</tr>
<tr>
<td style="text-align:left">insert ()</td>
<td style="text-align:left">插入字符</td>
</tr>
<tr>
<td style="text-align:left">erase()</td>
<td style="text-align:left">删除字符</td>
</tr>
<tr>
<td style="text-align:left">clear ()</td>
<td style="text-align:left">移除全部字符</td>
</tr>
<tr>
<td style="text-align:left">resize ()</td>
<td style="text-align:left">改变字符数量</td>
</tr>
<tr>
<td style="text-align:left">replace()</td>
<td style="text-align:left">替换字符</td>
</tr>
<tr>
<td style="text-align:left"><strong>+</strong></td>
<td style="text-align:left">串联字符串</td>
</tr>
<tr>
<td style="text-align:left">==，！ =，&lt;，&lt;=，&gt;，&gt;=，<strong>compare()</strong></td>
<td style="text-align:left">比较字符串内容</td>
</tr>
<tr>
<td style="text-align:left"><strong>size()，length()</strong></td>
<td style="text-align:left">返回字符数量</td>
</tr>
<tr>
<td style="text-align:left">max_size ()</td>
<td style="text-align:left">返回字符的最大可能个数</td>
</tr>
<tr>
<td style="text-align:left">empty ()</td>
<td style="text-align:left">判断字符串是否为空</td>
</tr>
<tr>
<td style="text-align:left">capacity ()</td>
<td style="text-align:left">返回重新分配之前的字符容量</td>
</tr>
<tr>
<td style="text-align:left">reserve()</td>
<td style="text-align:left">保留内存以存储一定数量的字符</td>
</tr>
<tr>
<td style="text-align:left"><strong>[ ],at()</strong></td>
<td style="text-align:left">获取字符串元素</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;，getline()</td>
<td style="text-align:left">从 stream 中读取某值</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;</td>
<td style="text-align:left">将值写入 stream</td>
</tr>
<tr>
<td style="text-align:left">copy()</td>
<td style="text-align:left">将内容复制为一个 C - string</td>
</tr>
<tr>
<td style="text-align:left"><strong>c_str()</strong></td>
<td style="text-align:left">将内容以 C - string 形式返回</td>
</tr>
<tr>
<td style="text-align:left">data()</td>
<td style="text-align:left">将内容以字符数组形式返回</td>
</tr>
<tr>
<td style="text-align:left">substr()</td>
<td style="text-align:left">返回子字符串</td>
</tr>
<tr>
<td style="text-align:left"><strong>find()</strong></td>
<td style="text-align:left">搜寻某子字符串或字符</td>
</tr>
<tr>
<td style="text-align:left"><strong>rfind()</strong></td>
<td style="text-align:left">逆向搜寻字符串或字符</td>
</tr>
<tr>
<td style="text-align:left"><strong>find_first_of()**</strong>find_last_of()**</td>
<td style="text-align:left">搜寻第一个/最后一个匹配的字符串</td>
</tr>
<tr>
<td style="text-align:left">begin( )，end()</td>
<td style="text-align:left">提供正向迭代器支持</td>
</tr>
<tr>
<td style="text-align:left">rbegin()，rend()</td>
<td style="text-align:left">提供逆向迭代器支持</td>
</tr>
<tr>
<td style="text-align:left">get_allocator()</td>
<td style="text-align:left">返回配置器</td>
</tr>
</tbody>
</table>
<h3 id="string构造和析构函数"><a href="#string构造和析构函数" class="headerlink" title="string构造和析构函数"></a>string构造和析构函数</h3><ul>
<li>类构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> strs <span class="comment">//生成空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str)</span> <span class="comment">//生成字符串str的复制品</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, stridx)</span> <span class="comment">//将字符串str中始于stridx的部分作为构造函数的初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, strbegin, <span class="built_in">strlen</span>)</span> <span class="comment">//将字符串str中始于strbegin、长度为strlen的部分作为字符串初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr)</span> <span class="comment">//以C_string类型cstr作为字符串s的初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr,char_len)</span>    <span class="comment">//以C_string类型cstr的前char_len个字符串作为字符串s的初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(num, c)</span> <span class="comment">//生成一个字符串，包含num个c字符</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(strs, beg, end)</span>    <span class="comment">//以区间[beg, end]内的字符作为字符串s的初值</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>析构函数<br><code>~string() //销毁所有内存，释放内存</code></li>
</ul>
<h2 id="5种序列容器"><a href="#5种序列容器" class="headerlink" title="5种序列容器"></a>5种序列容器</h2><p>序列容器以线性序列的方式存储元素。它没有对元素进行排序，元素的顺序和存储它们的顺序相同。</p>
<ol>
<li><code>array&lt;T,N&gt;</code> (数组容器) ：是一个长度固定的序列，有 N 个 T 类型的对象，不能增加或删除元素。</li>
<li><code>vector&lt;T&gt;</code> (向量容器) ：是一个长度可变的序列，用来存放T类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。</li>
<li><code>deque&lt;T&gt;</code> (双向队列容器) ：是一个长度可变的、可以自动增长的序列，在序列的两端都不能高效地增加或删除元素。</li>
<li><code>list&lt;T&gt;</code> (链表容器) 是一个长度可变的、由 T 类型对象组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。访问容器中任意元素的速度要比前三种容器慢，这是因为 <code>list&lt;T&gt;</code> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li>
<li><code>forward list&lt;T&gt;</code> (正向链表容器) ：是一个长度可变的、由 T 类型对象组成的序列，它以单链表的形式组织元素，是一类比链表容器快、更节省内存的容器，但是它内部的元素只能从第一个元素开始访问。</li>
</ol>
<h3 id="常用函数成员"><a href="#常用函数成员" class="headerlink" title="常用函数成员"></a>常用函数成员</h3><p>函数成员    array&lt;T,N&gt;    vector<t>    deque<t><br>begin() - 返回幵始迭代器    是    是    是<br>end() - 返回结束迭代器    是    是    是<br>rbegin() - 返回反向’开始迭代器    是    是    是<br>rend() - 返回反向结束迭代器    是    是    是<br>cbegin() - 返M const开始迭代器    是    是    是<br>cend() - 返回const结束迭代器    是    是    是<br>crbegin() - 返回const反向开始迭代器    是    是    是<br>crend() - 返回const反向结束迭代器    是    是    是<br>assign() - 用新元素替换原有内容    -    是    是<br>operator=() - 复制同类型容器的元素，或者用初始化列表替换 现有内容    是    是    是<br>size() - 返回实际元素个数    是    是    是<br>max_size() - 返回元素个数的设大值    是    是    是<br>capacity() - 返回当前容量    -    是    -<br>empty() - 返回true,如果容器中没有元素的话    是    是    是<br>resize() - 改变实际元素的个数    -    是    是<br>shrink _to_fit() - 将内存减少到等于当前元素实际所使用的大小    -    是    是<br>front() - 返回第一个元素的引用    是    是    是<br>back() - 返回铖后一个元素的引用    是    是    是<br>operator<a href=""></a> - 使用索弓丨访问元素    是    是    是<br>at() - 使用经过边界检査的索引访问元素    是    是    是<br>push_back() - 在序列的尾部添加一个元素    -    是    是<br>insert() - 在指定的位置插入一个或多个元素    -    是    是<br>emplace() - 在指定的位置直接生成一个元素    -    是    是<br>emplace_back() - 在序列尾部生成一个元素    -    是    是<br>pop_back() - 移出序列尾部的元素    -    是    是<br>erase() - 移出一个元素或一段元素    -    是    是<br>clear() - 移出所苻的元素，容器大小变为 0    -    是    是<br>swap() - 交换两个容器的所有元素    是    是    是<br>data() - 返回包含元素的内部数组的指针    是    是    -</t></t></p>
<p>函数成员    list<t>    forward list<t><br>begin() - 返回开始迭代器    是    是<br>end() - 返回结束迭代器    是    是<br>rbegin() - 返回反向开始迭代器    是    -<br>rend() - 返回反向结束迭代器    是    -<br>cbegin() - 返回 const 开始结束迭代器    是    是<br>before_begin() - 返回一个指向第一个元素前一个位置的迭代器    -    是<br>cbefore_begin() - 返回一个指向第一个元素前一个位置的const迭代器    -    是<br>cend() - 返回 const 结束迭代器    是    是<br>crbegin() - 返回 const 反向开始迭代器    是    -<br>crend() - 返回 const 反向结束迭代器    是    -<br>assign() - 用新元素替换原有内容    是    是<br>operator=() - 复制同类型容器的元素，或者用初始化列表替换现有内容    是    是<br>size() - 返回实际元素个数    是    -<br>max_size() - 返回元素个数的最大值    是    是<br>resize() - 改变实际元素的个数    是    是<br>empty() - 返回 true，如果容器中没有元素的话    是    是<br>from() - 返回第一个元素的引用    是    是<br>back() - 返回最后一个元素的引用    是    -<br>push_back() - 在序列的潘部添加一个元素    是    -<br>push_front() - 在序列的起始位置添加一个元素    是    是<br>emplace() - 在指矩位置直接生成一个元素    是    -<br>emplace_after() - 在指定位置的后面直接生成一个元素    -    是<br>emplace_back() - 在序列尾部生成一个元素    是    -<br>cmplacc_front() - 在序列的起始位生成一个元索    是    是<br>insert() - 在指定的位置插入一个或多个元素    是    -<br>insert_after() - 在指定位置的后面插入一个或多个元素    -    是<br>pop_back() - 移除序列尾部的元素    是    -<br>pop_front() - 移除序列头部的元素    是    是<br>reverse()-反向元素的顺序    是    是<br>erase() - 移除指定位置的一个元素或一段元素    是    -<br>erase_after() - 移除指定位 1；后面的一个元素或一段元素    -    是<br>remove() - 移除所苻和参数匹配的元素    是    是<br>remove_if() - 移除满足一元函数条件的所有元素    是    是<br>unique() - 移除所有连续重复的元素    是    是<br>clear() - 移除所有的元素，容器大小变为 0    是    是<br>swap() - 交换两个容器的所有元素    是    是<br>sort() - 对元素进行排序    是    是<br>merge() - 合并两个有序容器    是    是<br>splice() - 移动指定位置前面的所有元素到另一个同类型的 list 中    是    -<br>splice_after() - 移动指定位置后面的所有元素到另一个同类型的 list 中    -    是</t></t></p>
<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p>array：<code>std::array&lt;typename, 100&gt; data {};</code></p>
<ul>
<li>通过调用数组对象的成员函数 fill()，可以将所有元素设成给定值 <code>data.fill(0.0);</code></li>
<li>获取元素 <code>data[num]</code><ul>
<li>为了获取时能够检查越界索引值，可以使用成员函数 at()，当传给 at() 的索引是一个越界值时，这时会抛出 std::out_of_rang 异常 <code>data.at(num)</code></li>
</ul>
</li>
</ul>
<p>vector：<code>std::vector&lt;typename&gt; values(num) {1,2,3,...};</code></p>
<ul>
<li>通过调用 reserve() 来增加容器的容量 <code>values.reserve(20)</code></li>
<li>通过调用成员函数 resize() 可以改变容器大小 <code>values.resize(size, num)</code></li>
<li>使用 push_back()、insert()、emplace() 或 emplace_back() 函数来添加一个元素<br><code>values.push_back()</code>  //使用时会调用构造函数和拷贝构造函数<br><code>values.emplace_back()</code>  // 不需要触发构造函数和拷贝构造函数<br><code></code></li>
<li>front() 和 back() 分別返回序列中第一个和最后一个元素的引用 <code>values.front()</code></li>
<li>data() 返回指向数组的指针 <code>values.data()</code></li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>迭代器<br><code>auto first = std::begin(data);</code><br><code>auto last = std::end (data);</code></li>
</ul>
<h2 id="3种容器适配器"><a href="#3种容器适配器" class="headerlink" title="3种容器适配器"></a>3种容器适配器</h2><p>容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。</p>
<ol>
<li><code>stack&lt;T&gt;</code>：是一个封装了 <code>deque&lt;T&gt;</code> 容器的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。<code>stack&lt;T&gt;</code>· 模板定义在头文件 stack 中。</li>
<li><code>queue&lt;T&gt;</code>：是一个封装了 <code>deque&lt;T&gt;</code> 容器的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器。<code>queue&lt;T&gt;</code> 模板定义在头文件 queue 中。</li>
<li><code>priority_queue&lt;T&gt;</code>：是一个封装了 <code>vector&lt;T&gt;</code> 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。<code>priority_queue&lt;T&gt;</code> 模板定义在头文件 queue 中。</li>
</ol>
<h2 id="4种map容器"><a href="#4种map容器" class="headerlink" title="4种map容器"></a>4种map容器</h2><p><code>map&lt;K，T&gt;</code>容器，保存的是 <code>pair&lt;const K，T&gt;</code> 类型的元素。<code>pair&lt;const K,T&gt;</code> 封装了一对键对象，键的类型是 K，对象的类型是 T。每个键都是唯一的，所以不允许有重复的键；但可以保存重复的对象，只要它们的键不同。map 容器中的元素都是有序的，元素在容器内的顺序是通过比较键确定的。默认使用 less<k> 对象比较。<br>multimap&lt;K，T&gt; 容器和 map&lt;K，T&gt; 容器类似，也会对元素排序。它的键必须是可比较的，元素的顺序是通过比较键确定的。和 map&lt;K，T&gt; 不同的是，multimap&lt;K，T&gt; 允许使用重复的键。因此，一个 multimap 容器可以保存多个具有相同键值的 <const k,t=""> 元素。<br>unordered_map&lt;K，T&gt; 中 pair&lt; const K，T&gt;元素的顺序并不是直接由键值确定的，而是由键值的哈希值决定的。哈希值是由一个叫作哈希的过程生成的整数，本章后面会解释这一点。unordered_map&lt;K，T&gt;不允许有重复的键。<br>unordered_multimap&lt;K,T&gt; 也可以通过键值生成的哈希值来确定对象的位置，但它允许有重复的键。</const></k></p>
<h2 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h2><p>set 容器是关联容器，其中的对象是对象它们自己的键</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h2 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h2><h2 id="数值、时间和复数"><a href="#数值、时间和复数" class="headerlink" title="数值、时间和复数"></a>数值、时间和复数</h2><h2 id="C-常用算法和algorithm库"><a href="#C-常用算法和algorithm库" class="headerlink" title="C++常用算法和algorithm库"></a>C++常用算法和algorithm库</h2><hr>
<p>参考资料<br><a href="http://c.biancheng.net/stl/" target="_blank" rel="noopener">C语言中文网</a><br>C++ Primer Plus 第6版中文版<br>学校教材</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>KevinW</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/03/20/cpp-stl/">https://hyqskevin.github.io/2019/03/20/cpp-stl/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</li></ul></div><br><div class="tags"><a href="../../../../tags/c/">c++</a></div><div class="post-nav"><a class="pre" href="../../21/divide/">分治和递归基础算法</a><a class="next" href="../../19/hashtable/">散列表基础算法</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 学习分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../categories/Adobe/">Adobe</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/github-repo/">github-repo</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/language-learning/">language-learning</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/notes/">notes</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/others/">others</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/paper/">paper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/practice/">practice</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/repo/">repo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/study/">study</a><span class="category-list-count">15</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="../../../../tags/mysql/" style="font-size: 15px;">mysql</a> <a href="../../../../tags/others/" style="font-size: 15px;">others</a> <a href="../../../../tags/Kaggle/" style="font-size: 15px;">Kaggle</a> <a href="../../../../tags/time-series/" style="font-size: 15px;">time_series</a> <a href="../../../../tags/ensemble-learning/" style="font-size: 15px;">ensemble_learning</a> <a href="../../../../tags/bp-nn/" style="font-size: 15px;">bp_nn</a> <a href="../../../../tags/hexo/" style="font-size: 15px;">hexo</a> <a href="../../../../tags/bootstrap2-0/" style="font-size: 15px;">bootstrap2.0</a> <a href="../../../../tags/php/" style="font-size: 15px;">php</a> <a href="../../../../tags/book/" style="font-size: 15px;">book</a> <a href="../../../../tags/python/" style="font-size: 15px;">python</a> <a href="../../../../tags/pandas/" style="font-size: 15px;">pandas</a> <a href="../../../../tags/session/" style="font-size: 15px;">session</a> <a href="../../../../tags/cookie/" style="font-size: 15px;">cookie</a> <a href="../../../../tags/slam/" style="font-size: 15px;">slam</a> <a href="../../../../tags/Linux-device/" style="font-size: 15px;">Linux_device</a> <a href="../../../../tags/laravel/" style="font-size: 15px;">laravel</a> <a href="../../../../tags/machine-learning/" style="font-size: 15px;">machine_learning</a> <a href="../../../../tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="../../../../tags/c/" style="font-size: 15px;">c++</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="../../../04/05/ptr/">c++中的智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="../../25/cpp-oop/">c++ 面向对象的一些特性</a></li><li class="post-list-item"><a class="post-list-link" href="../../24/bintree/">二叉树的相关操作</a></li><li class="post-list-item"><a class="post-list-link" href="../../24/bintree2/">基于二叉树的衍生算法</a></li><li class="post-list-item"><a class="post-list-link" href="../../21/two-divide/">二分查找策略</a></li><li class="post-list-item"><a class="post-list-link" href="../../21/divide/">分治和递归基础算法</a></li><li class="post-list-item"><a class="post-list-link" href="">cpp_stl</a></li><li class="post-list-item"><a class="post-list-link" href="../../19/hashtable/">散列表基础算法</a></li><li class="post-list-item"><a class="post-list-link" href="../../18/datasets-benchmarks/">Autonomous Vehicles translate -- datasets & bechmarks</a></li><li class="post-list-item"><a class="post-list-link" href="../../17/sort/">各类排序算法实践</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="../../../../." rel="nofollow">MonoShow.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="../../../../js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="../../../../js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="../../../../js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-2" count="50" src="//lib.baomitu.com/canvas-nest.js/2.0.3/canvas-nest.umd.js"></script><script type="text/javascript" src="../../../../js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="../../../../js/smartresize.js?v=0.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":100,"height":200},"mobile":{"show":true},"log":false});</script></body></html>