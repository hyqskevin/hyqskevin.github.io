<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Kevin W build this air-castle to collect infos &amp; photos"><title>c++中的智能指针 | MonoShow</title><link rel="stylesheet" type="text/css" href="../../../../css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="../../../../favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="../../../../favicon.ico"><link rel="apple-touch-icon" href="../../../../apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="../../../../apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="../../../../atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">c++中的智能指针</h1><a id="logo" href="../../../../.">MonoShow</a><p class="description">Monologue from Kevin_W</p></div><div id="nav-menu"><a class="current" href="../../../../."><i class="fa fa-home"> 时间线</i></a><a href="../../../../archives/"><i class="fa fa-archive"> 档案袋</i></a><a href="../../../../photo/"><i class="fa fa-camera"> Ins摄影集</i></a><a href="../../../../categories/language-learning/"><i class="fa fa-book"> 看原著了嘛</i></a><a href="../../../../categories/github-repo/"><i class="fa fa-github"> 码代码了嘛</i></a><a href="../../../../categories/paper/"><i class="fa fa-file-text"> 翻译论文了嘛</i></a><a href="../../../../about/"><i class="fa fa-user"> 自己的碎碎念</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">c++中的智能指针</h1><div class="post-meta">Apr 5, 2019<span> | </span><span class="category"><a href="../../../../categories/study/">study</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 9</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#std-auto-ptr"><span class="toc-number">1.</span> <span class="toc-text">std::auto_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用示例"><span class="toc-number">1.1.</span> <span class="toc-text">使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不能使用-操作符"><span class="toc-number">1.2.</span> <span class="toc-text">不能使用 = 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#release-函数问题"><span class="toc-number">1.3.</span> <span class="toc-text">release() 函数问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-shared-ptr"><span class="toc-number">2.</span> <span class="toc-text">std::shared_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-weak-ptr"><span class="toc-number">3.</span> <span class="toc-text">std::weak_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-unique-ptr"><span class="toc-number">4.</span> <span class="toc-text">std::unique_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boost-scoped-ptr"><span class="toc-number">5.</span> <span class="toc-text">boost::scoped_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boost-shared-ptr"><span class="toc-number">6.</span> <span class="toc-text">boost::shared_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boost-scoped-array"><span class="toc-number">7.</span> <span class="toc-text">boost::scoped_array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boost-shared-array"><span class="toc-number">8.</span> <span class="toc-text">boost::shared_array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boost-weak-ptr"><span class="toc-number">9.</span> <span class="toc-text">boost::weak_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boost-intrusive-ptr"><span class="toc-number">10.</span> <span class="toc-text">boost:: intrusive_ptr</span></a></li></ol></div></div><div class="post-content"><p>由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，用智能指针便可以有效缓解这类问题。</p>
<p>对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。</p>
<a id="more"></a>
<p>访问智能指针包含的裸指针则可以用 get() 函数</p>
<p>智能指针包含了 reset() 方法，如果不传递参数（或者传递 NULL），则智能指针会释放当前管理的内存。如果传递一个对象，则智能指针会释放当前对象，来管理新传入的对象。</p>
<ul>
<li>编写测试类来辅助分析</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Simple(<span class="keyword">int</span> param = <span class="number">0</span>) &#123;</span><br><span class="line">    number = param;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ~Simple() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrintSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PrintSomething: "</span> &lt;&lt; info_extend.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> info_extend;</span><br><span class="line">  <span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h2><p>包含头文件 <code>#include&lt;memory&gt;</code> 便可以使用<br><code>std::auto_ptr</code> 能够方便的管理单个堆内存对象</p>
<p>用法一：<br><code>std::auto_ptr&lt;MyClass&gt;m_example(new MyClass());</code></p>
<p>用法二：<br><code>std::auto_ptr&lt;MyClass&gt;m_example;</code><br><code>m_example.reset(new MyClass());</code></p>
<p>用法三（指针的赋值操作）：<br><code>std::auto_ptr&lt;MyClass&gt;m_example1(new MyClass());</code><br><code>std::auto_ptr&lt;MyClass&gt;m_example2(new MyClass());</code><br><code>m_example2=m_example1;</code></p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));   <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;             <span class="comment">// 判断智能指针是否为空</span></span><br><span class="line">    my_memory-&gt;PrintSomething();  <span class="comment">// 使用 operator-&gt; 调用智能指针对象中的函数</span></span><br><span class="line">    my_memory.get()-&gt;info_extend = <span class="string">"Addition"</span>; <span class="comment">// 使用 get() 返回裸指针，然后给内部对象赋值</span></span><br><span class="line">    my_memory-&gt;PrintSomething();               <span class="comment">// 再次打印，表明上述赋值成功</span></span><br><span class="line">    (*my_memory).info_extend += <span class="string">" other"</span>;      <span class="comment">// 使用 operator 返回智能指针内部对象，然后用“.”调用智能指针对象中的函数</span></span><br><span class="line">    my_memory-&gt;PrintSomething();               <span class="comment">// 再次打印，表明上述赋值成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;                          <span class="comment">// my_memory 栈对象即将结束生命期，析构堆对象 Simple(1)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果为：<br>Simple: 1<br>PrintSomething:<br>PrintSomething: Addition<br>PrintSomething: Addition other<br>~Simple: 1</li>
</ul>
<h3 id="不能使用-操作符"><a href="#不能使用-操作符" class="headerlink" title="不能使用 = 操作符"></a>不能使用 = 操作符</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory2;   <span class="comment">// 创建一个新的 my_memory2 对象</span></span><br><span class="line">    my_memory2 = my_memory;             <span class="comment">// 复制旧的 my_memory 给 my_memory2</span></span><br><span class="line">    my_memory2-&gt;PrintSomething();       <span class="comment">// 输出信息，复制成功</span></span><br><span class="line">    my_memory-&gt;PrintSomething();        <span class="comment">// 崩溃</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>my_memory2 = my_memory</code>这行代码，my_memory2 完全夺取了 my_memory 的内存管理所有权，导致 my_memory 悬空，最后使用时导致崩溃。</p>
<h3 id="release-函数问题"><a href="#release-函数问题" class="headerlink" title="release() 函数问题"></a>release() 函数问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    my_memory.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                          <span class="comment">//最终执行结果为 Simple：1，没有被析构，导致内存泄露</span></span><br></pre></td></tr></table></figure>
<p>调用 release() 函数释放内存，不会释放对象，仅仅归还所有权，要自己delete或使用reset()函数销毁对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码修正</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    Simple* temp_memory = my_memory.release();</span><br><span class="line">    <span class="keyword">delete</span> temp_memory;</span><br><span class="line">    <span class="comment">// 或者直接 my_memory.reset();  释放 my_memory 内部管理的内存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意事项<br>使用 std::auto_ptr 时，<strong>绝对不能使用“operator=”操作符</strong>，这会夺取内存管理所有权<br>std::auto_ptr 的 release() 函数不会释放对象，仅仅归还所有权。<br>std::auto_ptr 最好不要当成参数传递（读者可以自行写代码确定为什么不能）。<br>std::auto_ptr 的“operator=”问题，有其管理的对象不能放入 std::vector 等容器中。<br>C++11中，std::auto_ptr已经被弃用</li>
</ul>
<hr>
<p>自C++11起，C++标准提供两大类型的智能指针：shared_ptr和unique_ptr</p>
<hr>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>shared_ptr实现共享式拥有（shared ownership）概念。<strong>多个智能指针可以指向相同对象</strong>，该对象和其相关资源会在“最后一个引用（reference）被销毁”时候释放。为了在结构复杂的情境中执行上述工作，标准库提供了weak_ptr、bad_weak_ptr和enable_shared_from_this等辅助类。</p>
<p>shared_ptr本身提供默认内存释放器（default deleter），调用的是delete，也可以自定义释放器</p>
<p>默认内存释放器并<strong>不能释放数组内存空间</strong>，要我们自己提供内存释放器</p>
<ul>
<li><p>成员函数<br>use_count 返回引用计数的个数<br>unique 返回是否是独占所有权( use_count 为 1)<br>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少<br>get 返回内部对象(指针)</p>
</li>
<li><p>示例</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp0(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp0);               <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp1);               <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp2);               <span class="comment">// 11</span></span><br><span class="line">sp1.swap(sp0);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp0);               <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp1);               <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp2);               <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp3(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">22</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp4 = sp3;     <span class="comment">// 或 auto sp4 = sp3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp3);               <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp4);               <span class="comment">// 22</span></span><br><span class="line">sp3.reset();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp3.use_count());    <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp4.use_count());    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp3);                <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意事项<br>shared_ptr 会因循环引用造成无法释放资源<br>与 weak_ptr 一起工作时, weak_ptr 在使用前需要检查合法性<br>shared_ptr 不支持数组, 如果使用数组, 需要自定义删除器</li>
</ul>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</p>
<p>weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象. 注意, weak_ptr 在使用前需要检查合法性。</p>
<p>weak_ptr 支持拷贝或赋值, 但不会影响对应的 shared_ptr 内部对象的计数。</p>
<ul>
<li><p>成员函数<br>expired 用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false<br>lock 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同。<br>use_count 返回与 shared_ptr 共享的对象的引用计数.<br>reset 将 weak_ptr 置空.</p>
</li>
<li><p>使用weak_ptr解决shared_ptr因循环不能释放资源的问题<br>使用 shared_ptr 时, shared_ptr 为强引用, 如果存在循环引用, 将导致内存泄露. 而 weak_ptr 为弱引用, 可以避免此问题</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CA()&#123;&#125;</span><br><span class="line">    ~CA()&#123;PRINT_FUN();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;CB&gt; m_spb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CB()&#123;&#125;;</span><br><span class="line">    ~CB()&#123;PRINT_FUN();&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CA&gt; m_spa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CA&gt; spa(<span class="keyword">new</span> CA);  <span class="comment">// 通过调用weak_ptr，释放CA内存时不影响CB</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CB&gt; spb(<span class="keyword">new</span> CB);</span><br></pre></td></tr></table></figure>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>unique_ptr实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（resourece leak）——例如“以new创建对象后因为发生异常而忘记调用delete”——特别有用。</p>
<p>unique_ptr 不支持拷贝和赋值，但是可以调用 release 或 reset 将指针的所有权从一个(非 const) unique_ptr 转移到另一个<br><code>std::unique_ptr&lt;A&gt; up1(new A(5));</code><br><code>std::unique_ptr&lt;A&gt; up2(up1);</code> // 错误, unique_ptr 不支持拷贝<br><code>std::unique_ptr&lt;A&gt; up2 = up1;</code> // 错误, unique_ptr 不支持赋值<br><code>std::unique_ptr&lt;int&gt; up2(up1.release());</code> // 正确</p>
<p>unique_ptr 不支持拷贝, 但是可以从函数中返回, 甚至返回局部对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt; Clone(<span class="keyword">const</span> Ty&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">　<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt; temp = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt;(<span class="keyword">new</span> Ty(obj));</span><br><span class="line">　<span class="keyword">return</span> temp;</span><br><span class="line">  <span class="comment">// 或直接 return std::unique_ptr&lt;Ty&gt;(new Ty(obj))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unique_ptr 支持管理数组</p>
<ul>
<li><p>成员函数<br>get 获得内部对象的指针<br>release 放弃内部对象的所有权，将内部指针置为空, 返回所内部对象的指针, 此指针需要手动释放<br>reset 销毁内部对象并接受新的对象的所有权(如果使用缺省参数的话，也就是没有任何对象的所有权, 此时仅将内部对象释放, 并置为空)<br>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br>std::move(name) 所有权转移(通过移动语义), 所有权转移后，变成“空指针”</p>
</li>
<li><p>防内存泄漏代码改进</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// 内存泄露</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// ptr成空悬指针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line">  ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 unique_ptr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="boost-scoped-ptr"><a href="#boost-scoped-ptr" class="headerlink" title="boost::scoped_ptr"></a>boost::scoped_ptr</h2><h2 id="boost-shared-ptr"><a href="#boost-shared-ptr" class="headerlink" title="boost::shared_ptr"></a>boost::shared_ptr</h2><h2 id="boost-scoped-array"><a href="#boost-scoped-array" class="headerlink" title="boost::scoped_array"></a>boost::scoped_array</h2><h2 id="boost-shared-array"><a href="#boost-shared-array" class="headerlink" title="boost::shared_array"></a>boost::shared_array</h2><h2 id="boost-weak-ptr"><a href="#boost-weak-ptr" class="headerlink" title="boost::weak_ptr"></a>boost::weak_ptr</h2><h2 id="boost-intrusive-ptr"><a href="#boost-intrusive-ptr" class="headerlink" title="boost:: intrusive_ptr"></a>boost:: intrusive_ptr</h2><p>参考资料：<br><a href="https://blog.csdn.net/xt_xiaotian/article/details/5714477" target="_blank" rel="noopener">https://blog.csdn.net/xt_xiaotian/article/details/5714477</a><br><a href="https://www.cnblogs.com/xiehongfeng100/p/4645555.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiehongfeng100/p/4645555.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930361.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930361.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930372.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930372.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930388.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930388.html</a></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>KevinW</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/04/05/ptr/">https://hyqskevin.github.io/2019/04/05/ptr/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</li></ul></div><br><div class="tags"><a href="../../../../tags/c/">c++</a></div><div class="post-nav"><a class="pre" href="../../11/flask-learning2/">Flask Web 学习笔记2 -- URL与视图函数映射</a><a class="next" href="../../../03/31/flask-learning1/">Flask Web 学习笔记1 -- 环境</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 学习分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../categories/Adobe/">Adobe</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/github-repo/">github-repo</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/language-learning/">language-learning</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/notes/">notes</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/others/">others</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/paper/">paper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/practice/">practice</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/repo/">repo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/study/">study</a><span class="category-list-count">17</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="../../../../tags/php/" style="font-size: 15px;">php</a> <a href="../../../../tags/others/" style="font-size: 15px;">others</a> <a href="../../../../tags/book/" style="font-size: 15px;">book</a> <a href="../../../../tags/Kaggle/" style="font-size: 15px;">Kaggle</a> <a href="../../../../tags/flask/" style="font-size: 15px;">flask</a> <a href="../../../../tags/time-series/" style="font-size: 15px;">time_series</a> <a href="../../../../tags/ensemble-learning/" style="font-size: 15px;">ensemble_learning</a> <a href="../../../../tags/bp-nn/" style="font-size: 15px;">bp_nn</a> <a href="../../../../tags/hexo/" style="font-size: 15px;">hexo</a> <a href="../../../../tags/bootstrap2-0/" style="font-size: 15px;">bootstrap2.0</a> <a href="../../../../tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="../../../../tags/mysql/" style="font-size: 15px;">mysql</a> <a href="../../../../tags/python/" style="font-size: 15px;">python</a> <a href="../../../../tags/pandas/" style="font-size: 15px;">pandas</a> <a href="../../../../tags/session/" style="font-size: 15px;">session</a> <a href="../../../../tags/cookie/" style="font-size: 15px;">cookie</a> <a href="../../../../tags/slam/" style="font-size: 15px;">slam</a> <a href="../../../../tags/Linux-device/" style="font-size: 15px;">Linux_device</a> <a href="../../../../tags/c/" style="font-size: 15px;">c++</a> <a href="../../../../tags/laravel/" style="font-size: 15px;">laravel</a> <a href="../../../../tags/machine-learning/" style="font-size: 15px;">machine_learning</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="../../11/flask-learning2/">Flask Web 学习笔记2 -- URL与视图函数映射</a></li><li class="post-list-item"><a class="post-list-link" href="">c++中的智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="../../../03/31/flask-learning1/">Flask Web 学习笔记1 -- 环境</a></li><li class="post-list-item"><a class="post-list-link" href="../../../03/25/cpp-oop/">c++ 面向对象的一些特性</a></li><li class="post-list-item"><a class="post-list-link" href="../../../03/24/bintree2/">基于二叉树的衍生算法</a></li><li class="post-list-item"><a class="post-list-link" href="../../../03/24/bintree/">二叉树的相关操作</a></li><li class="post-list-item"><a class="post-list-link" href="../../../03/21/two-divide/">二分查找策略</a></li><li class="post-list-item"><a class="post-list-link" href="../../../03/21/divide/">分治和递归基础算法</a></li><li class="post-list-item"><a class="post-list-link" href="../../../03/20/cpp-stl/">cpp_stl</a></li><li class="post-list-item"><a class="post-list-link" href="../../../03/19/hashtable/">散列表基础算法</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="../../../../." rel="nofollow">MonoShow.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="../../../../js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="../../../../js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="../../../../js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-2" count="50" src="//lib.baomitu.com/canvas-nest.js/2.0.3/canvas-nest.umd.js"></script><script type="text/javascript" src="../../../../js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="../../../../js/smartresize.js?v=0.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":100,"height":200},"mobile":{"show":true},"log":false});</script></body></html>