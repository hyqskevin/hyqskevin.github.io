<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[book-list]]></title>
    <url>%2F2019%2F02%2F16%2Fbook-list%2F</url>
    <content type="text"><![CDATA[个人书库，收集正在看的和准备要看的好书，不定期更新 【2018年《华盛顿邮报》推荐书单】本年度推荐的书：《Good Aand Mad》（《善良与狂暴》）、《The Library Book》（图书馆的书）、《The line becomes a river》（《一条线变成一条河》）、《The maze at Windermere》（《温德米尔的迷宫》）、《On desperate ground》（《在绝望的战场上》）、《One person,no vote》（《一人，零票》）、《The Overstory》（《上层林冠》）、《A place for US》（《属于我们的地方》）、《There There》（《好了，没事了》）、《Washington Black》（《华盛顿黑人》） 【2018年《华尔街日报》十佳书单】本年度推荐的书：《不对称》(ASYMMETRY)《丘吉尔传》(CHURCHILL)《暴风骤雨》(CLOUDBURSTS)《意识的本能》(THE CONSCIOUSNESS INSTINCT)《弗雷德里克·道格拉斯传》(FREDERICK DOUGLASS)《天赐良机》(GODSEND)《伊庇鲁斯的挽歌》(LAMENT FROM EPIRUS)《我自己的生活》(A LIFE OF MY OWN)《头号爱国者》(PATRIOT NUMBER ONE)《暗影季节》(SEASON OF THE SHADOW) 【2018《金融时报》和麦肯锡年度“最佳商业图书奖”入围书单 】本年度推荐的书：《美国资本主义》（Capitalism in America）《崩溃》（Crashed）《短命的银行》（The Bank That Lived A Little）《受损的商品》（Damaged Goods）《滴血成金》（Bad Blood）《十亿美元鲸鱼》（Billion Dollar Whale）：《简斯维尔》（Janesville），《认清事实》（Factfulness）：《万物价值》（The Value of Everything）《给人民发钱》（Give People Money）《新势力》（New Power）《零工》（Gigged）《亿万富翁的天下》（The Billionaire Raj）《崛起的五千万》（Fifty Million Rising）《极乐男权》（Brotopia）《谁是迈克尔·奥维茨？》（Who Is Michael Ovitz?） 【2018年比尔·盖茨推荐的5本书】本年度推荐的书：《21世纪的21一个教训 21 Lessons for the 21st Century》《一扫光的武器 Army of None_ Autonomous Weapons and the Future of War》《Educated 》《Bad Blood》《Meditation and Mindfulness》 【《经济学人》2018年推荐书单】《Moneyland》《Enlightenment Now》《Fascism: A Warning》《First Raise a Flag》《Into the Hands of the Soldiers》《Shadows of Empire》《A History of America in 100 Maps》《Pogrom》《The China Mission》《Rise and Kill First》《We the Corporations》《AI Superpowers》《Radical Markets》《EuroTragedy》《Crashed》《The Wife’s Tale: A Personal History》《Educated》《Barracoon》《Napoleon: A Life》《Churchill: Walking with Destiny》《Gandhi》《The Spy and the Traitor》 【彭博盘点2018年书单】《high growth handbook》《The Coddling of the American Mind: How Good Intentions and Bad Ideas Are Setting Up a Generation for Failure》《Our Towns: A 100,000-Mile Journey Into the Heart of America》《Educated: A Memoir》《Stubborn Attachments: A Vision for a Society of Free, Prosperous, and Responsible Individuals》《Refugee》《Factfulness: Ten Reasons We’re Wrong About the World—and Why Things Are Better Than You Think》《The Efficiency Paradox: What Big Data Can’t Do》《The Third Plate: Field Notes on the Future of Food》《Inspired: How to Create Tech Products Customers Love》《Bad Blood: Secrets and Lies in a Silicon Valley Startup》《Grant》《Principles: Life and Work》《The Coddling of the American Mind: How Good Intentions and Bad Ideas Are Setting Up a Generation for Failure》《The Culture Code: The Secrets of Highly Successful Groups》《Hit Refresh: The Quest to Rediscover Microsoft’s Soul and Imagine a Better Future for Everyone》《Keeping At It: The Quest for Sound Money and Good Government》《New Power: How Power Works in Our Hyperconnected World—and How to Make It Work for You》《The Complete Personal Memoirs of Ulysses S. Grant》《The Book of Why: The New Science of Cause and Effect》《Powerful: Building a Culture of Freedom and Responsibility》《The Courage to Be Disliked: The Japanese Phenomenon That Shows You How to Change Your Life and Achieve Real 》《Happiness》《Dare to Lead: Brave Work. Tough Conversations. Whole Hearts.》《Without Precedent: Chief Justice John Marshall and His Times》《The Largesse of the Sea Maiden: Stories》《Paris in the Present Tense》《Destined for War: Can America and China Escape Thucydides’s Trap?》《Small Fry》《Life 3.0: Being Human in the Age of Artificial Intelligence》《Love and Ruin》 来源：jianshu.com/p/0dc43df2c3eb]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[move to windows]]></title>
    <url>%2F2019%2F02%2F14%2Fmove-to-windows%2F</url>
    <content type="text"><![CDATA[由于archlinux上出现了一些bug，而且因为跑SLAM，安装包占去了过多存储空间，临时决定将blog移植到Windows上来方便经常更新。 install necessary modules download nodejs and install download git and install Win+R open cmd to the right direction $ mkdir blog$ npm install hexo -g$ hexo -v //check info$ npm install //install necessary components$ hexo init //initialize folder$ hexo g //Start processing related modules $ npm install //install necessary components$ npm install hexo-deployer-git --save // deploy to git$ npm install hexo-generator-feed --save // build RSS$ npm install hexo-generator-sitemap --save // build sitemap add ssh key$ ssh-keygen -t rsa -C "your email address"$ cat /home/xxx/.ssh/id_rsa.pub //check your key load key to Github (default on Github &amp; default you can use Github) $ ssh -T git@github.com set id &amp; email$ git config --global user.name "your id"$ git config --global user.email "your email" copy previous files copy source files to the new catalog (as follows) _config.yml package.json node_modules scaffolds source themes type hexo s to check]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP & MySQL learning notes (3)]]></title>
    <url>%2F2019%2F01%2F21%2Fphp-notes2%2F</url>
    <content type="text"><![CDATA[-基础笔记-慕课网 PHP基础语法巩固(2) 课堂笔记，包含会话，文件，数据库操作等细碎的摘要 会话控制sessionHTTP是无状态协议，HTTP不知道请求来自哪个客户端，Session提供在PHP脚本中定义全局变量的方法，使全局变量在同一个Session中对所有的PHP脚本文件内都有效,解决HTTP断链接的问题Session可以减轻服务器压力，缺点在于每次请求会传输大量重复的信息Session允许通过将数据存储在HTTP服务器中，使得用户在回话过程中保持该数据 session_start();$_SESSION['id'] = 'info' 每一次请求有SessionID区分不同的信息，SessionID存储到cookie中，Session数据通过变量$_SESSION存储到Session文件中 SessionID： PHP回话启用 检查SessionID，如果没有启动新会话 + SessionID 一直使用的SessionID相同，默认会话在活动，超过一定时间则视为过期 默认情况下SessionID存在Cookie中，也可以存在URL中 Session函数： bool session_start() //启动新会话或重用现有会话string session_id(string $id) //获取/设置当前会话的idstring session_name(string $name) //读取/设置会话名称bool session_destroy(void) //销毁一个会话中的全部数据session.auto_start(bool) //指定会话模块在请求开始时自动启动session.name(string) //指定会话名用作cookie名字session.save_handler(string) //定义用来存储和获取与会话关联的数据处理器的名字session.save_path(string) //定义传递给存储处理器的参数session.gc_maxlifetime(int) //指定数据存在时长session.gc_probability(int) //定义在会话初始化时启动垃圾回收进程的概率 必须在session_start()函数之前调用session_name()函数 垃圾回收进程概率计算：gc_probability/gc_divisor cookiecookie是服务器发送到用户浏览器上并保存在浏览器里的数据，会在浏览器下一次请求时一起发送到服务器上 session是存储在客户端的数据cookie是存储在服务器端的数据 cookie的用途：会话状态管理，个性化设置，浏览器行为跟踪 bool setcookie(string $name,string $value,[$expire,$path,$domain]) //名称，值，生命周期，路径，域名范围 文件操作API 文件信息相关 filetype($filename); //获取文件的类型；返回的是文件的类型，可能的值有 fifo，char，dir，block，link，file 和 unknown。如果 stat 调用失败或者文件类型未知的话 filetype() 还会产生一个 E_NOTICE 消息。filesize($filename); //获取文件的大小；返回的是字节数。如果出错返回 FALSE 并生成一条 E_WARNING 级的错误。filectime($filename); //获取文件的创建时间；返回的是时间戳。在失败时返回 FALSE。 时间以 Unix 时间戳的方式返回。filemtime($filename); //获取文件的修改时间；返回的是时间戳。在失败时返回 FALSE。fileatime($filename); //获取文件的最后访问时间；返回的是时间戳。在失败时返回 FALSE。//可以使用date()函数修改日期和时区；date_default_timezone_set('PRC');date('Y-m-d H:i:s',filectime($filename));is_readable($filename); //检测文件是否可读；返回布尔值is_writable($filename)/is_writeable($filename); //检测文件是否可写；返回布尔值is_executable($filename); //检测文件是否可执行；返回布尔值is_file($filename); //检测是否为文件；返回布尔值 文件路经相关 pathinfo($filename, $options); //获取文件路径相关信息；返回一个关联数组，包含有 path 的信息//options如果指定了，将会返回指定元素；它们包括：PATHINFO_DIRNAME，PATHINFO_BASENAME 和 PATHINFO_EXTENSION 或 PATHINFO_FILENAME。dirname($path); //返回文件中的路径部分basename($filename,$suffix); //返回路径文件名部分；file_exists($filename); //检测文件或者目录是否存在；返回布尔值 文件操作相关 touch($filename，$time,$atime); //设定文件的访问和修改时间，如果文件不存在，则会创建文件；返回布尔值//time: 使用当前系统的时间。//atime: 访问时间会被设为 atime，unlink($filename,$context); //删除文件；返回布尔值；rename($oldname,$newname，$path); //重命名或者剪切(给剪切path)一个文件或目录;返回布尔值；copy($filename); //拷贝一个文件或者目录；返回布尔值； 文件内容操作相关 $handle = fopen($filename, r|r+|w|...) //打开指定文件fread($handle, $size) //读取文件内容fwrite($handle, 'info',$size)|fput() //写入内容,之前有内容会覆盖ftell($handle) //读取指针位置fseek($handle,$size) //移动指针的位置fpassthru() //输出文件指针处的所有剩余数据rewind($handle) //重置文件指针ftruncate($handle,$size) //将文件截断到指定长度fgetc($handle) //读取一个字符fgets($handle) //读取一行字符fgetss($handle) //读取一行并过滤掉 HTML 标记fgetcsv() //从文件指针中读入一行并解析 CSV 字段fputcsv() //将行格式化为 CSV 并写入文件指针file_get_contents() //将整个文件读入一个字符串file_put_contents() //将一个字符串写入文件，和依次调用 fopen()，fwrite() 以及 fclose() 功能一样。file() //把整个文件读入一个数组中readfile() //读取文件并写入到输出缓冲feof($handle) //测试文件指针是否到了文件结束的位置fclose() //关闭文件parse_ini_file($filename) //解析一个配置文件parse_ini_string($ini) //解析配置字符串highlight_string($str) //字符串的语法高亮highlight_file() //语法高亮一个文件 ‘r’：只读方式打开，将文件指针指向文件头。‘r+’：读写方式打开，将文件指针指向文件头。‘w’：写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。‘w+’：读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。‘a’：写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。‘a+’：读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。‘x’：创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给 底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。‘x+’：创建并以读写方式打开，其他的行为和 ‘x’ 一样。 函数和类的封装 创建文件 可以用touch()创建，也可以直接file_get_contents() function create_file(string $filename)&#123; //检测文件是否存在，不存在则创建 if(file_exists($filename))&#123; return false; &#125; //检测目录是否存在，不存在则创建 if(!file_exists(dirname($filename)))&#123; //创建目录，可以创建多级 mkdir(dirname($filename),0777,true); &#125; // if(touch($filename))&#123; // return true; // &#125; // return false; if(file_put_contents($filename,'')!==false)&#123; return true; &#125; return false;&#125; 删除文件 function del_file(string $filename)&#123; //检测删除的文件是否存在,并且是否有权限操作 if(!file_exists($filename)||!is_writable($filename))&#123; return false; &#125; if(unlink($filename))&#123; return true; &#125; return false;&#125; 拷贝文件 function copy_file(string $filename,string $dest)&#123; //检测$dest是否是目标并且这个目录是否存在，不存在则创建 if(!is_dir($dest))&#123; mkdir($dest,0777,true); //0777为权限 &#125; $destName=$dest.DIRECTORY_SEPARATOR.basename($filename); //检测目标路径下是否存在同名文件 if(file_exists($destName))&#123; return false; &#125; //拷贝文件 if(copy($filename,$destName))&#123; return true; &#125; return false;&#125; 重命名文件 function rename_file(string $oldName,string $newName)&#123; //检测原文件并且存在 if(!is_file($oldName))&#123; return false; &#125; //得到原文件所在的路径 $path=dirname($oldName); $destName=$path.DIRECTORY_SEPARATOR.$newName; //路径下有文件名，重命名失败 if(is_file($destName))&#123; return false; &#125; if(rename($oldName,$newName))&#123; return true; &#125; return false;&#125; 剪切文件 function cut_file(string $filename,string $dest)&#123; //检查文件和路径是否都存在 if(!is_file($filename))&#123; return false; &#125; if(!is_dir($dest))&#123; mkdir($dest,0777,true); &#125; $destName=$dest.DIRECTORY_SEPARATOR.basename($filename); if(is_file($destName))&#123; return false; &#125; if(rename($filename,$destName))&#123; return true; &#125; return false;&#125; 返回文件信息 function get_file_info(string $filename)&#123; //检查文件存在且可读 if(!is_file($filename)||!is_readable($filename))&#123; return false; &#125; return [ 'atime'=&gt;date("Y-m-d H:i:s",fileatime($filename)), 'mtime'=&gt;date("Y-m-d H:i:s",filemtime($filename)), 'ctime'=&gt;date("Y-m-d H:i:s",filectime($filename)), 'size'=&gt;trans_byte(filesize($filename)), 'type'=&gt;filetype($filename) ];&#125; 字节转换 function trans_byte(int $byte,int $precision=2)&#123; $kb=1024; $mb=1024*$kb; $gb=1024*$mb; $tb=1024*$gb; if($byte&lt;$kb)&#123; return $byte.'B'; &#125;elseif($byte&lt;$mb)&#123; return round($byte/$kb,$precision).'KB'; &#125;elseif($byte&lt;$gb)&#123; return round($byte/$mb,$precision).'MB'; &#125;elseif($byte&lt;$tb)&#123; return round($byte/$gb,$precision).'GB'; &#125;else&#123; return round($byte/$tb,$precision).'TB'; &#125;&#125; 读取文件内容返回字符串 function read_file(string $filename)&#123; //检测是否是一个文件并且文件可读 if(is_file($filename) &amp;&amp; is_readable($filename))&#123; return file_get_contents($filename); &#125; return false;&#125; 读取文件内容返回数组 function read_file_array(string $filename,bool $skip_empty_lines=false)&#123; //检测是否是一个文件并且文件可读 if(is_file($filename)&amp;&amp;is_readable($filename))&#123; if($skip_empty_lines)&#123; //如果有空行就过滤掉 return file($filename,FILE_IGNORE_NEW_LINES|FILE_SKIP_EMPTY_LINES); &#125;else&#123; return file($filename); &#125; &#125; return false;&#125; 文件中写入内容 写入的内容是数组或者对象需要做序列化处理 function write_file(string $filename,$data)&#123; $dirname=dirname($filename); //检测目标路径是否存在 if(!file_exists($dirname))&#123; mkdir($dirname,0777,true); &#125; //判断内容是否是数组或者对象 if(is_array($data)||is_object($data))&#123; //序列化数据 $data=serialize($data); &#125; //向文件中写入内容 if(file_put_contents($filename,$data)!==false)&#123; return true; &#125;else&#123; return false; &#125;&#125; 非空文件中写入内容 function write_file1(string $filename,$data,bool $clearFlag=false)&#123; $dirname=dirname($filename); //检测目标路径是否存在 if(!file_exists($dirname))&#123; mkdir($dirname,0777,true); &#125; //检测文件是否存在并且可读 if(is_file($filename)&amp;&amp;is_readable($filename))&#123; //读取文件内容，之后和新写入的内容拼装到一起 if(filesize($filename)&gt;0)&#123; $srcData=file_get_contents($filename); &#125; &#125; //判断内容是否是数组或者对象 if(is_array($data)||is_object($data))&#123; //序列化数据 $data=serialize($data); &#125; //拼装到一起 $data=$srcData.$data; //向文件中写入内容 if(file_put_contents($filename,$data)!==false)&#123; return true; &#125;else&#123; return false; &#125;&#125; 截断文件到指定大小 function truncate_file(string $filename,int $length)&#123; //检测是否是文件且可写 if(is_file($filename)&amp;&amp;is_writable($filename))&#123; $handle=fopen($filename,'r+'); $length=$length&lt;0?0:$length; ftruncate($handle,$length); fclose($handle); return true; &#125; return false;&#125; 下载文件 在html里添加下载链接 建立down_file()函数 建立php文件进行下载 &lt;a href="download.php?filename=download.zip"&gt;file_name.zip&lt;/a&gt; //$allowDownExt 允许下载的文件类型function down_file(string $filename,array $allowDownExt=array('jpeg','jpg','png','gif','txt','html','php','rar','zip'))&#123; //检测下载文件是否存在，并且可读 if(!is_file($filename)||!is_readable($filename))&#123; return false; &#125; //检测文件类型是否允许下载 $ext=strtolower(pathinfo($filename,PATHINFO_EXTENSION)); if(!in_array($ext,$allowDownExt))&#123; return false; &#125; //通过header()发送头信息 //告诉浏览器输出的是字节流 header('Content-Type:application/octet-stream'); //告诉浏览器返回的文件大小是按照字节进行计算的 header('Accept-Ranges: bytes'); //告诉浏览器返回的文件大小 header('Accept-Length: '.filesize($filename)); //告诉浏览器文件作为附件处理，告诉浏览器最终下载完的文件名称 header('Content-Disposition: attachment;filename=king_'.basename($filename)); //读取文件中的内容 //readfile($filename); //exit; //规定每次读取文件的字节数为1024字节，直接输出数据 $read_buffer=1024; $sum_buffer=0; $handle=fopen($filename,'rb'); while(!feof($handle) &amp;&amp; $sum_buffer&lt;$filesize)&#123; echo fread($handle,$read_buffer); $sum_buffer+=$read_buffer; &#125; fclose($handle); exit;&#125; $filename=$_GET['filename'];down_file($filename); 单文件上传 function upload_file(array $fileInfo,string $uploadPath='./uploads',bool $imageFlag=true,array $allowExt=array('jpeg','jpg','png','gif'),int $maxSize=2097152)&#123; define('UPLOAD_ERRS',[ 'upload_max_filesize'=&gt;'超过了PHP配置文件中upload_max_filesize选项的值', 'form_max_size'=&gt;'超过了表单MAX_FILE_SIZE选项的值', 'upload_file_partial'=&gt;'文件部分被上传', 'no_upload_file_select'=&gt;'没有选择上传文件', 'upload_system_error'=&gt;'系统错误', 'no_allow_ext'=&gt;'非法文件类型', 'exceed_max_size'=&gt;'超出允许上传的最大值', 'not_true_image'=&gt;'文件不是真实图片', 'not_http_post'=&gt;'文件不是通过HTTP POST方式上传上来的', 'move_error'=&gt;'文件移动失败' ]); //检测是否上传是否有错误 if($fileInfo['error']===UPLOAD_ERR_OK)&#123; //检测上传文件类型 $ext=strtolower(pathinfo($fileInfo['name'],PATHINFO_EXTENSION)); if(!in_array($ext,$allowExt))&#123; echo UPLOAD_ERRS['no_allow_ext']; return false; &#125; //检测上传文件大小是否符合规范 if($fileInfo['size']&gt;$maxSize)&#123; echo UPLOAD_ERRS['exceed_max_size']; return false; &#125; //检测是否是真实图片 if($imageFlag)&#123; if(@!getimagesize($fileInfo['tmp_name']))&#123; echo UPLOAD_ERRS['not_true_image']; return false; &#125; &#125; //检测文件是否通过HTTP POST方式上传上来的 if(!is_uploaded_file($fileInfo['tmp_name']))&#123; return UPLOAD_ERRS['not_http_post']; &#125; //检测目标目录是否存在，不存在则创建 if(!is_dir($uploadPath))&#123; mkdir($uploadPath,0777,true); &#125; //生成唯一文件名，防止重名产生覆盖 $uniName=md5(uniqid(microtime(true),true)).'.'.$ext; $dest=$uploadPath.DIRECTORY_SEPARATOR.$uniName; //移动文件 if(@!move_uploaded_file($fileInfo['tmp_name'],$dest))&#123; echo UPLOAD_ERRS['move_error']; return false; &#125; echo '文件上传成功'; return $dest; &#125;else&#123; switch($fileInfo['error'])&#123; case 1: // $mes='超过了PHP配置文件中upload_max_filesize选项的值'; $mes=UPLOAD_ERRS['upload_max_filesize']; break; case 2: $mes=UPLOAD_ERRS['form_max_size']; break; case 3: $mes=UPLAOD_ERRS['upload_file_partial']; break; case 4: $mes=UPLOAD_ERRS['no_upload_file_select']; break; case 6: case 7: case 8: $mes=UPLAOD_ERRS['upload_system_error']; break; &#125; echo $mes; return false; &#125;&#125; 压缩单个文件 ZipArchive()一个用 Zip 压缩的文件存档类 压缩包要打开后将文件添加到压缩包中 function zip_file(string $filename)&#123; if(!is_file($filename))&#123; return false; &#125; $zip=new ZipArchive(); $zipName=basename($filename).'.zip'; //打开指定压缩包，不存在则创建，存在则覆盖 if($zip-&gt;open($zipName,ZipArchive::CREATE|ZipArchive::OVERWRITE))&#123; //将文件添加到压缩包中并删除文件 if($zip-&gt;addFile($filename))&#123; @unlink($filename); &#125; $zip-&gt;close(); return true; &#125;else&#123; return false; &#125;&#125; 多文件压缩 function zip_files(string $zipName,...$files)&#123; //检测压缩包名称是否正确 $zipExt=strtolower(pathinfo($zipName,PATHINFO_EXTENSION)); if('zip'!==$zipExt)&#123; return false; &#125; $zip=new ZipArchive(); if($zip-&gt;open($zipName,ZipArchive::CREATE|ZipArchive::OVERWRITE))&#123; foreach($files as $file)&#123; if(is_file($file))&#123; $zip-&gt;addFile($file); &#125; &#125; $zip-&gt;close(); return true; &#125;else&#123; return false; &#125;&#125; 解压缩 function unzip_file(string $zipName,string $dest)&#123; //检测要解压压缩包是否存在 if(!is_file($zipName))&#123; return false; &#125; //检测目标路径是否存在 if(!is_dir($dest))&#123; mkdir($dest,0777,true); &#125; $zip=new ZipArchive(); if($zip-&gt;open($zipName))&#123; $zip-&gt;extractTo($dest); $zip-&gt;close(); return true; &#125;else&#123; return false; &#125;&#125; 函数和类的封装源码: code/lib/file.func.php MySQL 具体参考PHP &amp; MySQL learning notes (1)-&gt;3.mySQL PHP操作MySQL MySQL：非永久链接，性能低，PHP5.5之后废弃 MySQLi：永久链接，减轻了服务器压力 PDO：实现MySQLi常用功能，支持大部分数据库 连接数据库：mysql -uroot -p password选择数据库：use db设置字符集：set names utf8 mysql_select_db("DATABASE NAME", $con)mysql_connect($server,$username,$password) //链接数据库mysql_select_db($database_name) //选择数据库名mysql_set_charset($charset) //设置字符集mysql_query($query) //执行INSERT，UPDATE，DELETE，DROP之类的操作，返回boolmysql_query($query) //执行SELECT操作，成功返回resource，失败返回FALSE 代码示例 header('content-type:text/html;charset=utf-8');//1、连接数据库$link = @mysql_connect('localhost','root','') or die('数据库连接失败！');//2、选择数据库mysql_select_db('test') or die('选择的数据库不存在！');//3、设置字符集mysql_set_charset('utf8');//添加数据$result = mysql_query("INSERT INTO users VALUES(NULL ,'李四',20)");//var_dump($result);//修改数据$result = mysql_query("UPDATE users SET money=25 where id=3");//var_dump($result);//删除单条数据$result = mysql_query("DELETE FROM users where id=3");//var_dump($result);//删除数据表$result = mysql_query("DROP TABLE test");//var_dump($result);//查询$result = mysql_query("SELECT * FROM users");//$line = mysql_fetch_row($result);//$line = mysql_fetch_assoc($result);while($line = mysql_fetch_array($result,MYSQL_ASSOC))&#123; $data[] = $line;&#125;var_dump($data);//array (size=3)// 'id' =&gt; string '1' (length=1)// 'name' =&gt; string '慕课' (length=6)// 'money' =&gt; string '100' (length=3)//关闭数据库连接mysql_close($link); MySQLi操作$connect = mysqli_connect('host','username','password'.'database'); //面向过程方式链接数据库$result = mysqli_query($connect,$sql); //执行SQL语句mysqli_fetch_all($result) //获取结果集 错误及常用命令 Parse error（解析错误）: syntax error(语法错误), unexpected ‘&lt;’, expecting end of file Notice(通知): Undefined variable（未定义的变量）: sdkljflskdjflksdjflksdjfklj Catchable fatal(致命) error: Object of class stdClass could not be converted to string Warning(警告): settype(): Invalid(非法) type header('content-type:text/html;charset=utf-8');date_defalut_timezone_set('PRC');@ //PHP提供的错误信息屏蔽的专用符号echo($var,....) //输出一个或者多个字符串var_dump($var) //打印变量的详细信息,可以一次打印一个或者多个变量的详细信息print_r($var) //打印数组的信息unset($var,...) //销毁变量，可以一次销毁一个或者多个，销毁之后变量的值为nulltime() //返回当前的 Unix 时间戳is_[int|float|double|bool...]($var) //判断变量的类型isset() //检测变量是否存在function_exists() //判断函数谁否存在file_exists() //判断文件是否存在$var = file_get_contents($filename) //得到文件中的内容，返回的是字符串serialize() //产生一个可存储的值的表示unserialize() //从已存储的表示中创建 PHP 的值setcookie(string $name, string $value, int $expire = 0, string $path = "", string $domain = "") //设置coockie：$name名称 $value值 $expire生命周期 $path可用路径 $domain可用域名范围$var = strip_tags() //从字符串中去除 HTML 和 PHP 标记exit()|die(); //输出一个消息并且退出当前脚本]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 layoutit 设计简易留言板功能]]></title>
    <url>%2F2018%2F11%2F18%2Flayoutit%2F</url>
    <content type="text"><![CDATA[-基础练习-Layoutit是基于bootstrap2.0的一个可视化布局模板, 可以点击模板里的文字进行修改, 也可以通过点击弹出的编辑框进行富文本修改. 拖动区块能实现排序。尝试用Layoutit进行快速可视化布局，练习PHP的_POST和_GET，后台数据用文件存储，未使用数据库 后台步骤 创建msg.md，将文件中的内容创建成 PHP 的值，读取到$msgs：$msgs=unserialize($string); header('content-type:text/html;charset=utf-8');date_default_timezone_set('PRC');$filename="msg.md";$msgs=[];//检测文件是否存在if(file_exists($filename))&#123; //读取文件中的内容 $string=file_get_contents($filename); if(strlen($string)&gt;0)&#123; $msgs=unserialize($string); &#125;&#125; 检测到用户提交留言 读取$username, $title, $content, $time 组成关联数组: $data=compact(&#39;username&#39;,&#39;title&#39;,&#39;content&#39;,&#39;time&#39;); 写入新的数据到$msgs: array_push($msgs,$data); 产生一个存储的值: $msgs=serialize($msgs); 报告留言成功或失败 if(isset($_POST['pubMsg']))&#123; $username=$_POST['username']; $title=strip_tags($_POST['title']); $content=strip_tags($_POST['content']); $time=time(); //将其组成关联数组 $data=compact('username','title','content','time'); array_push($msgs,$data); $msgs=serialize($msgs); if(file_put_contents($filename,$msgs))&#123; echo "&lt;script&gt;alert('留言成功！');location.href='22-msg.php';&lt;/script&gt;"; &#125;else&#123; echo "&lt;script&gt;alert('留言失败！');location.href='22-msg.php';&lt;/script&gt;"; &#125;&#125; 将$msgs中的内容显示在留言板上 检测到$msgs存在且数组有内容 将$msgs中的所有数组键名按顺序读取，分别在网页中输出：foreach($msgs as $val) &lt;?php if(is_array($msgs)&amp;&amp;count($msgs)&gt;0):?&gt;...&lt;?php $i=1;foreach($msgs as $val):?&gt; &lt;tr class="success"&gt; &lt;td&gt; &lt;?php echo $i++;?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo $val['username'];?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo $val['title'];?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo date("m/d/Y H:i:s",$val['time']);?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo $val['content'];?&gt; &lt;/td&gt; &lt;/tr&gt;&lt;?php endforeach;?&gt;&lt;?php endif;?&gt; 表格输出 编号 用户 标题 时间 内容 1 KevinW test 11/18/2018 15:59:25 测试留言 Layoutit页面设计 Kevin_W的留言板-V1.1.0 Hello, Layoutit! 这是一个可视化布局模板, 你可以点击模板里的文字进行修改, 也可以通过点击弹出的编辑框进行富文本修改. 拖动区块能实现排序. 参看更多 » 请留言 用户 标题 内容 L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":100,"height":200},"mobile":{"show":true},"log":false}); msg.phpmsg.md]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>bootstrap2.0</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP & MySQL learning notes (2)]]></title>
    <url>%2F2018%2F11%2F05%2Fphp-notes%2F</url>
    <content type="text"><![CDATA[-基础笔记-慕课网 PHP基础语法巩固(2) 课堂笔记，包含基本语法，变量和数据和函数等细碎的摘要 PHP使用环境和IDE LAMP(build): Linux+Apache+MySQL+PHP LNMP: Linux+Nginx+MySQL+PHP LNMPA: Linux+Nginx+MySQL+PHP+Apache WAMP(build): Window+Apache+MySQL+PHP 集成环境: xampp, wampserver, phpstudy IDE: vscode,Atom, Sublime Text3, PHPStorm, ZendStudio 基础语法 标准风格：&lt;?php 代码段; ?&gt;如果文档中只有PHP代码，结束标记要省略掉如果文档中不只有PHP代码，一定要保证PHP的开始和结束标记成对出现，可以出现任意位置，任意多次都可以 短风格：&lt;? 代码段; ?&gt;需要配置PHP配置文件php.ini中short_open_tag=On,重启Apache服务器即可 ASP风格：&lt;% 代码段; %&gt;需要配置PHP配置文件php.ini中asp_tags=On,重启Apache服务器即可 常量 &amp; 变量定义常量 define($name, $value) const NAME=值常量名称不加$常量名称最好大写，以字母或者下划线开始常量默认区分大小写常量作用域是全局常量一经定义，在脚本执行期间是不能改变的常量的值可以是标量类型，也可以是数组 - constant($name) //根据常量的名称获取常量的值- defined($name) //检测常量名称是否存在，如果存在返回true，否则返回false- get_defined_constants() //返回的是包含系统常量和自定义常量的数组 魔术常量 __LINE__ //得到当前的行号 __FILE__ //得到当前文件的完整绝对路径和文件名 __DIR__ //得到文件的完整绝对路径 __FUNCTION__ //得到当前函数的名称 __CLASS__ //得到当前类的类名 __METHOD__ //得到当前类的方法名称 __TRAIT__ //得到当前的TRAIT名称 __NAMESPACE__ //得到当前明明空间的名称 定义变量 通过美元$变量名称来表示变量 PHP是弱类型语言，可以声明变量在使用，也可以不声明，可以一次声明一个，也可以一次声明多个 变量命名法 驼峰标记法小骆驼: firstName,lastName,zendControllerFront大骆驼: irstName,LastName,ZendControllerFront 下划线法first_name,last_name,zend_controller_front 预定义变量 $GLOBALS //超全局变量，包含以下所有的预定义变量 $_SERVERS //服务器和执行环境信息变量 $_ENV //环境变量 $_COOKIE //HTTP Cookies $_SESSION //HTTP Session变量 $_FILES //文件上传信息变量 $_GET[&#39;名称&#39;] //主要接收以?形式传递的数据，像表单以get形式发送数据，包括像超链接典型的?形式传递参数 $_POST[&#39;名称&#39;] //主要接收表单以post形式发送的数据 $_REQUEST //$_GET+$_POST+$_COOKIE 数据类型 &amp; 转换临时转换整型: (int)$变量名称|(integer)$变量名称浮点型: (float|double|real)$变量名称字符型: (string)$变量名称布尔型: (bool|boolean)$变量名称空: (unset)$变量名称数组: (array)$变量名称对象: (object)$变量名称 通过系统函数实现intval($var) //返回变量转换成整型之后的值floatval($var)|doubleval($var) //返回变量转换成浮点型的值strval($var) //返回变量转换成字符串的值boolval($var) //返回变量转换成布尔类型的值 永久转换settype($var,$type) //设置变量的类型gettype($var) //返回变量的类型 函数函数变量局部变量 局部动态变量: 变量只在函数内部执行，执行完毕则被销毁 局部静态变量: 在函数内部设置static时，执行完毕变量不被销毁 全局变量: 使用global，在函数内部定义全局变量，当函数执行时先调用函数外面已经定义好的变量再执行，如函数内部有重复定义相同变量不同值，执行出的是函数内部修改过的值 参数传递 值传递: 在函数内部修改变量的值的情况下，在函数调用时调用函数外部的变量，值不变 引用传递: 在函数内部修改变量的值的情况下，在函数调用时，函数的参数前面加一个&amp;符号，值发生改变 在对象中，不加&amp;符号，对象的值也会发生改变 堆内存: 存放占用内存比较大的，如对象 new xxx() 栈内存: 存放基本类型 $obj 可变参数列表 func_num_args：实参个数； func_get_arg：返回某一个实参，必须事实参数组的索引； func_get_args：返回实参数组; 可以返回整型，字符串型，数组等数据类型 复杂函数类型可变函数：通过变量改变函数的名字并调用，让函数的调用更具有多样性 匿名函数：使用变量 = function(){}; ，调用时也是用变量加小括号来进行调用，变量后面要加上分号结尾声明一个函数不给函数起名字，用来以后做回调函数时用 嵌套函数访问外部局部变量：变量名1 = function() use ($变量名2){}; 系统库函数int strlen(string $str) //返回字符串长度string strtolower(string $str) //转换成小写string strtoupper(string $str) //转换成大写string ucfirst(string $str) //句首字母转换成大写string ucwords(string $str) //每个单词首字母转换成大写mixed str_replace(mixed $search, mixed replace, mixed $subject, [int &amp;$count]) //实现字符替换，区分大小写mixed str_ireplace(mixed $search, mixed replace, mixed $subject, [int &amp;$count]) //实现字符替换，不区分大小写float floor(float $svalue) //舍去float ceil(float $svalue) //进位int mt_rand(int $min, int $max) //随机数，比rand()更好 数组创建数组 通过array()形式 array()空数组array(值,…)下标连续的索引数组，下标从0开始array(键名=&gt;键值,…)指定下标的索引数组、关联数组、混合数组通过[]的形式定义数组，代替array() 通过[ ]动态创建 $数组名称[]=值 //下标连续的索引数组$数组名称[键名]=值 //指定下标的索引数组和关联数组 通过range()和compact()快速创建 range() //快速创建下标连续的索引数组compact() //快速创建关联数组,只能写已经存在的变量名称，不能加$ 通过define(), const定义常量数组 数组转换临时转换: (array)$var永久转换: settype($var,$type) 数组运算符+ 合并数组，如果键名相同，使用前面数组的键值== 只比较键名和键值是否相同，如果相同返回true，否则返回false=== 既要比较键名和键值是否相同，还要比较类型和顺序 数组遍历通过foreach遍历数组foreach($数组名称 as $val)&#123;循环体;&#125; //只要键值foreach($数组名称 as $key=&gt;$val)&#123;循环体;&#125; //既要键名又要键值foreach($数组名称 as $key=&gt;&amp;$val)&#123;循环体;&#125; //引用传递 深入理解PHP原理之foreach 可以通过:和endforeach代替{ } PHP7中foreach的改变 foreach遍历对数组内部指针不再起作用 按照值进行遍历的时候，foreach操作的值是数组的副本 按照引用进行遍历的时候，有更好的迭代特性，在遍历体内修改数组对遍历有影响 通过指针函数遍历key($array) //得到当前指针所在位置的键名current($array) //得到当前指针所在位置的键值next($array) //将数组指针向下移动一位，返回当前指针所在位置的键值，否则返回falseprev($array) //将数组指针向上移动一位，返回当前指针所在位置的键值，否则返回falseend($array) //将数组指针移动到末尾，返回当前指针所在位置的键值，否则返回falsereset($array) //将数组指针移动到开始，返回当前指针所在位置的键值，否则返回false 通过each()和list()函数遍历数组each()list() 数组库API创建数组操作range($min,$max[,$step=1]):快速创建下标连续的索引数组compact($varname,$varname...):快速创建关联数组array_fill($start_index,$num,$value):用给定的值填充数组array_fill_keys($keys,$value):使用指定的键和值填充数组array_combine($keys,$values):创建一个数组，用一个数组的值作为其键名，另外一个值作为其键值 键值相关操作count($var[,$mode=COUNT_NORMAL])/sizeof():计算数组中的单元数目或对象中的属性个数 array_keys($array):取得数组的键名作为下标连续的索引数组返回array_values($array):取得数组的键值作为下标连续的索引数组返回array_flip($array):交换数组中的键名和键值in_array($search,$array[,$strict]):检测数组中是否存在某个值array_search($search,$array[,$strict]):在数组中搜索给定的值，如果成功则返回相应的键名array_key_exists($search,$array):检查给定的键名或索引是否存在于数组中array_reverse($array[,$preserve_keys=false]):数组倒置shuffle($array):打乱数组的元素array_rand($array[,$num_req=1]):随机取出数组的键名array_unique($array[,$sort_flag=SORT_STRING]):移除数组中重复的值array_sum($array):统计数组中元素值的总和array_product($array):计算数组中所有值的乘积array_count_values($array):统计数组中值出现的次数extract($array[,$extract_type=EXTR_OVERWRITE[,$prefix=null]]):从数组中将变量导入到当前的符号表 array_pad($array,$size,$value):用值将数组填补到指定长度 数组指针函数key($array):得到当前指针所在位置元素的键名current($array)|pos($array):得到当前指针所在位置元素的键值next($array):将数组指针向下移动一位，并且返回当前指针所在位置元素的键值prev($array):将数组指针向上移动一位，并且返回当前指针所在位置元素的键值end($array):将数组指针移动倒数组的末尾，并且返回当前指针所在位置元素的键值reset($array):将数组指针移动到数组的开始，并且返回当前指针所在位置元素的键值each($array):返回数组中当前的键值对，并将数组指针向下移动一位list($var,...):将数组中元素的值赋给对应的变量array_unshift($array,$value...):在数组开头插入一个元素或者多个元素array_shift($array):弹出数组的第一个元素array_push($array,$value...):在数组末尾压入一个元素或者多个元素array_pop($array):弹出数组的最后一个元素 数组的排序函数sort($array[,$sort_flag=SORT_REGULAR]):对数组的键值按照升序排列，不保留键名rsort($array[,$sort_flag=SORT_REGULAR]):对数组键值按照降序排列，不保留键名asort($array[,$sort_flag=SORT_REGULAR]):对数组键值按照升序排列，保留键值对关系arsort($array[,$sort_flag=SORT_REGULAR]):对数组键值按照降序排列，保留键值对关系ksort($array[,$sort_flag=SORT_REGULAR]):对数组的键名按照升序排列krsort($array[,$sort_flag=SORT_REGULAR]):对数组的键名按照降序排列natsort($array):用自然排序法排序natcasesort($array):用自然排序算法对数组进行不区分大小写字母的排序 array_multisort($arr[,$arg=SORT_STRING...]):对多个数组或多维数组进行排序 数组的交集与差集array_diff($array1,$array2[...]):计算数组的差集array_diff_assoc($array1,$array2[,...]):带索引检查计算数组的差集 array_intersect($array1,$array2[...]):计算数组的交集array_intersect_assoc($array1,$array2[...]):带索引检查计算数组的交集 数组的拆分与合并array_slice($array,$offset[$length=null[,$preserve_keys=false]]):截取数组array_splice($array,$offset[,$length=0,$replacement]]):将数组中一部分去掉并用其它值替代array_merge($arr1[,$arr2...]):合并数组array_chunk($array,$size[,$preserve_keys=false]):将一个数组分割成多个array_column($array,$column_key[,$index_key]):返回数组中指定的一列 错误及常用命令 Parse error（解析错误）: syntax error(语法错误), unexpected ‘&lt;’, expecting end of file Notice(通知): Undefined variable（未定义的变量）: sdkljflskdjflksdjflksdjfklj Catchable fatal(致命) error: Object of class stdClass could not be converted to string Warning(警告): settype(): Invalid(非法) type header('content-type:text/html;charset=utf-8');date_defalut_timezone_set('PRC');echo($var,....) //输出一个或者多个字符串var_dump($var) //打印变量的详细信息,可以一次打印一个或者多个变量的详细信息print_r($var) //打印数组的信息unset($var,...) //销毁变量，可以一次销毁一个或者多个，销毁之后变量的值为nulltime() //返回当前的 Unix 时间戳is_[int|float|double|bool...]($var) //判断变量的类型isset() //检测变量是否存在function_exists() //判断函数谁否存在file_exists() //判断文件是否存在$var = file_get_contents($filename) //得到文件中的内容，返回的是字符串serialize() //产生一个可存储的值的表示unserialize() //从已存储的表示中创建 PHP 的值setcookie(string $name, string $value, int $expire = 0, string $path = "", string $domain = "") //设置coockie：$name名称 $value值 $expire生命周期 $path可用路径 $domain可用域名范围$var = strip_tags() //从字符串中去除 HTML 和 PHP 标记]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adobe 2019 crack]]></title>
    <url>%2F2018%2F11%2F01%2FAdobe2019%2F</url>
    <content type="text"><![CDATA[Adobe 2019 全家桶和破解包百度云链接，所有安装包和破解未验证具体完整性和安全性，可能出现不完全破解，请谨慎使用文章内容和链接非原创，在此感谢 vposy 胡萝卜周 和 painter 大神们，还有学校 摄影工作室 的小伙伴们。关于破解的最新内容会搬运过来同步更新，不一定及时，有需要可以去关注一下大神们微博：vposy，胡萝卜周，twitter：@painter701 2月更新 转自微博 2.18 SP版已更新，为 Illustrator CC 2019 添加了库功能。Photoshop CC 2019 直接支持视频模块，不再需要登录后激活 2.7 Adobe Lightroom Classic CC 8.2 2.6 Adobe Photoshop CC 2019 (20.0.3.24950) 2.4 CC 2018 WIN SP版/大师版，CC 2019 WIN/MAC SP版/大师版 1月更新 1.31 Camera Raw CC 11.2.0.36 ​​​​ 1.12 为 Animate、Dreamweaver、Illustrator、InCopy、InDesign、Lightroom Classic 添加了文件夹图标 1.10 Adobe Photoshop CC 2019 (20.0.2.22488) 12月更新 12.22 AE16.0.1.48修正HEVC,建议按住ctrl+alt+shift启动程序重置一次 PR修正主页 12.13 Adobe Acrobat Pro DC 2019 连续版 (2019.010.20064) SP 2018.12.13更新 11月更新 11.11 Lightroom Classic 8.0 要求重新登录，但不影响正常使用，功能完整。 11.8 Adobe Photoshop CC 2019.0.1 (20.0.1.17836) 11.2 更新 Adobe Bridge CC 2019.0.1 (9.0.1.216) 更新 Adobe InDesign CC 2019.0.1 (14.0.1.202) 更新 Adobe Media Encoder CC 2019.0.1 (13.0.1.12) 更新 Adobe Premiere Pro CC 2019.0.1 (13.0.1.13) 到10月28日，目前除Lightroom Classic CC没有照片编辑功能外，vposy破解的版本其它貌似都能勉勉强强使用，具体会出现的BUG和解决方案也会持续更新出来（如果有的话）下载链接vposy的原版和SP版（只有win10）百度云下载链接：https://pan.baidu.com/share/init?surl=F1iCpjajAz-Ez5QsJZP5zQhttps://pan.baidu.com/s/1F1iCpjajAz-Ez5QsJZP5zQ提取密码: ewyu vposy的 Adobe CC 2018 大师版百度云下载链接：https://pan.baidu.com/s/1dio1Z4提取密码：w7i4 ZerOCod3 文件替换破解 百度云下载链接：https://pan.baidu.com/s/11msujRxnXgl5wJpHNjd6YA提取码: xjew 破解文件为.exe文件，将Adobe根目录下的文件替换成破解文件就行 或者可以下载ZerOCod破解包合集。https://pan.baidu.com/s/1W3Jnd8w2wMLTVHlsrvYQhw 提取码: zi2u CC Maker 早期版本汇总 百度云下载链接：链接: https://pan.baidu.com/s/14ubOSVQkltVFarvbB7vUXQ提取码: cuvr CC Maker汇总了早期版本的Adobe软件下载，早期版本可用amtlib破解程序破解 关于Adobe CC 2019 系统需求WIN10最新版本。旧版WIN10，WIN8.1不支持，WIN7部分支持（不建议） CC2019开始ADOBE抛弃了十几年的amtlib，新激活模块内置于主程序，正版必须登录ID，所有之前的破解程序都没用,新版本的破解也只是是跳过ID登录，没有授权信息 WIN新版破解会很快，但MAC版短时间就难说了。全系列完美破解短时间就不要想了，只有本地功能，与ACC有关的在线功能如库能否正常使用取决于ADOBE。ACC需单独破解 官方今年还没有给出完整版地址，同时也封掉了CCP。新版版发布时间还不长，不清楚官方是否不打算给完整包了。 新版本BUG问题可以去Adobe官方社区论坛上讨论 painter的emu 他本人说遇到了一点困难，至少目前没有 至少他是想在尽量不动主程序的情况下模拟ID授权激活的，而不是简单的跳过ID登录，完全规避无授权BUG，具体情况可以自己去推上问他]]></content>
      <categories>
        <category>Adobe</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[breast-cancer-diagnose from Kaggle]]></title>
    <url>%2F2018%2F10%2F28%2Fcancer-diagnose%2F</url>
    <content type="text"><![CDATA[学校人工智能导论课程小组作业，乳腺癌检测（from Kaggle）。作业训练基础的数据清理，数据特征分类，验证不同的分类算法之间的分类效果 训练数据集：[Breast Cancer Wisconsin (Diagnostic) Data Set](https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+%28Diagnostic%29) UCI关于此数据集有两份，本实验使用较为完整的一份 实验数据为文本数据，数据量是为569的小型数据，有部分数据缺失 步骤中降维部分，violin图部分为半成品，效果并不显著，可以自动忽略 Attribute Information: 1) ID number 2) Diagnosis (M = malignant, B = benign) 3) Ten real-valued features are computed for each cell nucleus:a) radius (mean of distances from center to points on the perimeter)b) texture (standard deviation of gray-scale values)c) perimeterd) areae) smoothness (local variation in radius lengths)f) compactness (perimeter^2 / area - 1.0)g) concavity (severity of concave portions of the contour)h) concave points (number of concave portions of the contour)i) symmetryj) fractal dimension (“coastline approximation” - 1) 以下列举部分实验结果，具体实现步骤&gt;&gt; breast-cancer-diagnose.ipynb downloadLogisticRegression (逻辑斯蒂回归 分类器) from sklearn.linear_model import LogisticRegressionLR = LogisticRegression()LR.fit(X_train, y_train)LR.predict(X_test)LR.score(X_test,y_test) Out: 0.9883040935672515 结论： 通过比较，逻辑斯蒂模型比随机梯度下降模型在测试集上表现有更高的准确性，因为逻辑斯蒂采用解析的方式精确计算模型参数，而随机梯度下降采用估计值 特点分析： 逻辑斯蒂对参数的计算采用精确解析的方法，计算时间长但是模型性能高，随机梯度下降采用随机梯度上升算法估计模型参数，计算时间短但产出的模型性能略低，一般而言，对于训练数据规模在10万量级以上的数据，考虑到时间的耗用，推荐使用随机梯度算法 SGDClassifier (梯度下降 分类器)from sklearn.linear_model import SGDClassifier SGD = SGDClassifier(loss=&apos;hinge&apos;, penalty=&apos;l2&apos;, alpha=0.001, l1_ratio=0.15, fit_intercept=True, max_iter=None, tol=None, shuffle=True, verbose=0, epsilon=0.1, n_jobs=1, random_state=None, learning_rate=&apos;optimal&apos;, eta0=0.0, power_t=0.5, class_weight=None, warm_start=False, average=False, n_iter=None)SGD.fit(X_train,y_train)SGD.predict(X_test)SGD.score(X_test,y_test) Out: 0.9824561403508771 LinearRegression (线性回归 分类器)from sklearn.linear_model import LinearRegression LR2 = LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=1)LR2.fit(X_train,y_train)LR2.predict(X_test)LR2.score(X_test,y_test) Out: 0.8739645029687063 KNeighborsClassifier (k近邻 分类器)from sklearn.neighbors import KNeighborsClassifier KNN = KNeighborsClassifier(n_neighbors=5, weights=&apos;uniform&apos;, algorithm=&apos;auto&apos;, leaf_size=30, p=2, metric=&apos;minkowski&apos;, metric_params=None, n_jobs=1, **kwargs)KNN.fit(X_train,y_train)KNN.predict(X_test)KNN.score(X_test,y_test) Out: 0.9883040935672515 GaussianNB (朴素贝叶斯 分类器)from sklearn.naive_bayes import GaussianNB GNB = GaussianNB(priors=None)GNB.fit(X_train,y_train)GNB.predict(X_test)GNB.score(X_test,y_test) Out: 0.9766081871345029]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thinkpad fingerprint device on Linux]]></title>
    <url>%2F2018%2F10%2F28%2Ftp-print%2F</url>
    <content type="text"><![CDATA[Thinkpad 在Linux下新版本指纹识别驱动的安装与指纹实现管理员验证 1.Check your finger print devicelsusb example in device ID: 138:0090 and show device ID (for me) Bus xxx Device xxx: ID 138a:0090 Validity Sensors, Inc. here are some integrated fingerprint Reader in thinkwiki USB ID Reader Software 08ff:1600 Authentec AES1610 fprint 08ff:2580 Authentec AES2501 fprint 08ff:2810 Authentec 2810 supported by libfprint v0.5.0 onwards released December 2012 138a:0017 Validity Sensors, Inc. Fingerprint Reader (to test) Driver Patch as use case with T440 or gist sample Supported by libfprint v0.6.0 138a:0090 Validity Sensors RE work for validity90 fingerprint reader 2.Install packages 2.1 Packages for Fingerprint GUI for Ubuntu 14.04, 16.04, 17.10, 18.04 and any distribution based thereupon ! check if your device is in supported readers then install 2.2 Install fprintd (for me in device 138a:0090) read the guide: Validity and libfprint in github for ubuntu/linuxmint sudo apt install fpirntdsudo add-apt-repository -y ppa:3v1n0/libfprint-vfs0090sudo apt updatesudo apt install libpam-fprintd for archlinux sudo pacman -S fprintdyaourt -S libfprint-vfs0090-git 3.Enroll your finger print add your signature for a finger (touch your finger device) fprintd-enroll ! use sudo fprintd-enroll may have some bug if not work for finger in &#123;left,right&#125;-&#123;thumb,&#123;index,middle,ring,little-finger&#125;; do fprintd-enroll -f "$finger" "$USER"; done e.g for finger in {left,right}-{thumb,{index,middle,ring,little-finger}; do fprintd-enroll -f &quot;right-index-finger&quot; &quot;kevin&quot;; done ! here has a bug, you may need to add 10x4 times to add finger signature 4.Login configuration read the guide in archlinux wiki 4.1 For linuxmint Add pam_fprintd.so as sufficient to the top of the auth section of /etc/pam.d/runuser sudo nano /etc/pam.d/runuser---auth sufficient pam_fprintd.soauth sufficient pam_rootok.sosession optional pam_keyinit.so revoke... 4.2 For archlinux Add pam_fprintd.so as sufficient to the top of the auth section of /etc/pam.d/system-local-login 5.Reboot check the light of finger device in linuxmint, print finger then click sign in in archlinux, click enter then print finger]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux device</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP & MySQL learning notes (1)]]></title>
    <url>%2F2018%2F10%2F28%2Fw3school-php%2F</url>
    <content type="text"><![CDATA[W3school PHP 和 MySQL的初次学习 1.PHP基础PHP 脚本以 &lt;?php 开头，以 ?&gt; 结尾,语句以分号结尾: &lt;?php// 此处是 PHP 代码;?&gt; // 这是单行注释 # 这也是单行注释 / /这是多行注释块 变量 变量以 $ 符号开头，其后是变量的名称 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线 A-z、0-9 以及 _ 变量名称对大小写敏感（$y 与 $Y 是两个不同的变量） 松散型语言，不必告知 PHP 变量的数据类型 PHP global 关键词 global 关键词用于访问函数内的全局变量。 要做到这一点，请在（函数内部）变量前面使用 global 关键词 PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。 function myTest() &#123; global $x,$y; $y=$x+$y;&#125;function myTest() &#123; $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];&#125; PHP static 关键词 通常，当函数完成/执行后，会删除所有变量。不过，有时我需要不删除某个局部变量。实现这一点需要更进一步的工作。要完成这一点，请在您首次声明变量时使用 static 关键词 echo 和 print 之间的差异： echo - 能够输出一个以上的字符串 print - 只能输出一个字符串，并始终返回 1 PHP var_dump() 会返回变量的数据类型和值 PHP 对象 对象是存储数据和有关如何处理数据的信息的数据类型。 首先我们必须声明对象的类。对此，我们使用 class 关键词;然后我们在对象类中定义数据类型;然后在该类的实例中使用此数据类型 class Car&#123; var $color; function Car($color="green") &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125;&#125; strlen() 函数返回字符串的长度，以字符计 strpos() 函数用于检索字符串内指定的字符或文本 如需设置常量，请使用 define() 函数 - 它使用三个参数： 首个参数定义常量的名称 第二个参数定义常量的值 可选的第三个参数规定常量名是否对大小写不敏感。默认是 false。 PHP 字符串运算符 运算符 名称 例子 结果 . 串接 $txt1 = “Hello” $txt2 = $txt1 . “ world!” 现在 $txt2 包含 “Hello world!” .= 串接赋值 $txt1 = “Hello” $txt1 .= “ world!” 现在 $txt1 包含 “Hello world!” PHP 递增/递减运算符 运算符 名称 描述 ++$x 前递增 $x 加一递增，然后返回 $x $x++ 后递增 返回 $x，然后 $x 加一递增 –$x 前递减 \$x 减一递减，然后返回 \$x $x– 后递减 返回 \$x，然后 \$x 减一递减 在 PHP 中， array() 函数用于创建数组 在 PHP 中，有三种数组类型： 索引数组 - 带有数字索引的数组$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;SAAB&quot;); 关联数组 - 带有指定键的数组$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); 多维数组 - 包含一个或多个数组的数组 count() 函数用于返回数组的长度（元素数） 如需遍历并输出索引数组的所有值，您可以先count数组长度，再使用 for 循环 如需遍历并输出关联数组的所有值，您可以使用 foreach 循环 PHP foreach 循环 foreach 循环只适用于数组，并用于遍历数组中的每个键/值对。 foreach ($array as $value) &#123;code to be executed;&#125; PHP - 数组的排序函数 sort() - 以升序对数组排序 rsort() - 以降序对数组排序 asort() - 根据值，以升序对关联数组进行排序 ksort() - 根据键，以升序对关联数组进行排序 arsort() - 根据值，以降序对关联数组进行排序 krsort() - 根据键，以降序对关联数组进行排序 超全局变量： $GLOBALS 引用全局作用域中可用的全部变量$_SERVER 保存关于报头、路径和脚本位置的信息$_REQUEST 用于收集 HTML 表单提交的数据$_POST 广泛用于收集提交 method=&quot;post&quot; 的 HTML 表单后的表单数据。$_POST 也常用于传递变量$_GET 用于收集提交 HTML 表单 (method=&quot;get&quot;) 之后的表单数据,也可以收集 URL 中的发送的数据$_ENV$_COOKIE$_SESSION &lt;html&gt;&lt;body&gt;&lt;form method="post" action="&lt;?php echo $_SERVER['PHP_SELF'];?&gt;"&gt;Name: &lt;input type="text" name="fname"&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;?php$name = $_REQUEST['fname'];echo $name;?&gt;&lt;/body&gt;&lt;/html&gt; 2.PHP表单HTML表单处理表单界面 &lt;html&gt;&lt;body&gt;&lt;!--form创建表单--&gt;&lt;form action="welcome.php" method="post"&gt;Name: &lt;input type="text" name="name"&gt;&lt;br&gt; &lt;!--文本--&gt;E-mail: &lt;input type="text" name="email"&gt;&lt;br&gt;Gender: &lt;!--选择--&gt;&lt;input type="radio" name="gender" value="female"&gt;Female&lt;input type="radio" name="gender" value="male"&gt;Male&lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; welcome.PHP &lt;html&gt;&lt;body&gt;Welcome &lt;?php echo $_POST["name"]; ?&gt;&lt;br&gt;Your email address is: &lt;?php echo $_POST["email"]; ?&gt;&lt;/body&gt;&lt;/html&gt; 可以将post换成get 后端GET &amp; POST $_GET 是通过 URL 参数传递到当前脚本的变量数组。 通过 GET 方法从表单发送的信息对任何人都是可见的（所有变量名和值都显示在 URL 中）。GET 对所发送信息的数量也有限制。限制在大于 2000 个字符。不过，由于变量显示在 URL 中，把页面添加到书签中也更为方便。 GET 可用于发送非敏感的数据。 $_POST 是通过 HTTP POST 传递到当前脚本的变量数组。 通过 POST 方法从表单发送的信息对其他人是不可见的（所有名称/值会被嵌入 HTTP 请求的主体中），并且对所发送信息的数量也无限制。 一般偏向于POST发送表单数据 表单安全验证&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;&gt; $_SERVER[&quot;PHP_SELF&quot;] 是一种超全局变量，它返回当前执行脚本的文件名 htmlspecialchars() 函数把特殊字符转换为 HTML 实体 $_SERVER[&quot;PHP_SELF&quot;] 变量能够被黑客利用,使用了 PHP_SELF，用户能够输入下划线然后执行跨站点脚本（XSS）,通过使用 htmlspecialchars() 函数能够避免 $_SERVER[&quot;PHP_SELF&quot;] 被利用 利用php函数检查表单 （通过 PHP trim() 函数）去除用户输入数据中不必要的字符（多余的空格、制表符、换行） （通过 PHP stripslashes() 函数）删除用户输入数据中的反斜杠（\） // 定义变量并设置为空值$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; $name = test_input($_POST["name"]); $email = test_input($_POST["email"]); $website = test_input($_POST["website"]); $comment = test_input($_POST["comment"]); $gender = test_input($_POST["gender"]);&#125;function test_input($data) &#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125; 必须输入字段增加了一些新变量：$nameErr、$emailErr、$genderErr 以及 $websiteErr。这些错误变量会保存被请求字段的错误消息。 还需要每个 $_POST 变量添加了一个 if else 语句。这条语句检查 $_POST 变量是否为空（通过 PHP empty() 函数）。如果为空，则错误消息会存储于不同的错误变量中。如果不为空，则通过 test_input() 函数发送用户输入数据 $nameErr = $emailErr = $genderErr = $websiteErr = "";$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; if (empty($_POST["name"])) &#123; $nameErr = "Name is required"; &#125; else &#123; $name = test_input($_POST["name"]); &#125; if (empty($_POST["email"])) &#123; $emailErr = "Email is required"; &#125; else &#123; $email = test_input($_POST["email"]); &#125; if (empty($_POST["website"])) &#123; $website = ""; &#125; else &#123; $website = test_input($_POST["website"]); &#125; if (empty($_POST["comment"])) &#123; $comment = ""; &#125; else &#123; $comment = test_input($_POST["comment"]); &#125; if (empty($_POST["gender"])) &#123; $genderErr = "Gender is required"; &#125; else &#123; $gender = test_input($_POST["gender"]); &#125;&#125; HTML显示错误消息在每个被请求字段后面增加了一点脚本。如果需要，会生成恰当的错误消息 Name: &lt;input type="text" name="name"&gt;&lt;span class="error"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt; //验证E-mail:&lt;input type="text" name="email"&gt;&lt;span class="error"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt;Website:&lt;input type="text" name="website"&gt;&lt;span class="error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;label&gt;Comment: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;/textarea&gt;Gender:&lt;input type="radio" name="gender" value="female"&gt;Female&lt;input type="radio" name="gender" value="male"&gt;Male&lt;span class="error"&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt;&lt;input type="submit" name="submit" value="Submit"&gt; 验证输入数据验证名字：preg_match() 函数检索字符串的模式，如果模式存在则返回 true，否则返回 false $name = test_input($_POST["name"]);if (!preg_match("/^[a-zA-Z ]*$/",$name)) &#123; $nameErr = "只允许字母和空格！";&#125; 验证email $email = test_input($_POST["email"]);if (!preg_match("/([\w\-]+\@[\w\-]+\.[\w\-]+)/",$email)) &#123; $emailErr = "无效的 email 格式！";&#125; 验证URL $website = test_input($_POST["website"]);if (!preg_match("/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i",$website)) &#123; $websiteErr = "无效的 URL";&#125; HTML保留表单中的值在输入字段的 value 属性中增加了一小段 PHP 脚本：name、email 以及 website 在 comment 文本框字段中，把脚本放到了 &lt;textarea&gt; 与 &lt;/textarea&gt; 之间;这些脚本输出 $name、$email、$website 和 $comment 变量的值。 要显示选中了哪个单选按钮，操作 checked 属性（而非单选按钮的 value 属性） Name: &lt;input type="text" name="name" value="&lt;?php echo $name;?&gt;"&gt;E-mail: &lt;input type="text" name="email" value="&lt;?php echo $email;?&gt;"&gt;Website: &lt;input type="text" name="website" value="&lt;?php echo $website;?&gt;"&gt;Comment: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;?php echo $comment;?&gt;&lt;/textarea&gt;Gender:&lt;input type="radio" name="gender"&lt;?php if (isset($gender) &amp;&amp; $gender=="female") echo "checked";?&gt;value="female"&gt;Female&lt;input type="radio" name="gender"&lt;?php if (isset($gender) &amp;&amp; $gender=="male") echo "checked";?&gt;value="male"&gt;Male 完整代码&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.error &#123;color: #FF0000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;?php// 定义变量并设置为空值$nameErr = $emailErr = $genderErr = $websiteErr = "";$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; if (empty($_POST["name"])) &#123; $nameErr = "姓名是必填的"; &#125; else &#123; $name = test_input($_POST["name"]); // 检查姓名是否包含字母和空白字符 if (!preg_match("/^[a-zA-Z ]*$/",$name)) &#123; $nameErr = "只允许字母和空格"; &#125; &#125; if (empty($_POST["email"])) &#123; $emailErr = "电邮是必填的"; &#125; else &#123; $email = test_input($_POST["email"]); // 检查电子邮件地址语法是否有效 if (!preg_match("/([\w\-]+\@[\w\-]+\.[\w\-]+)/",$email)) &#123; $emailErr = "无效的 email 格式"; &#125; &#125; if (empty($_POST["website"])) &#123; $website = ""; &#125; else &#123; $website = test_input($_POST["website"]); // 检查 URL 地址语法是否有效（正则表达式也允许 URL 中的斜杠） if (!preg_match("/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i",$website)) &#123; $websiteErr = "无效的 URL"; &#125; &#125; if (empty($_POST["comment"])) &#123; $comment = ""; &#125; else &#123; $comment = test_input($_POST["comment"]); &#125; if (empty($_POST["gender"])) &#123; $genderErr = "性别是必选的"; &#125; else &#123; $gender = test_input($_POST["gender"]); &#125;&#125;function test_input($data) &#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125;?&gt;&lt;h2&gt;PHP 验证实例&lt;/h2&gt;&lt;p&gt;&lt;span class="error"&gt;* 必需的字段&lt;/span&gt;&lt;/p&gt;&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt; 姓名：&lt;input type="text" name="name"&gt; &lt;span class="error"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 电邮：&lt;input type="text" name="email"&gt; &lt;span class="error"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 网址：&lt;input type="text" name="website"&gt; &lt;span class="error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 评论：&lt;textarea name="comment" rows="5" cols="40"&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; 性别： &lt;input type="radio" name="gender" value="female"&gt;女性 &lt;input type="radio" name="gender" value="male"&gt;男性 &lt;span class="error"&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;input type="submit" name="submit" value="提交"&gt;&lt;/form&gt;&lt;?phpecho "&lt;h2&gt;您的输入：&lt;/h2&gt;";echo $name;echo "&lt;br&gt;";echo $email;echo "&lt;br&gt;";echo $website;echo "&lt;br&gt;";echo $comment;echo "&lt;br&gt;";echo $gender;?&gt;&lt;/body&gt;&lt;/html&gt; 3.mySQLPHP连接MySQL通过 mysql_connect() 函数完成 mysql_connect(&#39;servername&#39;,&#39;username&#39;,&#39;password&#39;); 参数 描述 servername 可选。规定要连接的服务器。默认是 “localhost:3306” username 可选。规定登录所使用的用户名。默认值是拥有服务器进程的用户的名称 password 可选。规定登录所用的密码。默认是 “” $con = mysql_connect("localhost","root","");if (!$con) &#123; die('Could not connect: ' . mysql_error()); //连接失败执行die &#125;// some code 创建数据库用 mysql_query() 函数 mysql_query(&quot;CREATE DATABASE database_name&quot;,password) $con = mysql_connect('localhost','root','');if (!$con)&#123; die('Could not connect: ' . mysql_error()); &#125;if (mysql_query("CREATE DATABASE my_db",$con))&#123; //创建数据库 echo "Database created"; &#125;else&#123; echo "Error creating database: " . mysql_error(); &#125;mysql_close($con); 创建表创建表之前，必须首先选择数据库;通过 mysql_select_db() 函数选取数据库mysql_query() 函数添加 CREATE TABLE 语句 // Create table in databasemysql_select_db("DATABASE NAME", $con);$sql = "CREATE TABLE Persons(FirstName varchar(15),LastName varchar(15),Age int)";mysql_query($sql,$con); 表的主键和递增字段：主键字段通常是 ID 号，且通常使用 AUTO_INCREMENT 设置 AUTO_INCREMENT 会在新记录被添加时逐一增加该字段的值。要确保主键字段不为空，我们必须向该字段添加 NOT NULL 设置 personID int NOT NULL AUTO_INCREMENT 插入数据INSERT INTO table_name VALUES (value1, value2,....) SQL 语句对大小写不敏感。INSERT INTO 与 insert into 相同。 为了让 PHP 执行该语句，我们必须使用 mysql_query() 函数。该函数用于向 MySQL 连接发送查询或命令 mysql_select_db("DATABASE NAME", $con);mysql_query("INSERT INTO Persons (FirstName, LastName, Age)VALUES ('Peter', 'Griffin', '35')");mysql_close($con); 表单数据插入数据库 当用户点击上例中 HTML 表单中的提交按钮时，表单数据被发送到 “insert.php”。”insert.php” 文件连接数据库，并通过 $_POST 变量从表单取回值。然后，mysql_query() 函数执行 INSERT INTO 语句，一条新的记录会添加到数据库表中 mysql_select_db("DATABASE NAME", $con);$sql="INSERT INTO Persons (FirstName, LastName, Age)VALUES('$_POST[firstname]','$_POST[lastname]','$_POST[age]')"; //HTML表单中的数据if (!mysql_query($sql,$con))&#123;die('Error: ' . mysql_error());&#125;echo "1 record added";mysql_close($con) 选取数据SELECT column_name(s) FROM table_name 使用 mysql_fetch_array() 函数以数组的形式从记录集返回第一行 使用了 PHP 的 $row 变量 ($row[‘FirstName’] 和 $row[‘LastName’])输出每行的值 mysql_select_db("my_db", $con);$result = mysql_query("SELECT * FROM Persons");while($row = mysql_fetch_array($result)) &#123; echo $row['FirstName'] . " " . $row['LastName']; echo "&lt;br /&gt;"; &#125;mysql_close($con); 显示成表格样式 mysql_select_db("my_db", $con);$result = mysql_query("SELECT * FROM Persons");echo "&lt;table border='1'&gt; &lt;tr&gt; &lt;th&gt;Firstname&lt;/th&gt; &lt;th&gt;Lastname&lt;/th&gt; &lt;/tr&gt;"; while($row = mysql_fetch_array($result)) &#123; echo "&lt;tr&gt;"; echo "&lt;td&gt;" . $row['FirstName'] . "&lt;/td&gt;"; echo "&lt;td&gt;" . $row['LastName'] . "&lt;/td&gt;"; echo "&lt;/tr&gt;"; &#125;echo "&lt;/table&gt;";mysql_close($con); 如需选取匹配指定条件的数据，请向 SELECT 语句添加 WHERE 子句 SELECT column FROM table WHERE column operator value mysql_select_db("my_db", $con);$result = mysql_query("SELECT * FROM PersonsWHERE FirstName='Peter'"); ORDER BY 关键词用于对记录集中的数据进行排序 SELECT column_name(s) FROM table_name ORDER BY column_name ORDER BY 关键词，记录集的排序顺序默认是升序;可用DESC 关键词来设定降序排序 SELECT column_name(s) FROM table_name ORDER BY column_name DESC mysql_select_db("my_db", $con);$result = mysql_query("SELECT * FROM Persons ORDER BY age"); 修改数据UPDATE 语句用于在数据库表中修改数据 UPDATE table_name SET column_name = new_value WHERE column_name = some_value mysql_select_db("my_db", $con);mysql_query("UPDATE Persons SET Age = '36'WHERE FirstName = 'Peter' AND LastName = 'Griffin'");mysql_close($con); 删除数据DELETE FROM 语句用于从数据库表中删除记录 DELETE FROM table_name WHERE column_name = some_value mysql_select_db("my_db", $con);mysql_query("DELETE FROM Persons WHERE LastName='Griffin'");mysql_close($con);]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的欢迎界面]]></title>
    <url>%2F2018%2F10%2F28%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[description: 这是第一次是使用Hexo时Hexo展示的页面，为方便查询移动至此Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tips about building blog]]></title>
    <url>%2F2018%2F10%2F20%2Ftips-about-building-blog%2F</url>
    <content type="text"><![CDATA[安装hexo的笔记,不间断进行更新更新目录： 安装和部署必要模组 页面模板 写文章 本地查看和Github部署 分类和标签须知 标签插件 建立资源文件夹 更换Maupassant主题 增加右下角动图 添加pdf插件 安装字数统计插件 install nodejs npm git hexo 安装和部署必要模组install on Linuxsudo apt-get install -y nodejssudo apt-get install -y build-essentialsudo apt-get install -y npmsudo apt-get install git related modules npm install //install necessary componentsnpm install hexo-deployer-git --save // deploy to gitnpm install hexo-generator-feed --save // build RSSnpm install hexo-generator-sitemap --save // build sitemap deploy hexo open terminal &amp; cd to the right direction mkdir blognpm install hexo -ghexo -v //check infohexo init //initialize folderhexo g //Start processing add ssh keyssh-keygen -t rsa -C "your email address"cat /home/xxx/.ssh/id_rsa.pub //check your key load key to Github (default on Github &amp; default you can use Github) ssh -T git@github.com set id &amp; emailgit config --global user.name "your id"git config --global user.email "your email" install on Windows download nodejs and install download git and install Win+R open cmd to the right direction mkdir blognpm install hexo -ghexo -v //check infonpm install //install necessary componentshexo init //initialize folderhexo g //Start processing add related module &amp; ssh key &amp; set id+email (the same as linux) template 模板 各页面相对应的模板名称 模板 用途 回退index首页post文章indexpage分页indexarchive归档indexcategory分类归档archivetag标签归档archive write pages 写文章init pagehexo new post "post_name" edit title:date:categories:tags:description:###### tags 目前的标签 | Kaggle | Linux device | hexo | php | mysql | others | categories 目前的分类 Adobe: about any update &amp; crack of CC software notes: personal thoughts &amp; ideas others: just others study: study notes local server &amp; deploy 本地查看和部署hexo clean //clean cachehexo generate //generate static fileshexo seserver //localhost:4000hexo deploy //open server update notes 2019.2.14 更新 categories &amp; tags 分类和标签须知 只有文章支持分类和标签 分类具有顺序性和层次性,标签没有顺序和层次 Hexo不支持指定多个同级分类 categories:- Diarytags:- PS3- Games Tag Plugins 标签插件quote 在文章中插入引言，可包含作者、来源和标题 &#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; example &#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125; Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake code 插入代码&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; image 插入图片&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; link 插入链接&#123;% link text url [external] [title] %&#125; Assert fold 资源文件夹 如果需要插入图片,最简单的方法就是将它们放在 source/pic 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们. 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。需要使用标签插件 &#123;% asset_img example.jpg This is an example image %&#125;&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;... 2.18日更新 因NexT不可描述的页面无法跳转原因，更换主题到Maupassant，大道至简 给文章添加目录：开头加上 toc: true 首页自定义显示文章摘录：在摘录后加上&lt;!--more--&gt; 2.22日更新 增加萌宠或二次元动图hexo live2d插件 2.0Github地址 npm install --save hexo-helper-live2d然后挑一个npm install live2d-widget-model-xxxxx 向Hexo的 _config.yml 文件添加配置 live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-xxxxx display: position: right width: 150 height: 300 mobile: show: true 添加pdf插件npm install --save hexo-pdfhexo new page book .md文件中添加pdf 外部链接：&#123;% pdf http://xxx.pdf %&#125;本地连接：&#123;% pdf ./pdf名字.pdf %&#125; 安装字数统计插件npm i --save hexo-wordcount将自己所用主题中的 _config.yml 文件中的 wordcount 设置为true Reference hexo.io cnblogs: hexo+Github搭建自己的博客]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to Kevin_W's attic,filled with whispers & murmurs]]></title>
    <url>%2F2018%2F10%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Kevin_W 创立于这个世界在10月10日，2018。 他可以是一本日志,也可以是一篇日记，一个仓库，或者一个告解室，一个树洞，亦或什么都不是。 但这里，的确是独立于外部的一个世界。 Kevin 不清楚这个世界能存在多久，会放置些什么，有多少谁在看，更新频率是多快，更新的知识有多深奥，只能保证这个世界创造的一切，都是十分重要的信息。 Kevin 也不清楚能把这个世界创造得多好，不清楚这个世界会往哪里发展，不清楚到底有多少个类似这样的平行世界，只能保证创造这个世界的Kevin 是最Kevin’s 的一个Kevin. Wubba lubba dub dubHey，what are you in for ?]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
</search>
