<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[scikit-learn 文档学习笔记]]></title>
    <url>%2F2019%2F07%2F30%2Fscikit-learn-note%2F</url>
    <content type="text"><![CDATA[scikit-learn 基于 Python 语言,建立在 NumPy ，SciPy 和 matplotlib 上,是简单高效的数据挖掘和数据分析工具文章记录 scikit-learn API的使用方法，包括监督学习、无监督学习，模型的选择和评估，数据集的加载和转换 API只给出函数结构，参数具体使用参考scikit-learn官方文档 监督学习线性回归模型目标值 y 是输入变量 x 的线性组合 $y(w,x) = w_0 +w_1x_1 + … + w_px_p$ 其中w为系数(coef) $w_0$ 为截距(intercept)。 1.普通最小二乘法 LinearRegression 拟合一个带有系数 $w = (w_1, …, w_p)$ 的线性模型，使得数据集实际观测数据和预测数据（估计值）之间的残差平方和最小。$\underset{w}{min\,} {|| X w - y||_2}^2$ sklearn.linear_model.LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=None) from sklearn.linear_model import LinearRegressionreg = LinearRegression().fit(X,y) # 模型拟合reg.cof_ # 得到系数矩阵reg.intercept_ # 得到截距矩阵reg.score(X,y) # 误差reg.predict(X) # 预测 2.岭回归 Ridge 回归通过对系数的大小施加惩罚来解决普通最小二乘法的一些问题。 岭系数最小化的是带罚项的残差平方和。$\underset{w}{min\,} {||X w - y||_2^2 + \alpha ||w||_2^2}$，其中$\alpha \geq 0$ 是控制系数收缩量的复杂性参数(超参数) sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True, normalize=False, copy_X=True, max_iter=None, tol=0.001, solver=’auto’, random_state=None) from sklearn import linear_modelreg = linear_model.Ridge().fit(X,y) sklearn.linear_model.RidgeCV( ) 内置对$\alpha$的交叉验证实现岭回归 3.套索回归 Lasso 用于拟合稀疏系数的线性模型，使用了 coordinate descent （坐标下降算法）来拟合系数，罚项 为L1 范数。$\underset{w}{min\,} { \frac{1}{2n_{samples}} ||X w - y||_2 ^ 2 + \alpha ||w||_1}$ sklearn.linear_model.Lasso(alpha=1.0, fit_intercept=True, normalize=False, precompute=False, copy_X=True, max_iter=1000, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’) sklearn.linear_model.LassoCV() // 对超参数$\alpha$采用交叉验证 sklearn.linear_model.LassoLars() // 采用的是最小角回归法，而不是坐标下降法进行优化 sklearn.linear_model.LassoLarsCV() //同时采用不同的验证和优化方法 sklearn.linear_model.LassoLarsIC() //对超参数$\alpha$采用 Akaike 信息准则(AIC)和贝叶斯信息准则(BIC),需要假设模型是正确的，对大样本（渐近结果）进行导出 LassoLarsCV 在寻找 $\alpha$ 参数值上更具有优势，而且如果样本数量比特征数量少得多时，通常 LassoLarsCV 比 LassoCV 要快 Multitask 4.弹性网络 ElasticNet 最近邻朴素贝叶斯决策树支持向量机集成方法半监督学习神经网络模型无监督学习高斯混合聚类流形学习无监督神经网络模型模型选择和评估交叉检验量化评估指标模型持久化绘制学习曲线数据集加载数据集转换数据预处理缺失值补全无监督降维API汇总]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask Web 学习笔记2 -- URL与视图函数映射]]></title>
    <url>%2F2019%2F04%2F11%2Fflask-learning2%2F</url>
    <content type="text"><![CDATA[-学习笔记-通过URL传递参数，接收参数，利用试图函数实现参数到URL转换，自定义URL转换 URL是Uniform Resource Locator的简写，统一资源定位符。一个URL由以下几部分组成： scheme://host:port/path/?query-string=xxx#anchor scheme：代表的是访问的协议，一般为http或者https以及ftp等。 host：主机名，域名，比如www.baidu.com。 port：端口号。当你访问一个网站的时候，浏览器默认使用80端口。 path：查找路径。比如：www.jianshu.com/trending/now，后面的trending/now就是path。 query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。 anchor：锚点，后台一般不用管，前端用来做页面定位的。 传递参数传递参数的语法是：/&lt;参数名&gt;/。然后在视图函数中，也要定义同名的参数。 @app.route('/')@app.route('/list/')@app.route('/p/&lt;float:article_id&gt;')@app.route('/u/&lt;uuid:user_id&gt;/')@app.route('/&lt;any(blog,article):url_path&gt;/&lt;id&gt;/') 参数的数据类型 如果没有指定具体的数据类型，那么默认就是使用string数据类型。 int数据类型只能传递int类型。 float数据类型只能传递float类型。 path数据类型和string有点类似，都是可以接收任意的字符串，但是path可以接收路径，也就是说可以包含斜杠。 uuid数据类型只能接收符合uuid的字符串。uuid是一个全宇宙都唯一的字符串，一般可以用来作为表的主键。 any数据类型可以在一个url中指定多个路径。 @app.route('/&lt;any(blog,article):url_path&gt;/&lt;id&gt;/')def detail(url_path,id): if url_path == 'blog': return '博客详情：%s' % id else: return '博客详情：%s' % id 接收用户传递的参数 第一种：使用path的形式（将参数嵌入到路径中），就是上面讲的。 第二种：使用查询字符串的方式，就是通过?key=value的形式传递的。 @app.route('/d/')def d(): wd = request.args.get('wd') return '参数是：%s' % wd URL转换器url_for将视图函数名字后面的参数传递给url。如果传递的参数之前在url中已经定义了，那么这个参数就会被当成path的形式给url。如果这个参数之前没有在url中定义，那么将变成查询字符串的形式放到url中。 from flask import Flask,url_for,request...@app.route('/list/&lt;page&gt;/')def my_list(page): return 'my list'print(url_for('my_list',page=1,count=2))# page作为path，count作为查询字符串# 构建出来的url：/my_list/1/?count=2 url_for优势 将来如果修改了URL，但没有修改该URL对应的函数名，就不用到处去替换URL了 @app.route('/post/list/&lt;page&gt;/')def my_list(page): return 'my list'url = url_for('my_list'，page=1,count=2)# 原来的url：/my_list/1/?count=2# 新构建出来的url：/post/my_list/1/?count=2 url_for会自动的处理那些特殊的字符，不需要手动去处理。 @app.route('/login/')def login(): return 'login'url = url_for('login',next='/')# 会自动的将`/`编码，不需要手动去处理。# url=/login/?next=%2F 自定义URL转换器URL参数的数据类型通过routing.py中的Unicode/Float/Any/Path/Number Converter等类指定，使用了默认转换器 可以自定义类型URL转换器和运算符URL转换器 自定义方法 实现一个类，继承自BaseConverter。 在自定义的类中，重写regex，也就是这个变量的正则表达式。 将自定义的类，映射到app.url_map.converters上。 from flask import Flask,url_forfrom werkzeug.routing import BaseConverter# 自定义手机号码的变量URL转换class TelephoneConveter(BaseConverter): regex = r'1[85734]\d'app.url_map.converters['tel'] = TelephoneConverter# 使用自定义的数据类型@app.route('/telephone/&lt;tel:my_tel&gt;/')def my_tel(my_tel): return '您的手机号码是：%s' % my_tel############################ 自定义+号运算符解析class OpratorConverter(BaseConverter):def to_python(self, value): # 这个方法的返回值，将会传递到view函数中作为参数 return value.split('+')def to_url(self, value): # 在调用url_for函数的时候生成符合要求的URL形式 return "+".join(value) # return "hello"app.url_map.converters['oprator+'] = OpratorConverter# 使用自定义+@app.route('/posts/&lt;oprator+:boards&gt;/')def posts(boards): print(boards) return "您提交的板块是：%s" % boards URL重定向重定向在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面。比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面。 永久性重定向：http的状态码是301，多用于旧网址被废弃了要转到一个新的网址确保用户的访问。 暂时性重定向：http的状态码是302，表示页面的暂时性跳转。比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面，这种情况下，应该用暂时性重定向。 flask中有一个函数叫做redirect，可以重定向到指定的页面。 from flask import Flask,request,redirect,url_forapp = Flask(__name__)@app.route('/login/')def login(): return '这是登录页面'@app.route('/profile/')def profile(): if request.args.get('name'): return '个人中心页面' else: # redirect 重定向 return redirect(url_for('login')) 视图函数的响应 可以返回字符串：flask会创建werkzeug、wrappers、Response对象，状态码200，MIME类型test/html，然后返回Response对象 from flask import Response...@app.route('/list/')def list(): Response('Hello World!')# Response('Hello World!',status=200,mimetype='text/html') 还可以通过make_response进行创建 form flask import make_response@app.route('/list/')def list(): return make_response('list page.') 可以返回元组：元组的形式是(Response,Status,header)不一定三个都要写，写两个也是可以的，status返回200，header为列表或字典。返回的元组，其实在底层也是包装成了一个Response对象。return &#39;list&#39;,200,{&#39;NAME&#39;:&#39;kevin&#39;} @app.errorheader(404)def not_found(): return 'not found',404 直接返回合法的响应对象 resp = Response('list')resp.set_cookie('country','china')return resp 以上条件不满足，则进行自定义响应 继承自Response类。实现方法force_type(cls,response,environ=None)。指定app.response_class为你自定义的Response对象。如果视图函数返回的数据，不是字符串，也不是元组，也不是Response对象，那么就会将返回值传给force_type，然后再将force_type的返回值返回给前端。 class myResponse(Response): def force_type(cls, response, environ=None): return Response('return error.')app.response_class = myResponse # 使用jsonify将返回的格式转换成json格式from flask import jsonify...class myResponse(Response): def force_type(cls, response, environ=None): if isinstance(response,dict): # jsonify除了将字典转换成json对象，还将改对象包装成了一个Response对象 response = jsonify(response) # 调用父类 return super(myResponse, cls).force_type(response, environ)app.response_class = myResponse]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中的智能指针]]></title>
    <url>%2F2019%2F04%2F05%2Fptr%2F</url>
    <content type="text"><![CDATA[由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，用智能指针便可以有效缓解这类问题。 对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。 访问智能指针包含的裸指针则可以用 get() 函数 智能指针包含了 reset() 方法，如果不传递参数（或者传递 NULL），则智能指针会释放当前管理的内存。如果传递一个对象，则智能指针会释放当前对象，来管理新传入的对象。 编写测试类来辅助分析 class Simple &#123; public: Simple(int param = 0) &#123; number = param; std::cout &lt;&lt; "Simple: " &lt;&lt; number &lt;&lt; std::endl; &#125; ~Simple() &#123; std::cout &lt;&lt; "~Simple: " &lt;&lt; number &lt;&lt; std::endl; &#125; void PrintSomething() &#123; std::cout &lt;&lt; "PrintSomething: " &lt;&lt; info_extend.c_str() &lt;&lt; std::endl; &#125; std::string info_extend; int number;&#125;; std::auto_ptr包含头文件 #include&lt;memory&gt; 便可以使用std::auto_ptr 能够方便的管理单个堆内存对象 用法一：std::auto_ptr&lt;MyClass&gt;m_example(new MyClass()); 用法二：std::auto_ptr&lt;MyClass&gt;m_example;m_example.reset(new MyClass()); 用法三（指针的赋值操作）：std::auto_ptr&lt;MyClass&gt;m_example1(new MyClass());std::auto_ptr&lt;MyClass&gt;m_example2(new MyClass());m_example2=m_example1; 使用示例void TestAutoPtr() &#123; std::auto_ptr&lt;Simple&gt; my_memory(new Simple(1)); // 创建对象 if (my_memory.get()) &#123; // 判断智能指针是否为空 my_memory-&gt;PrintSomething(); // 使用 operator-&gt; 调用智能指针对象中的函数 my_memory.get()-&gt;info_extend = "Addition"; // 使用 get() 返回裸指针，然后给内部对象赋值 my_memory-&gt;PrintSomething(); // 再次打印，表明上述赋值成功 (*my_memory).info_extend += " other"; // 使用 operator 返回智能指针内部对象，然后用“.”调用智能指针对象中的函数 my_memory-&gt;PrintSomething(); // 再次打印，表明上述赋值成功 &#125;&#125; // my_memory 栈对象即将结束生命期，析构堆对象 Simple(1) 执行结果为：Simple: 1PrintSomething:PrintSomething: AdditionPrintSomething: Addition other~Simple: 1 不能使用 = 操作符void TestAutoPtr2() &#123; std::auto_ptr&lt;Simple&gt; my_memory(new Simple(1)); if (my_memory.get()) &#123; std::auto_ptr&lt;Simple&gt; my_memory2; // 创建一个新的 my_memory2 对象 my_memory2 = my_memory; // 复制旧的 my_memory 给 my_memory2 my_memory2-&gt;PrintSomething(); // 输出信息，复制成功 my_memory-&gt;PrintSomething(); // 崩溃 &#125;&#125; my_memory2 = my_memory这行代码，my_memory2 完全夺取了 my_memory 的内存管理所有权，导致 my_memory 悬空，最后使用时导致崩溃。 release() 函数问题void TestAutoPtr3() &#123; std::auto_ptr&lt;Simple&gt; my_memory(new Simple(1)); if (my_memory.get()) &#123; my_memory.release(); &#125;&#125; //最终执行结果为 Simple：1，没有被析构，导致内存泄露 调用 release() 函数释放内存，不会释放对象，仅仅归还所有权，要自己delete或使用reset()函数销毁对象 //代码修正void TestAutoPtr3() &#123; std::auto_ptr&lt;Simple&gt; my_memory(new Simple(1)); if (my_memory.get()) &#123; Simple* temp_memory = my_memory.release(); delete temp_memory; // 或者直接 my_memory.reset(); 释放 my_memory 内部管理的内存 &#125;&#125; 注意事项使用 std::auto_ptr 时，绝对不能使用“operator=”操作符，这会夺取内存管理所有权std::auto_ptr 的 release() 函数不会释放对象，仅仅归还所有权。std::auto_ptr 最好不要当成参数传递（读者可以自行写代码确定为什么不能）。std::auto_ptr 的“operator=”问题，有其管理的对象不能放入 std::vector 等容器中。C++11中，std::auto_ptr已经被弃用 自C++11起，C++标准提供两大类型的智能指针：shared_ptr和unique_ptr std::shared_ptrshared_ptr实现共享式拥有（shared ownership）概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用（reference）被销毁”时候释放。为了在结构复杂的情境中执行上述工作，标准库提供了weak_ptr、bad_weak_ptr和enable_shared_from_this等辅助类。 shared_ptr本身提供默认内存释放器（default deleter），调用的是delete，也可以自定义释放器 默认内存释放器并不能释放数组内存空间，要我们自己提供内存释放器 成员函数use_count 返回引用计数的个数unique 返回是否是独占所有权( use_count 为 1)swap 交换两个 shared_ptr 对象(即交换所拥有的对象)reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少get 返回内部对象(指针) 示例 std::shared_ptr&lt;int&gt; sp0(new int(2));std::shared_ptr&lt;int&gt; sp1(new int(11));std::shared_ptr&lt;int&gt; sp2 = sp1;printf("%d\n", *sp0); // 2printf("%d\n", *sp1); // 11printf("%d\n", *sp2); // 11sp1.swap(sp0);printf("%d\n", *sp0); // 11printf("%d\n", *sp1); // 2printf("%d\n", *sp2); // 11std::shared_ptr&lt;int&gt; sp3(new int(22));std::shared_ptr&lt;int&gt; sp4 = sp3; // 或 auto sp4 = sp3printf("%d\n", *sp3); // 22printf("%d\n", *sp4); // 22sp3.reset();printf("%d\n", sp3.use_count()); // 0printf("%d\n", sp4.use_count()); // 1printf("%d\n", sp3); // 0 注意事项shared_ptr 会因循环引用造成无法释放资源与 weak_ptr 一起工作时, weak_ptr 在使用前需要检查合法性shared_ptr 不支持数组, 如果使用数组, 需要自定义删除器 std::weak_ptrweak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。 weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象. 注意, weak_ptr 在使用前需要检查合法性。 weak_ptr 支持拷贝或赋值, 但不会影响对应的 shared_ptr 内部对象的计数。 成员函数expired 用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 falselock 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同。use_count 返回与 shared_ptr 共享的对象的引用计数.reset 将 weak_ptr 置空. 使用weak_ptr解决shared_ptr因循环不能释放资源的问题使用 shared_ptr 时, shared_ptr 为强引用, 如果存在循环引用, 将导致内存泄露. 而 weak_ptr 为弱引用, 可以避免此问题 class CA&#123;public: CA()&#123;&#125; ~CA()&#123;PRINT_FUN();&#125;private: std::weak_ptr&lt;CB&gt; m_spb;&#125;;class CB&#123;public: CB()&#123;&#125;; ~CB()&#123;PRINT_FUN();&#125;;private: std::shared_ptr&lt;CA&gt; m_spa;&#125;;std::shared_ptr&lt;CA&gt; spa(new CA); // 通过调用weak_ptr，释放CA内存时不影响CBstd::shared_ptr&lt;CB&gt; spb(new CB); std::unique_ptrunique_ptr实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（resourece leak）——例如“以new创建对象后因为发生异常而忘记调用delete”——特别有用。 unique_ptr 不支持拷贝和赋值，但是可以调用 release 或 reset 将指针的所有权从一个(非 const) unique_ptr 转移到另一个std::unique_ptr&lt;A&gt; up1(new A(5));std::unique_ptr&lt;A&gt; up2(up1); // 错误, unique_ptr 不支持拷贝std::unique_ptr&lt;A&gt; up2 = up1; // 错误, unique_ptr 不支持赋值std::unique_ptr&lt;int&gt; up2(up1.release()); // 正确 unique_ptr 不支持拷贝, 但是可以从函数中返回, 甚至返回局部对象 std::unique_ptr&lt;Ty&gt; Clone(const Ty&amp; obj)&#123; std::unique_ptr&lt;Ty&gt; temp = std::unique_ptr&lt;Ty&gt;(new Ty(obj)); return temp; // 或直接 return std::unique_ptr&lt;Ty&gt;(new Ty(obj))&#125; unique_ptr 支持管理数组 成员函数get 获得内部对象的指针release 放弃内部对象的所有权，将内部指针置为空, 返回所内部对象的指针, 此指针需要手动释放reset 销毁内部对象并接受新的对象的所有权(如果使用缺省参数的话，也就是没有任何对象的所有权, 此时仅将内部对象释放, 并置为空)swap 交换两个 shared_ptr 对象(即交换所拥有的对象)std::move(name) 所有权转移(通过移动语义), 所有权转移后，变成“空指针” 防内存泄漏代码改进 int main()&#123; int *ptr = new int(0); return 0;&#125; // 内存泄露 int main()&#123; int *ptr = new int(0); delete ptr; // 释放内存 return 0;&#125; // ptr成空悬指针 int main()&#123; int *ptr = new int(0); delete ptr; // 释放内存 ptr = nullptr; return 0;&#125; //使用 unique_ptrint main()&#123; unique_ptr&lt;int&gt; ptr(new int(0)); return 0;&#125; boost::scoped_ptrboost::shared_ptrboost::scoped_arrayboost::shared_arrayboost::weak_ptrboost:: intrusive_ptr参考资料：https://blog.csdn.net/xt_xiaotian/article/details/5714477https://www.cnblogs.com/xiehongfeng100/p/4645555.htmlhttps://www.cnblogs.com/diysoul/p/5930361.htmlhttps://www.cnblogs.com/diysoul/p/5930372.htmlhttps://www.cnblogs.com/diysoul/p/5930388.html]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask Web 学习笔记1 -- 环境]]></title>
    <url>%2F2019%2F03%2F31%2Fflask-learning1%2F</url>
    <content type="text"><![CDATA[-学习笔记-flask前期准备，在目录下建立flask虚拟环境，开启调试模式和书写配置文档 flask = werkzeug(web服务)+sqlalchemy(数据库)+jinja2(框架模板) flask运行环境pip install pipenv使用 pipenv 隔离虚拟环境，防止不同项目环境冲突 命令行切换到目标目录下pipenv shell 进入虚拟环境pipenv install flask 安装flaskpipenv graph 打印所有依赖exit 退出虚拟环境 pipenv doc python 必须重启服务器才生效 默认模板 # 从flask这个包中导入Flask这个类# Flask这个类是项目的核心，以后很多操作都是基于这个类的对象# 注册url、注册蓝图等都是基于这个类的对象__author__ = 'kevin'from flask import Flask# 创建一个Flask对象，传递__name__参数进去# __name__参数的作用：# 1. 可以规定模版和静态文件的查找路径# 2. 以后一些Flask插件，比如Flask-migrate、Flask-SQLAlchemy如果报错了，那么Flask可以通过这个参数找到具体的错误位置app = Flask(__name__)# @app.route：是一个装饰器# @app.route('/')就是将url中的/映射到hello_world这个视图函数上面# 以后你访问我这个网站的/目录的时候，会执行hello_world这个函数，然后将这个函数的返回值返回给浏览器。@app.route('/')def hello_world(): return 'Hello,World.'# 如果这个文件是作为一个主文件运行，那么就执行app.run()方法，遍历运行# 只在开发时使用if __name__ == '__main__': app.run(host='127.0.0.1',port=5000) debug模式开启了DEBUG模式，那么在代码中如果抛出了异常，在浏览器的页面中可以看到具体的错误信息，以及具体的错误代码位置。方便开发者调试。 如果开启了DEBUG模式，那么以后在Python代码中修改了任何代码，只要按ctrl+s，flask就会自动的重新记载整个网站。不需要手动点击重新运行。 在app.run()中传递一个参数debug=True就可以开启DEBUG模式 if __name__ == '__main__': app.run(debug=True) 给app.deubg=True也可以开启debug模式。 app = Flask(__name__)app.debug = True 通过配置参数的形式设置DEBUG模式：app.config.update(DEBUG=True)。 # 设置配置参数的形式# DEBUG必须要大写，不能小写app = Flask(__name__)app.config.update(DEBUG=True) 通过配置文件的形式设置DEBUG模式：app.config.from_object(config) 导入import config使用app.config.from_object(config)新建config.py文件，写入DEBUG=true config文件 导入import config，使用app.config.from_object(config),新建config.py文件，写入DEBUG=true app.config.from_pyfile(&#39;config.py,silence=True),新建config.py文件，写入DEBUG=true可以传递silent=True，那么这个静态文件没有找到的时候，不会抛出异常]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 面向对象的一些特性]]></title>
    <url>%2F2019%2F03%2F25%2Fcpp-oop%2F</url>
    <content type="text"><![CDATA[-基础笔记-(loading…)C++面向对象编程知识点复习梳理，包括类、继承、重载、多态、数据抽象、数据封装、接口 类和对象类访问修饰符public公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值 private私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员默认情况下，类的所有成员都是私有的一般会在私有区域定义数据，在公有区域定义相关的函数 protected保护成员在派生类（即子类）中是可访问的 构造函数,拷贝构造函数和析构函数创建、初始化和删除所创建的对象时调用构造函数的名称与类的名称是完全相同的，不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值拷贝构造函数是一种特殊的构造函数，在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数析构函数的名称与类的名称是完全相同的，不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源 class Classname&#123;public: Classname(); //构造函数 Classname(const Classname &amp;obj); //拷贝构造函数 ~Classname(); //析构函数private: int *ptr;&#125;Classname::Classname()&#123; cout&lt;&lt;"调用构造函数"&lt;&lt;endl; *ptr = new int; //指针分配内存&#125;Classname::Classname(const Classname &amp;obj)&#123; cout&lt;&lt;"调用拷贝构造函数"&lt;&lt;endl; *ptr = *obj.ptr; //指针分配内存&#125;CLassname::~Classname()&#123; cout&lt;&lt;"释放内存"&lt;&lt;endl; delete ptr;&#125; 一个类如果有多个字段 X、Y、Z 等需要进行初始化，可以使用如下语法 Classname::objname( double a, double b, double c): X(a), Y(b), Z(c)&#123; ....&#125; 浅拷贝和深拷贝浅拷贝：如果没有拷贝构造函数，编译器自动产生一个“默认拷贝构造函数”，使用“老对象”的数据成员的值对“新对象”的数据成员进行赋值当对象存在动态成员，那么浅拷贝就会出问题，在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，出现错误 深拷贝：对象中动态成员重新动态分配空间 class Classname&#123;public: Classname()&#123; p = new int(100); &#125; Classname(const Classname&amp; r)&#123; p = new int(100); //重新分配动态空间 *p = *(r.p); //指针分配内存 &#125; ~Classname()&#123; delete p; &#125;&#125;; 友元函数定义在类外部，用来访问类的 private 和 protected 成员可以不使用范围解析运算符 :: 定义该函数 friend class Classname; //友元类friend void objname(); //友元函数 内联函数通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码，即把该函数的代码副本放置在每个调用该函数的地方类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符 this指针每一个对象都能通过 this 指针来访问自己的地址友元函数没有 this 指针，因为友元不是类的成员 类指针一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 -&gt;，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。 class Box&#123; public: func()&#123;&#125; ... private: ...&#125;;Box *ptrBox;ptrBox-&gt;func(); 静态成员变量和函数都可以被声明为静态的 声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员在类的所有对象中是共享的不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数） class Box&#123; public: static int objectCount; static int getCount() &#123; return objectCount; &#125; private: ...&#125;;// 初始化类 Box 的静态成员int Box::objectCount = 0;output = Box::getCount() 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前 auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符 register(C++ 11弃用) 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置） static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值 extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。 mutable 说明符仅适用于类的对象，它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问，变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。 thread_local 说明符可以与 static 或 extern 合并。 继承依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。 当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。 class derived-class: (public/protected/private) base-class // 基类class Shape&#123; public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;;// 派生类class Rectangle: public Shape&#123; public: int getArea() &#123; return (width * height); &#125;&#125;; 多继承多继承即一个子类可以有多个父类，它继承了多个父类的特性，C++ 类可以从多个类继承成员 class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…&#123;&lt;派生类类体&gt;&#125;; // 基类 Shapeclass Shape&#123; public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;;// 基类 PaintCostclass PaintCost&#123; public: int getCost(int area) &#123; return area * 70; &#125;&#125;;// 派生类class Rectangle: public Shape, public PaintCost&#123; public: int getArea() &#123; return (width * height); &#125;&#125;; 虚继承：解决多继承中出现的问题从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。 虚继承在创建对象的时候会创建一个虚表，从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。 这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。 class 派生类: virtual 方式1 基类1，virtual 方式2 基类2，...&#123;...//派生类成员声明&#125;; class D&#123;......&#125;;class A: virtual public D&#123;......&#125;;class B: virtual public D&#123;......&#125;;class C: public B, public A&#123;.....&#125;; 派生类无法从基类继承基类的构造函数、析构函数和拷贝构造函数基类的重载运算符基类的友元函数 重载C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。 编译器通过把使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。 运算符重载重定义或重载大部分 C++ 内置的运算符，使用自定义类型的运算符。 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 Box operator+(const Box&amp; b); // 重载+运算符 函数重载同一个类中，声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。 public:void print(int i) &#123; cout &lt;&lt; "整数为: " &lt;&lt; i &lt;&lt; endl;&#125;void print(double f) &#123; cout &lt;&lt; "浮点数为: " &lt;&lt; f &lt;&lt; endl;&#125;void print(char c[]) &#123; cout &lt;&lt; "字符串为: " &lt;&lt; c &lt;&lt; endl;&#125; 多态4.2“覆盖”是指派生类函数覆盖基类函数，特征是：（1）不同的范围（分别位于派生类与基类）；（2）函数名字相同；（3）参数相同；（4）基类函数必须有virtual 关键字。 4.3“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，特征是： （1）如果派生类的函数与基类的函数同名，但是参数不同，此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。（2）如果派生类的函数与基类的函数同名，但是参数相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。 数据抽象数据封装接口 参考资料：http://c.biancheng.net/cplus/w3school]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的相关操作]]></title>
    <url>%2F2019%2F03%2F24%2Fbintree%2F</url>
    <content type="text"><![CDATA[二叉树的笔记 loading… 存储结构基本操作创建插入查找四种遍历方法二叉树静态实现二叉查找树平衡二叉树一般意义上的树深度优先搜索广度优先搜索]]></content>
      <categories>
        <category>github-repo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于二叉树的衍生算法]]></title>
    <url>%2F2019%2F03%2F24%2Fbintree2%2F</url>
    <content type="text"><![CDATA[二叉树衍生算法 loading… 并查集堆哈夫曼树]]></content>
      <categories>
        <category>github-repo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找策略]]></title>
    <url>%2F2019%2F03%2F21%2Ftwo-divide%2F</url>
    <content type="text"><![CDATA[需要一个严格单调的序列，就能将O(n)的复杂度降到O(logn)的优秀算法非常适合有序数列的查找二分的思想也可以用来逼近准确值和降幂求值 二分查找思路设left，right，mid，查找数x查找的数 &gt; mid，left = mid + 1查找的数 &lt; mid，right = mid - 1直到查找的数 = mid，程序结束 #include&lt;cstdio&gt;int binSearch(int array[], int left, int right, int x)&#123; int mid; while(left&lt;=right) &#123; mid = (left + right) / 2; if(array[mid] == x) return mid; else if(array[mid] &gt; x) right = mid - 1; else left = mid + 1; &#125; return false; //查找失败则返回false&#125;int main()&#123; const int n = 10; //序列元素个数 int array[n] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int result = binSearch(array,0,n-1,6); printf("%d",result); return 0;&#125; mid = (left + right) / 2 可能会导致int类型溢出，可以改成 mid = left + (right - left) / 2 当序列中有相同的元素求解序列中第一个等于x的元素和最后一个等于x的元素 int lower_bound(int array[], int left, int right, int x)&#123; int mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(array[mid] &gt;= x) right = mid; else left = mid + 1; &#125; return left; // left==right 循环停止&#125; int upper_bound(int array[], int left, int right, int x)&#123; int mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(array[mid] &gt; x) right = mid; else left = mid + 1; &#125; return left; // left==right 循环停止&#125; 逼近无理数近似值计算f(x)中x的值 const double eps = 1e-5;double func(double x)&#123; return ...; // f(x)的公式&#125;double solve(double L, double R)&#123; double left = L, right = R, mid; while(right - left &gt; eps) &#123; mid = (left + right) / 2; if(func(mid)&gt;0) right = mid; else left = mid &#125; return mid;&#125; 快速求幂二分幂的思想可以用来降低时间复杂度若b为奇数，a^b = a a^b-1若b为偶数，a^b = a^b/2 a^b/2直到a^0 =1，依次退回计算 快速幂递归写法求解 a^b%m的递归写法 typedef long long LL;LL binFunc(LL a, LL b, LL m)&#123; if(b == 0) return 1; // a^0 == 1 if(b % 2 ==1) return a* binFunc(a, b-1, m) % m; else &#123; LL mul = binFunc(a, b/2, m); return mul * mul % m; &#125;&#125; b % 2 ==1可以写成b&amp;1,将b和1进行按位与操作，判断b末尾是否为1 快速幂非递归写法将b写成若干2次幂之和，将a^b表示成若干项乘积 typedef long long LL;LL binFunc(LL a, LL b, LL m)&#123; LL ans = 1; while(b&gt;0) &#123; if(b&amp;1) ans = ans * a % m; //判断2进制末尾是否为1，是的话*a a = a * a % m; b &gt;&gt;= 1; &#125; return ans;&#125;]]></content>
      <categories>
        <category>github-repo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治和递归基础算法]]></title>
    <url>%2F2019%2F03%2F21%2Fdivide%2F</url>
    <content type="text"><![CDATA[写分治和贪心时，习惯性地会去思索程序的全局，而一旦展开去想，基本上就大脑溢出了目前还是无法把握递归式和递归边界，这算法终将是一生之敌。 Fibonacci用Fibonacci数列简单熟悉一下算法 #include&lt;cstdio&gt;int Fibonacci(int n)&#123; if(n==0 | n==1) return 1; //递归边界 else return Fibonacci(n-1) + Fibonacci(n-2); //递归式&#125;int main()&#123; int n; scanf("%d",&amp;n); printf("%d",Fibonacci(n)); return 0;&#125; 全排列按照字典顺序从小到大顺序输出1-n全排列 思路：数组P存放当前排列，hashTable 置为 true 存放已在P中的数字递归式：P按位处理，数字x不在P中，将x填入P，P处理下一位递归边界：处理完n位，输出排列，hashTable[x]=false 还原 #include&lt;cstdio&gt;const int maxn = 1024;int P[maxn],hashTable[maxn] = &#123;false&#125;,n;//处理第index位void generateP(int index)&#123; if(index == n+1) //到达递归边界 &#123; for(int i=0; i&lt;n; i++) printf("%d ",P[i]); &#125; printf("\n"); return; else &#123; for(int x=1; x&lt;=n; x++) &#123; if(hashTable[x] == false) //递归式逻辑 &#123; P[index] = x; hashTable[x] = true; generateP(index+1); hashTable[x] = false; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); //输入有几个数 generateP(1)； //从1开始递归 return 0;&#125; n皇后问题皇后两两不在同行同列同对角线 思路：到达递归边界时，遍历任意两个皇后查看是否满足条件递归边界：列index到达n，满足八皇后条件，count+1递归式：行x不在hashTable中，此列放置皇后，index移动到下一列 int count = 0;void generateP(int index)&#123; bool flag = true; if(index == n+1) //到达递归边界，判断是否合法 &#123; for(int i=1; i&lt;=n; i++) for(int j=i+1; j&lt;=n; j++) if(abs(P[i]-P[j]) == abs(i-j)) flag = false; if(flag) count++; return; &#125; else &#123; for(int x=1; x&lt;=n; x++) &#123; if(hashTable[x] == false) //递归式 &#123; P[index] = x; hashTable[x] = true; generateP(index+1); hashTable[x] = false; &#125; &#125; &#125;&#125; 枚举所有情况会比较耗时间，可以在放置皇后的同时遍历之前的，判断是否有冲突 int count = 0;void generateP(int index)&#123; if(inedx == n+1) //到达递归边界 count++; return; else &#123; for(int x=1; x&lt;=n; x++) &#123; if(hashTable[x] == false) &#123; bool flag = true; for(int pre=1; pre&lt;index; pre++) &#123; if(abs(P[index]-P[pre]) == abs(index-pre)) &#123; flag == false; break; &#125; &#125; if(flag) &#123; P[index] = x; hashTable[x] = true; generateP(index+1); hashTable[x] = false; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>github-repo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp_stl]]></title>
    <url>%2F2019%2F03%2F20%2Fcpp-stl%2F</url>
    <content type="text"><![CDATA[C++ STL接触(loading…)在学习C++，数据结构基础上，STL是基础和进阶的分水岭，要多尝试用STL实现常用的算法和数据结构 Template（模板）模板（Template）指C++程序设计设计语言中采用类型作为参数的程序设计，支持通用程序设计。C++ 的标准库提供许多有用的函数大多结合了模板的观念，如STL以及IO Stream。 函数模板可以实现不同类型的函数代码的复用 // 模板定义template&lt;typename t&gt; swap(t &amp;t1, t &amp;t2)&#123; t tmpT; tmpT = t1; t1 = t2; t2 = tmpT;&#125;//模板实例化int main()&#123; int num1 = 1, num2 = 2; float num3 = 1.0, num4 = 2.0; swap&lt;int&gt;(num1, num2); swap&lt;float&gt;(num3, num4); return 0;&#125; 类模板可以实现不同类型的类的复用 // 模板定义template&lt;class t&gt; class Stack&#123; public: Stack()&#123; maxSize = 100; size = 0; p = new t[maxSize]; &#125;; ~Stack()&#123; delete p[]; p = nullptr; &#125;; void push(t num)&#123; size++; p[size-1] = num; &#125;; t pop()&#123; t num = p[size-1]; size--; return num; &#125;; bool isEmpty()&#123; return size == 0; &#125;; private: t *p; int maxSize; int size;&#125;// 模板实例化int main()&#123; Stack&lt;int&gt; intStack; Stack&lt;float&gt; floatStack; ... intStack.push(1); intStack.push(2); intStack.push(3); ... while(!intStack.isEmpty())&#123; printf("%d",intStack.pop()); &#125; return 0;&#125; 模板参数模板可以有常规的类型参数，也可以有默认模板参数template&lt;class t, int maxSize = 100&gt; class stack{} 一个类没有模板参数，但是成员函数有模板参数，是可行的 有些特殊的参数可以使用模板专门化template&lt;&gt; void swap(std::vector&lt;int&gt;&amp; t1, std::vector&lt;int&gt;&amp; t2){} string类使用指针 ++ 和 — 操作符来遍历字符串，无论 ASCII 码字符串还是 Unicode 字符串，使用指针均能够正确无误地返回要寻求的字符位置。使用数组处理字符串中的字符也非常方便。 STL 中只有一个字符串类，即 basic_string。类 basic_string 实现管理以 \0 结尾的字符数组，字符类型由模板参数决定。basic_string 有两个预定义类型：包含 char 的 string 类型和包含 wchar 的 wstring 类型。 string 作为类出现，其集成的操作函数足以完成多数情况下的需要。可以使用 “=” 进行赋值，使用 “==” 进行等值比较，使用 “+” 做串联。 string 类包含了 6 个构造函数。string 类支持 cin 方式和 getline() 方式两种输入方式。 basic_stringbasic_string是一个类模板，包括string，wstring，u16stirng和u32stringtypedef basic_string &lt;char&gt; string;typedef basic_string &lt;wchar&gt; wstring; //wstring 类是为了便于使用宽字符集，例如 Unicode 或某些欧洲字符集 string函数string 类提供的各种操作函数大致分为八类：构造器和析构器、大小和容量、元素存取、字 符串比较、字符串修改、字符串接合、I/O 操作以及搜索和查找。 函数名称 功能 构造函数 产生或复制字符串 析构函数 销毁字符串 =，assign 赋以新值 Swap 交换两个字符串的内容 + =，append( )，push_back() 添加字符 insert () 插入字符 erase() 删除字符 clear () 移除全部字符 resize () 改变字符数量 replace() 替换字符 + 串联字符串 ==，！ =，&lt;，&lt;=，&gt;，&gt;=，compare() 比较字符串内容 size()，length() 返回字符数量 max_size () 返回字符的最大可能个数 empty () 判断字符串是否为空 capacity () 返回重新分配之前的字符容量 reserve() 保留内存以存储一定数量的字符 [ ],at() 获取字符串元素 &gt;&gt;，getline() 从 stream 中读取某值 &lt;&lt; 将值写入 stream copy() 将内容复制为一个 C - string c_str() 将内容以 C - string 形式返回 data() 将内容以字符数组形式返回 substr() 返回子字符串 find() 搜寻某子字符串或字符 rfind() 逆向搜寻字符串或字符 find_first_of()**find_last_of()** 搜寻第一个/最后一个匹配的字符串 begin( )，end() 提供正向迭代器支持 rbegin()，rend() 提供逆向迭代器支持 get_allocator() 返回配置器 string构造和析构函数 类构造函数 string strs //生成空字符串string s(str) //生成字符串str的复制品string s(str, stridx) //将字符串str中始于stridx的部分作为构造函数的初值string s(str, strbegin, strlen) //将字符串str中始于strbegin、长度为strlen的部分作为字符串初值string s(cstr) //以C_string类型cstr作为字符串s的初值string s(cstr,char_len) //以C_string类型cstr的前char_len个字符串作为字符串s的初值string s(num, c) //生成一个字符串，包含num个c字符string s(strs, beg, end) //以区间[beg, end]内的字符作为字符串s的初值 析构函数~string() //销毁所有内存，释放内存 5种序列容器序列容器以线性序列的方式存储元素。它没有对元素进行排序，元素的顺序和存储它们的顺序相同。 array&lt;T,N&gt; (数组容器) ：是一个长度固定的序列，有 N 个 T 类型的对象，不能增加或删除元素。 vector&lt;T&gt; (向量容器) ：是一个长度可变的序列，用来存放T类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。 deque&lt;T&gt; (双向队列容器) ：是一个长度可变的、可以自动增长的序列，在序列的两端都不能高效地增加或删除元素。 list&lt;T&gt; (链表容器) 是一个长度可变的、由 T 类型对象组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。访问容器中任意元素的速度要比前三种容器慢，这是因为 list&lt;T&gt; 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。 forward list&lt;T&gt; (正向链表容器) ：是一个长度可变的、由 T 类型对象组成的序列，它以单链表的形式组织元素，是一类比链表容器快、更节省内存的容器，但是它内部的元素只能从第一个元素开始访问。 常用函数成员函数成员 array vector dequebegin() - 返回幵始迭代器 是 是 是end() - 返回结束迭代器 是 是 是rbegin() - 返回反向’开始迭代器 是 是 是rend() - 返回反向结束迭代器 是 是 是cbegin() - 返M const开始迭代器 是 是 是cend() - 返回const结束迭代器 是 是 是crbegin() - 返回const反向开始迭代器 是 是 是crend() - 返回const反向结束迭代器 是 是 是assign() - 用新元素替换原有内容 - 是 是operator=() - 复制同类型容器的元素，或者用初始化列表替换 现有内容 是 是 是size() - 返回实际元素个数 是 是 是max_size() - 返回元素个数的设大值 是 是 是capacity() - 返回当前容量 - 是 -empty() - 返回true,如果容器中没有元素的话 是 是 是resize() - 改变实际元素的个数 - 是 是shrink _to_fit() - 将内存减少到等于当前元素实际所使用的大小 - 是 是front() - 返回第一个元素的引用 是 是 是back() - 返回铖后一个元素的引用 是 是 是operator - 使用索弓丨访问元素 是 是 是at() - 使用经过边界检査的索引访问元素 是 是 是push_back() - 在序列的尾部添加一个元素 - 是 是insert() - 在指定的位置插入一个或多个元素 - 是 是emplace() - 在指定的位置直接生成一个元素 - 是 是emplace_back() - 在序列尾部生成一个元素 - 是 是pop_back() - 移出序列尾部的元素 - 是 是erase() - 移出一个元素或一段元素 - 是 是clear() - 移出所苻的元素，容器大小变为 0 - 是 是swap() - 交换两个容器的所有元素 是 是 是data() - 返回包含元素的内部数组的指针 是 是 - 函数成员 list forward listbegin() - 返回开始迭代器 是 是end() - 返回结束迭代器 是 是rbegin() - 返回反向开始迭代器 是 -rend() - 返回反向结束迭代器 是 -cbegin() - 返回 const 开始结束迭代器 是 是before_begin() - 返回一个指向第一个元素前一个位置的迭代器 - 是cbefore_begin() - 返回一个指向第一个元素前一个位置的const迭代器 - 是cend() - 返回 const 结束迭代器 是 是crbegin() - 返回 const 反向开始迭代器 是 -crend() - 返回 const 反向结束迭代器 是 -assign() - 用新元素替换原有内容 是 是operator=() - 复制同类型容器的元素，或者用初始化列表替换现有内容 是 是size() - 返回实际元素个数 是 -max_size() - 返回元素个数的最大值 是 是resize() - 改变实际元素的个数 是 是empty() - 返回 true，如果容器中没有元素的话 是 是from() - 返回第一个元素的引用 是 是back() - 返回最后一个元素的引用 是 -push_back() - 在序列的潘部添加一个元素 是 -push_front() - 在序列的起始位置添加一个元素 是 是emplace() - 在指矩位置直接生成一个元素 是 -emplace_after() - 在指定位置的后面直接生成一个元素 - 是emplace_back() - 在序列尾部生成一个元素 是 -cmplacc_front() - 在序列的起始位生成一个元索 是 是insert() - 在指定的位置插入一个或多个元素 是 -insert_after() - 在指定位置的后面插入一个或多个元素 - 是pop_back() - 移除序列尾部的元素 是 -pop_front() - 移除序列头部的元素 是 是reverse()-反向元素的顺序 是 是erase() - 移除指定位置的一个元素或一段元素 是 -erase_after() - 移除指定位 1；后面的一个元素或一段元素 - 是remove() - 移除所苻和参数匹配的元素 是 是remove_if() - 移除满足一元函数条件的所有元素 是 是unique() - 移除所有连续重复的元素 是 是clear() - 移除所有的元素，容器大小变为 0 是 是swap() - 交换两个容器的所有元素 是 是sort() - 对元素进行排序 是 是merge() - 合并两个有序容器 是 是splice() - 移动指定位置前面的所有元素到另一个同类型的 list 中 是 -splice_after() - 移动指定位置后面的所有元素到另一个同类型的 list 中 - 是 具体使用array：std::array&lt;typename, 100&gt; data {}; 通过调用数组对象的成员函数 fill()，可以将所有元素设成给定值 data.fill(0.0); 获取元素 data[num] 为了获取时能够检查越界索引值，可以使用成员函数 at()，当传给 at() 的索引是一个越界值时，这时会抛出 std::out_of_rang 异常 data.at(num) vector：std::vector&lt;typename&gt; values(num) {1,2,3,...}; 通过调用 reserve() 来增加容器的容量 values.reserve(20) 通过调用成员函数 resize() 可以改变容器大小 values.resize(size, num) 使用 push_back()、insert()、emplace() 或 emplace_back() 函数来添加一个元素values.push_back() //使用时会调用构造函数和拷贝构造函数values.emplace_back() // 不需要触发构造函数和拷贝构造函数 front() 和 back() 分別返回序列中第一个和最后一个元素的引用 values.front() data() 返回指向数组的指针 values.data() 迭代器 迭代器auto first = std::begin(data);auto last = std::end (data); 3种容器适配器容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。 stack&lt;T&gt;：是一个封装了 deque&lt;T&gt; 容器的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。stack&lt;T&gt;· 模板定义在头文件 stack 中。 queue&lt;T&gt;：是一个封装了 deque&lt;T&gt; 容器的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器。queue&lt;T&gt; 模板定义在头文件 queue 中。 priority_queue&lt;T&gt;：是一个封装了 vector&lt;T&gt; 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。priority_queue&lt;T&gt; 模板定义在头文件 queue 中。 4种map容器map&lt;K，T&gt;容器，保存的是 pair&lt;const K，T&gt; 类型的元素。pair&lt;const K,T&gt; 封装了一对键对象，键的类型是 K，对象的类型是 T。每个键都是唯一的，所以不允许有重复的键；但可以保存重复的对象，只要它们的键不同。map 容器中的元素都是有序的，元素在容器内的顺序是通过比较键确定的。默认使用 less 对象比较。multimap 容器和 map 容器类似，也会对元素排序。它的键必须是可比较的，元素的顺序是通过比较键确定的。和 map 不同的是，multimap 允许使用重复的键。因此，一个 multimap 容器可以保存多个具有相同键值的 元素。unordered_map 中 pair&lt; const K，T&gt;元素的顺序并不是直接由键值确定的，而是由键值的哈希值决定的。哈希值是由一个叫作哈希的过程生成的整数，本章后面会解释这一点。unordered_map不允许有重复的键。unordered_multimap 也可以通过键值生成的哈希值来确定对象的位置，但它允许有重复的键。 set容器set 容器是关联容器，其中的对象是对象它们自己的键 随机数流迭代器数值、时间和复数C++常用算法和algorithm库 参考资料C语言中文网C++ Primer Plus 第6版中文版学校教材]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列表基础算法]]></title>
    <url>%2F2019%2F03%2F19%2Fhashtable%2F</url>
    <content type="text"><![CDATA[-散列基础-散列（hash）是常用的算法思想之一，它使用空间换时间的思想在我第一次碰到时就感觉巧妙如魔法一般。特别是在进行一些大量数字和字符串比较方面，hash能瞬间将O(n^2)的复杂度降到O(n),单次查询的复杂度降到O(1)，靠的就是数组下标与查询的元素之间建立的唯一转换关系。 常用hash线性变换函数：H(key) = a*key+b除留余数：h(key) = key%mod 除留余数法会出现冲突的情况，需要解决多个hash值相同的情况 线性探测法：从当前位置检查相邻地址是否被占用，如果都被占用，循环检查下一个位置 平方探测法：从当前位置检查+1，-1，+4，-4，+9，-9……如果检查中+k^2超过表长（Tablesize），[H(key)+k^2]%Tablesize 链地址法：把hash相同的key连接成单链表 整数hash查询数组M中的数在数组N中是否出现过常规思路：遍历所有N，要遍历M次，时间复杂度O(MN)hash思路：bool hashTable[maxn]={false}，先读入N，N中出现的数x，hashTable[x]=true,再查询M，时间复杂度O(M+N) 示例 #include&lt;cstdio&gt;const int maxn = 1024;bool hashTable[maxn] = &#123;false&#125;;int main()&#123; int n[10] = &#123;2,6,8,12,23,5,15,5,0,1&#125;; int m[3] = &#123;8,22,5&#125;; int x; for(int i=0; i&lt;10; i++) hashTable&#123;n[i]&#125; = true; for(int j=0; j&lt;3;j++) &#123; if(hashTable&#123;m[j]]&#125; == true) printf("%d,yes\n",m[j]); else printf("%d,no\n",m[j]); &#125; return 0;&#125; 查询M中的数在N中出现的次数将hashTable 替换为int类型进行计数 示例 #include&lt;cstdio&gt;const int maxn = 1024;int hashTable[maxn] = &#123;0&#125;;int main()&#123; int n[10] = &#123;2,6,8,12,8,5,15,5,0,1&#125;; int m[3] = &#123;8,12,5&#125;; int x; for(int i=0; i&lt;10; i++) hashTable&#123;n[i]&#125;++; for(int j=0; j&lt;3;j++) &#123; printf("%d\n",hashTable&#123;m[j]&#125;); &#125; return 0;&#125; 字符串hash需要将字符串和整数唯一对应，可以直接对应或使用hash函数对应：A-Z 0~25，a-z 26~51 //将字符串S转换为整数int hashFunc(char S[], int len)&#123; int hashID = 0; for(int i=0; i&lt;len; i++) &#123; if(S[i]&gt;='A' &amp;&amp; S[i]&lt;='Z') hashID = hashID*52 + S[i] - 'A'; else if(S[i]&gt;='a' &amp;&amp; S[i]&lt;='z') hashID = hashID*52 + S[i]-'a'+ 26; &#125; return id;&#125;int id = hashFunc(P[i],52);hashTable[id] = P[i]; 查询N个字符串中M个字符串出现的次数，每个字符串长度固定为5#include&lt;cstdio&gt;const int maxn = 100;char S[maxn][5],temp[5];int hashTable[26*26*26+10];//每个字符串拥有唯一idint hashFunc(char S[], int len)&#123; int id = 0; for(int i=0; i&lt;len; i++) &#123; id = id*26 + (S[i]-'A'); &#125; return id;&#125;int main()&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for(int i=0; i&lt;n; i++) &#123; sacnf("%s", S[i]); int id = hashFunc(s[i], 3); hashTable[id]++; &#125; for(int i=0; i&lt;m; i++) &#123; sacnf("%s",temp); int id = hashFunc(temp, 3); printf("%d",hashTable[id]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>github-repo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autonomous Vehicles translate -- datasets & bechmarks]]></title>
    <url>%2F2019%2F03%2F18%2Fdatasets-benchmarks%2F</url>
    <content type="text"><![CDATA[Computer Vision for Autonomous Vehicles:Problems, Datasets and State-of-the-Art自动驾驶技术的计算机视觉：问题，数据和前沿技术数据集和基准 datasets &amp; Benchmarks 数据集和基准 Datasets have played a key role in the progress of many research fields by providing problem specific examples with ground truth. They allow quantitative evaluation of approaches providing key insights about their capacities and limitations. |In particular, several of these datasets Geiger et al. (2012b); Scharstein &amp; Szeliski (2002); Baker et al. (2011); Everingham et al. (2010); Cordts et al. (2016) also provide online evaluation servers which allow for a fair comparison on held-out test sets and provide researchers in the field an up-to-date overview over the state-of-the-art. |This way, current progress and remaining challenges can be easily identified by the research community. In the context of autonomous vehicles, the KITTI dataset Geiger et al. (2012b) and the Cityscapes dataset Cordts et al.(2016) have introduced challenging benchmarks for reconstruction, motion estimation and recognition tasks, and contributed to closing the gap between laboratory settings and challenging real-world situations. |Only a few years ago, datasets with a few hundred annotated examples were considered sufficient for many problems. The introduction of datasets with many hundred to thousands of labeled examples, however, has led to spectacular breakthroughs in many computer vision disciplines by training high-capacity deep models in a supervised fashion. |However, collecting a large amount of annotated data is not an easy endeavor, in particular for tasks such as optical flow or semantic segmentation. This initiated a collective effort to produce that kind of data in several areas by searching for ways to automate the process as much as possible such as through semi-supervised learning or synthesization. 数据集在许多研究领域进展方面发挥了关键作用，提供了真实的(ground truth)问题特例。它们允许通过提供有关其能力与局限的核心信息，数据集还可以对方法进行量化评估。 特别地，这些数据集中的几个比如Geiger（2012b）;Scharstein＆Szeliski（2002）; Baker（2011）;Everinghamet al（2010）; Cordts（2016）也提供在线评估服务器允许在延期测试（held-out）中进行公平的比较，而且为该领域的研究人员提供更新的目前最好的算法。 这种方式可以让研究团队很容易地确定目前的进展和剩下的挑战。在自主车辆的环境中，KITTI数据集Geiger（2012b）和Cityscapes数据集Cordts （2016）为重建、运动估计和识别任务引入了挑战性的基准，因此缩小了实验室设置与挑战现实世界的情况之间的差距。 几年前，有数百个注释例子的数据集对于解决很多问题是足够的。然而，有数百到数千个有标签的例子的数据集的引入，通过以监督的方式训练大容量深度模型，已经使得许多计算机视觉学科的重大突破。 然而，收集大量的注释数据不是一个容易的事情，特别是对于诸如光流或者语义分割的任务。这使得集体努力通过搜索尽可能多的方式来自动化过程，例如通过半监督学习或合成，从而在多个领域产生了这种数据。 Real-World Datasets 真实数据集 While several algorithmic aspects can be inspected using synthetic data, real-world datasets are necessary to guarantee performance of algorithms in real situations. For example, algorithms employed in practice need to handle complex objects and environments while facing challenging environmental conditions such as direct lighting, reflections from specular surfaces, fog or rain. The acquisition of ground truth is often labor intensive because very often this kind of information cannot be directly obtained with a sensor but requires tedious manual annotation. |For example, (Scharstein &amp; Szeliski (2002),Baker et al. (2011)) acquire dense pixel-level annotations in a controlled lab environment whereas Geiger et al. (2012b); Kondermann et al. (2016) provide sparse pixel-level annotations of real street scenes using a LiDAR laser scanner. Recently, crowdsourcing with Amazon’s Mechanical Turk9 have become very popular to create annotations for large scale datasets, e.g., Deng et al. (2009); Lin et al. (2014); Leal-Taix´e et al. (2015); Milan et al. (2016). However, the annotation quality obtained via Mechanical Turk is often not sufficient to be considered as reference and significant efforts in post-processing and cleaning-up the obtained labels is typically required. |In the following, we will first discuss the most popular computer vision datasets and benchmarks addressing tasks relevant to autonomous vision. Thereafter, we will focus on datasets particularly dedicated to autonomous vehicle applications. 虽然可以使用合成数据检查几个算法方面，但实际数据集对于确保算法在实际情况下的性能是必要的。例如，在实践中使用的算法需要处理复杂的对象和环境，同时面对挑战性的环境条件，例如直接照明，镜面反射，雾或雨。获取ground truth通常是劳动密集型的，因为这种信息通常不能用传感器直接获得，而是需要繁琐的手动注释。 例如，（Scharstein＆Szeliski（2002），Baker（2011））在受控实验室环境中获得了密集的像素级注释，而Geiger等人（2012B）; Kondermann等人（2016）使用LiDAR激光扫描仪提供实际街景场景的稀疏像素级注解。 最近，亚马逊的Mechanical Turk的众包已经变得非常受欢迎，为大型数据集创建注释，例如Deng（2009）;Lin（2014）; Leal-Taix’e（2015）; Milan（2016）。然而，通过Mechanical Turk获得的注释质量通常不太合适被认为是参考，并且通常需要在后处理中最初的重大努力和清理所获得的标签中也是非常需要的。 在下文中，我们将首先讨论最流行的计算机视觉数据集和基准，以解决与自主视觉相关的任务。此后，我们将专注于数据集，尤其致力于自动驾驶车辆的应用。 Stereo and 3D Reconstruction: The Middlebury stereo benchmark introduced by Scharstein &amp; Szeliski (2002) provides several multi-frame stereo data sets for comparing the performance of stereo matching algorithms. |Pixel-level ground truth is obtained by hand labeling and reconstructing planar components in piecewise planar scenes. Scharstein &amp; Szeliski (2002) further provide a taxonomy of stereo algorithms that allows the comparison of design decisions and a test bed for quantitative evaluation. |Approaches submitted to their benchmark website are evaluated using the root mean squared error and the percentage of bad pixels between the estimated and ground truth disparity maps. Scharstein &amp; Szeliski (2003) and Scharstein et al. (2014) introduced novel datasets to the Middlebury benchmark comprising more complex scenes and including ordinary objects like chairs, tables and plants. In both works a structured lighting system was used to create ground truth. |For the latest version Middlebury v3, Scharstein et al. (2014) generate highly accurate ground truth for high-resolution stereo images with a novel technique for 2D subpixel correspondence search and self-calibration of cameras as well as projectors. This new version achieves significantly higher disparity and rectification accuracy than those of existing datasets and allows a more precise evaluation. An example depth map from the dataset is illustrated in Figure 1. The Middlebury multi-view stereo (MVS) benchmark11 by Seitz et al. (2006) is a calibrated multi-view image dataset with registered ground truth 3D models for the comparison of MVS approaches. The benchmark played a key role in the advances of MVS approaches but is relatively small in size with only two scenes. |In contrast, the TUD MVS dataset12 by Jensen et al. (2014) provides 124 different scenes that were also recorded in controlled laboratory environment. Reference data is obtained by combining structured light scans from each camera position and the resulting scans are very dense, each containing 13.4 million points on average. For 44 scenes the full 360 degree model was obtained by rotation and scanning four times with 90 degree intervals. In contrast to the datasets so far, Sch¨ops et al. (2017) provide scenes that are not carefully staged in a controlled laboratory environment and thus represent real world challenges. Sch¨ops et al. (2017) recorded high-resolution DSLR imagery as well as synchronized low-resolution stereo videos in a variety of indoor and outdoor scenes. A high-precision laser scanner allows to register all images with a robust method. The high-resolution images enable the evaluation of detailed 3D reconstruction while the low-resolution stereo images are provided to compare approaches for mobile devices. 立体与 3D 重建类数据集：由Scharstein＆Szeliski（2002）引入的Middlebury立体声基准测试仪提供了多个立体声数据集，用于比较立体匹配算法的性能。 通过在分段平面场景中手工标记和重建平面构成获得像素级地面真值。Scharstein和Szeliski（2002）进一步提供立体声算法的分类法，允许通过比较设计决策和测试台来进行定量评估。 使用均方误差以及估计值和地面真实视差图之间坏像素的百分比来评估提交给其基准网站的方法。 Scharstein &amp; Szeliski (2003) 和 Scharstein et al. (2014)为Middlebury基准引入了一种新颖的数据集，这个数据及包含更多复杂的场景和普通的物体，比如椅子、桌子、植物等对象。在这两个工作中，均使用一个结构化的照明系统来创造地面实况。 对于最新版本的Middlebury v3，Scharstein（2014）采用新颖的2D子像素对应搜索和相机自动校准技术以及投影机为高分辨率立体图像生成高精度的地面实况。与现有数据集相比，该新版本的差异和整改精度明显提高，可以进行更精确的评估。 Figure 1是来自数据集的示例深度图：Seitz等人的Middlebury多视点立体声（MVS）基准测试（2006）是注册地面真相3D模型用于比较MVS方法一种校准的多视图图像数据集。基准测试在MVS方法的进步中发挥了关键作用，但只有两个场景，尺寸相对较小。相比之下，Jensen等人的TUD MVS数据集（2014年）提供了124个不同的场景，这些场景也被记录在受控实验室环境中。 参考数据通过组合来自每个摄像机位置的结构光扫描获得，并且所得到的扫描非常密集，平均每个包含13.4million个点。对于44个场景，通过以90度的间隔旋转和扫描四次获得完整的360度模型。 与迄今为止的数据集相比，Sch¨ops等人（2017年）提供了在受控实验室环境中未仔细分级的场景，从而代表了现实世界的挑战。Sch¨ops et al. (2017) 录制了高分辨率DSLR单反相机图像以及各种室内和室外场景中同步的低分辨率立体视频。 高精度激光扫描仪允许以强大的方法注册所有图像。高分辨率图像可以评估详细的3D重建，同时提供低分辨率立体图像来比较移动设备的方法。 Optical Flow: The Middlebury flow benchmark13 by Baker et al. (2011) provides sequences with non-rigid motion, synthetic sequences and a subset of the Middlebury stereo benchmark sequences (static scenes) for the evaluation of optical flow methods. For all non-rigid sequences, ground truth flow is obtained by tracking hidden fluorescent textures sprayed onto the objects using a toothbrush. The dataset comprises eight different sequences with eight frames each. Ground truth is provided for one pair of frames per sequence. Besides the limited size, real world challenges like complex structures, lighting variation and shadows are missing as the dataset necessitates laboratory conditions which allow for manipulating the light source between individual captures. In addition, it only comprises very small motions of up to twelve pixels which do not admit the investigation of challenges provided by fast motions. Compared to other datasets, however, the Middlebury dataset allows to evaluate sub-pixel precision since it provides very accurate and dense ground truth. Performance is measured using the angular error (AEE) and the absolute end point error (EPE) between the estimated flow and the ground truth. Janai et al. (2017) present a novel optical flow dataset comprising of complex real world scenes in contrast to the laboratory setting in Middlebury. High-speed video cameras are used to create accurate reference data by tracking pixel through densely sampled space-time volumes. This method allows to acquire optical flow ground truth in challenging everyday scenes in an automatic fashion and to augment realistic effects such as motion blur to compare methods in varying conditions. Janai et al. (2017) provide 160 diverse real-world sequences of dynamic scenes with a significantly larger resolution (1280X1024 Pixels) than previous optical datasets and compare several state of-the-art optical techniques on this data. 光流类数据集：Baker等人的“Middlebury流量标准” （2011）提供了具有非刚性运动序列，合成序列和Middlebury立体声基准序列（静态场景）的子集的序列，用于评估光流方法。 对于所有非刚性序列，通过使用toothbrush牙刷追踪在物体上喷洒的隐藏的荧光纹理来获得地面真实流。 数据集包含八个不同的序列，每个序列具有八个帧。 每个序列提供一对帧的地面实况。除了有限的大小之外，由于数据集需要实验室条件，允许在各个捕获之间操纵光源，所以缺少像复杂结构，照明变化和阴影这样的真实世界挑战。 此外，它只包含最多十二个像素的非常小的运动，不承认对快速运动提供的挑战的调查。 然而，与其他数据集相比，Middlebury数据集可以评估子像素精度，因为它提供了非常精确和密集的地面实例。 使用角度误差（AEE）和估计流量与地面实数之间的绝对终点误差（EPE）来测量性能。Janai等人 （2017）提出了一个新颖的光流数据集，其中包括复杂的现实世界场景，与Middlebury的实验室设置相反。 高速视频摄像机用于通过密集采样的时空容量跟踪像素来创建精确的参考数据。 该方法允许以自动方式在挑战性的日常场景中获取光流场地真相，并且增加诸如运动模糊的现实效果以在不同条件下比较方法。 Janai等人 （2017年）提供了160个不同的现实世界动态场景序列，具有比以前的光学数据集显着更大的分辨率（1280x1024像素），并比较了这些数据的几种最先进的光学技术。 Object Recognition and Segmentation: The availability of large-scale, publicly available datasets such as ImageNet (Denget al. (2009)), PASCAL VOC (Everingham et al. (2010)), Microsoft COCO (Lin et al.(2014)), Cityscapes (Cordts et al.(2016)) and TorontoCity (Wang et al. (2016)) have had a major impact on the success of deep learning in object classification, detection, and semantic segmentation tasks. The PASCAL Visual Object Classes (VOC) challenge14 by Everingham et al. (2010) is a benchmark for object classification, object detection, object segmentation and action recognition. It consists of challenging consumer photographs collected from Flickr with high quality annotations and contains large variability in pose, illumination and occlusion. Since its introduction, the VOC challenge has been very popular and was yearly updated and adapted to the needs of the community until the end of the program in 2012. Whereas the first challenge in 2005 had only 4 different classes, 20 di erent object classeswere introduced in 2007. Over the years, the benchmark grew in size reaching a total of 11,530 images with 27,450 ROI annotated objects in 2012. In 2014, Lin et al. (2014) introduced the Microsoft COCO dataset15 for the object detection, instance segmentation and contextual reasoning. They provide images of complex everyday scenes containing common objects in their natural context. The dataset comprises 91 object classes, 2.5 million annotated instances and 328k images in total. Microsoft COCO is significantly larger in the number of instances per class than the PASCAL VOC object segmentation benchmark. All objects are annotated with per-instance segmentations in an extensive crowd worker effort. Similar to PASCAL VOC, the intersection-overunion metric is used for evaluation. 对象识别与分割类数据集：大量的公开数据集，如ImageNet（Deng等人（2009）），PASCAL VOC（Everingham等（2010）），Microsoft COCO（Lin等人（2014）），Cityscapes（Cordts （2016））和TorontoCity（Wang等人（2016年））对物体分类，目标检测和语义分割任务中深入学习的成功产生了重大影响。 由Everingham等人（2010）提供的PASCAL视觉对象类（VOC）挑战是对象分类，物体检测，物体分割和动作识别的基准。它由具有高质量标注的Flickr收集的有挑战性的消费者照片组成，并且包含姿势，照明和遮挡的大变化。 自从介绍以来，VOC的挑战一直很受欢并且逐年更新并适应社区的需求直到2012年计划结束。而2005年的第一个挑战只有4个不同的类，2007年引入了20个不同的对象类。多年来，基准规模在2012年达到总共11,530张图像当中共有27,450张ROI注释物体。 2014年，Lin等 （2014）介绍了Microsoft COCO数据集，用于物体检测，实例分割和上下文推理。 它们在自然环境中提供包含常见对象的复杂日常场景的图像。 数据集总共包括91个对象类，250万个注释实例和328k个图像。 Microsoft COCO在PASCAL VOC对象分割基准测试中每个类的实例数显著增加。 所有物体都在广泛的人群工作人员的努力下对每个实例进行标注。 与PASCAL VOC类似，IOU度量用于评估。 Tracking: Leal-Taix´e et al. (2015); Milan et al. (2016) present the MOTChallenge16 which addresses the lack of a centralized benchmark for multi object tracking. The benchmark contains 14 challenging video sequences in unconstrained environments filmed with static and moving cameras and subsumes many existing multi-object tracking benchmarks such as PETS (Ferryman &amp; Shahrokni (2009)) and KITTI (Geiger et al.(2012b)). The annotations for three object classes are provided: moving or standing pedestrians, people that are not in an upright position and others. They use the two popular tracking measures, Multiple Object Tracking Accuracy (MOTA) and Multiple Object Tracking Precision (MOTP) introduced by Stiefelhagen et al. (2007) for the evaluation of the approaches. Detection ground truth provided by the authors allows to analyze the performance of tracking systems independent of a detection system. Methods using a detector and methods using the detection ground truth can be compared separately on their website. - Aerial Image Datasets: The ISPRS benchmark17 (Rottensteiner et al. (2013, 2014)) provides data acquired by airborne sensors for urban object detection and 3D building reconstruction and segmentation. It consists of two datasets: Vaihingen and Downtown Toronto. The object classes considered in the object detection task are building, road, tree, ground, and car. The Vaihingen dataset provides three areas with various object classes and a large test site for road detection algorithms. The Downtown Toronto dataset covers an area of about 1.45 km2 in the central area of Toronto, Canada. Similarly to Vaihingen, there are two smaller areas for object extraction and building reconstruction, as well as one large area for road detection. For each test area, aerial images with orientation parameters, digital surface model (DSM), orthophoto mosaic and airborne laser scans are provided. The quality of the approaches is assessed using several metrics for detection and reconstruction. In both cases completeness, correctness and quality is assessed on a per-area level and a per-object level. 追踪：Leal-Taix’e（2015），Milan（2016）提出了MOTChallenge16，解决了多对象跟踪缺乏集中的基准。该基准测试包含14个具有静态和移动摄像机拍摄的无约束环境的挑战性视频序列，并包含许多现有的多对象跟踪基准，如PETS（Ferryman＆Shahrokni（2009））和KITTI（Geiger等（2012b））。提供三个对象类的注释：移动或站立的行人，不在直立位置的人等。他们使用Stiefelhagen等人介绍的两个流行的跟踪措施，多目标跟踪精度（MOTA）和多对象跟踪精度（MOTP）。 （2007）评估方法。作者提供的检测基准真实性可以分析独立于检测系统的跟踪系统的性能。使用检测器的方法和使用检测基准的方法可以在其网站上单独进行比较。 - 空中图像数据集：ISPRS benchmark17（Rottensteiner等（2013，2014））提供了用于城市物体检测和3D建筑重建和分割的机载传感器获取的数据。它包括两个数据集：Vaihingen和多伦多市区。对象检测任务中考虑的对象类是建筑，道路，树木，地面和汽车。 Vaihingen数据集提供了三个不同对象类别的区域和一个用于道路检测算法的大型测试站点。多伦多市中心数据集在加拿大多伦多的中部地区面积约1.45平方公里。与Vaihingen类似，有两个较小的对象提取和建筑重建区域，以及一个大面积的道路检测。对于每个测试区域，提供具有取向参数，数字表面模型（DSM），正射影像马赛克和机载激光扫描的航空图像。使用检测和重建的几个度量来评估方法的质量。在这两种情况下，完整性，正确性和质量都在每个面积水平和每个物体水平上进行评估。 Autonomous Driving: In 2012, Geiger et al. (2012b, 2013) have introduced the KITTI Vision Benchmark18 for stereo, optical flow, visual odometry/SLAM and 3D object detection (Figure). The dataset has been captured from an autonomous driving platform and comprises six hours of recordings using high-resolution color and grayscale stereo cameras, a Velodyne 3D laser scanner and high-precision GPS/IMU inertial navigation system. The stereo and optical flow benchmarks derived from this dataset comprise 194 training and 195 test image pairs at a resolution of 1280  376 pixels and sparse ground truth obtained by projecting accumulated 3D laser point clouds onto the image. Due to the limitations of the rotating laser scanner used as reference sensor, the stereo and optical flow benchmark is restricted to static scenes with camera motion. To provide ground truth motion fields for dynamic scenes, Menze &amp; Geiger (2015) have annotated 400 dynamic scenes, fitting accurate 3D CAD models to all vehicles in motion in to order to obtain flow and stereo ground truth for these objects. The KITTI flow and stereo benchmarks use the percentage of erroneous (bad) pixels to assess the performance of the submitted methods. Additionally, Menze &amp; Geiger (2015) combined the stereo and flow ground truth to form a novel 3D scene flow benchmark. For evaluating scene flow, they combine classical stereo and optical flow measures. The visual odometry / SLAM challenge consists of 22 stereo sequences, with a total length of 39.2 km. The ground truth pose is obtained using GPS/IMU localization unit which was fed with RTK correction signals. The translational and rotational error averaged over a particular trajectory length is considered for evaluation. For the KITTI object detection challenge, a special 3D labeling tool has been developed to annotate all 3D objects with 3D bounding boxes for 7481 training and 7518 test images. The benchmark for the object detection task was separated into a vehicle, pedestrian and cyclist detection tasks, allowing to focus the analysis on the most important problems in the context of autonomous vehicles. Following PASCAL VOC Everingham et al. (2010), the intersection-over-union (IOU) metric is used for evaluation. For an additional evaluation, this metric has been extended to capture both 2D detection and 3D orientation estimation performance. A true 3D evaluation is planned to be released shortly. The KITTI benchmark was extended by Fritsch et al. (2013) to the task of road/lane detection. In total, 600 diverse training and test images have been selected for manual annotation of road and lane areas. Mattyus et al. (2016) used aerial images to enhance the KITTI dataset with fine grained segmentation categories such as parking spots and sidewalk as well as the number and location of road lanes. The KITTI dataset has established itself as one of the standard benchmarks in all of the aforementioned tasks, in particular in the context of autonomous driving applications. 2012年，Geiger等（2012b，2013）推出了用于立体声，光流，视觉测距/ SLAM和3D物体检测的KITTI Vision Benchmark18（图）。数据集已从自主驾驶平台捕获，包括使用高分辨率彩色和灰度立体相机的六小时录音，Velodyne 3D激光扫描仪和高精度GPS / IMU惯性导航系统。从该数据集派生的立体声和光流基准测试包括194次训练和195个测试图像对，分辨率为1280？通过将累积的3D激光点云投影到图像上获得的376个像素和稀疏的地面真实。由于用作参考传感器的旋转激光扫描仪的局限性，立体声和光学流量基准仅限于具有摄像机运动的静态场景。 为了为动态场景提供地面真相运动场，Menze＆Geiger（2015）已​​经注明了400个动态场景，将精确的3D CAD模型适用于所有运动的车辆，以获得这些物体的流动和立体声地面实况。 KITTI流量和立体声基准使用错误（不良）像素的百分比来评估提交的方法的性能。此外，Menze＆Geiger（2015）结合了立体声和流动地面的真相，形成了一种新颖的3D场景流动基准。为了评估场景流，它们结合了古典立体声和光学流量测量。 视觉测距/ SLAM挑战包括22个立体声序列，总长39.2公里。使用馈送有RTK校正信号的GPS / IMU定位单元获得地面真实姿势。考虑在特定轨迹长度上平均的平移和旋转误差进行评估。 对于KITTI对象检测挑战，已经开发了一种特殊的3D标签工具，用于通过3D边界框注释所有3D对象，用于7481个训练和7518个测试图像。物体检测任务的基准被分为车辆，行人和骑车人员检测任务，允许将分析集中在自主车辆的上下文中最重要的问题。按照PASCAL VOC Everingham等（2010），交叉联合（IOU）度量用于评估。为了进一步评估，该指标已扩展到捕获2D检测和3D定向估计性能。计划即将发布真正的3D评估。 由Fritsch等人扩展了KITTI基准。 （2013年）到道路/车道检测任务。总共选择了600多种不同的训练和测试图像，用于手动注释道路和车道区域。 Mattyus等人（2016）使用航空图像来增强KITTI数据集，并提供诸如停车位和人行道之类的细粒度细分类别，以及道路的数​​量和位置。 KITTI数据集已经成为所有上述任务的标准基准之一，特别是在自主驾驶应用的上下文中。 Complementary to other datasets, the HCI benchmark19 proposed in Kondermann et al. (2016) specifically includes realistic, systematically varied radiometric and geometric challenges. Overall, a total of 28,504 stereo pairs with stereo and flow ground truth is provided. In contrast to previous datasets, ground truth uncertainties have been estimated for all static regions. The uncertainty estimate is derived from pixel-wise error distributions for each frame which are computed based on Monte Carlo sampling. Dynamic regions are manually masked out and annotated with approximate ground truth for 3,500 image pairs. The major limitation of this dataset is that all sequences were recorded in a single street section, thus lacking diversity. On the other hand, this enabled better control over the content and environmental conditions. In contrast to the mobile laser scanning solution of KITTI, the static scene is scanned only once using a high-precision laser scanner in order to obtain a dense and highly accurate ground truth of all static parts. Besides the metrics used in KITTI and Middlebury, they use semantically meaningful performance metrics such as edge fattening and surface smoothness for evaluation Honauer et al. (2015). The HCI benchmark is rather new and not established yet but the controlled environment allows to simulate rarely occurring events such as accidents which are of great interest in the evaluation of autonomous driving systems. The Caltech Pedestrian Detection Benchmark20 proposed by Dollar et al. (2009) provides 250,000 frames of sequences recorded by a vehicle while driving through regular traffic in an urban environment. 350,000 bounding boxes and 2,300 unique pedestrians were annotated including temporal correspondence between bounding boxes and detailed occlusion labels. Methods are evaluated by plotting the miss rate against false positives and varying the threshold on detection confidence. The Cityscapes Dataset21 by Cordts et al. (2016) provides a benchmark and large-scale dataset for pixel-level and instancelevel semantic labeling that captures the complexity of realworld urban scenes. It consists of a large, diverse set of stereo video sequences recorded in streets of different cities. High quality pixel-level annotations are provided for 5,000 images while 20,000 additional images have been annotated with coarse labels obtained using a novel crowd sourcing platform. For two semantic granularities, i.e., classes and categories, they report mean performance scores and evaluate the intersection-overunion metric at instance-level to assess how well individual instances are represented in the labeling. The TorontoCity benchmark presented byWang et al. (2016) covers the greater Toronto area with 712 km2 of land, 8,439 km of road and around 400,000 buildings. The benchmark covers a large variety of tasks including building height estimation (reconstruction), road centerline and curb extraction, building instance segmentation, building contour extraction, semantic labeling and scene type classification. The dataset was captured from airplanes, drones, and cars driving around the city to provide different perspectives. 与其他数据集的补充，在Kondermann等人提出的HCI基准19。 （2016）具体包括现实的，有系统地变化的辐射和几何挑战。总的来说，共提供了28,504立体声和流动地面真相的立体声对。与以前的数据集相比，所有静态区域的地面真实不确定度已被估计。不确定性估计是根据基于蒙特卡洛取样计算的每个帧的像素误差分布得出的。手动屏蔽动态区域并用3,500个图像对的近似地面实例进行注释。 这个数据集的主要限制是所有序列记录在单个街区，因此缺乏多样性。另一方面，这能够更好地控制内容和环境条件。与KITTI的移动激光扫描解决方案相比，静态场景仅使用高精度激光扫描仪扫描一次，以获得所有静态部件的致密和高精度的地面实况。除了KITTI和Middlebury使用的指标之外，他们使用语义有意义的性能指标，如边缘育肥和表面平滑度评估Honauer等。 （2015年）。 HCI基准相当新，尚未建立，但受控环境允许模拟很少发生的事件，例如对自主驾驶系统的评估感兴趣的事故。 美国加州大学提出的Caltech行人检测基准20 （2009）提供了车辆记录的25万帧序列，同时在城市环境中经常进行交通。包括350,000个边界框和2,300个独特的行人，包括边界框和详细遮挡标签之间的时间对应关系。通过绘制误差率与误报率并在检测置信度上改变阈值来评估方法。 由Cordts等人的Cityscapes Dataset21 （2016）为像素级和实例级语义标注提供了基准和大型数据集，捕捉到现实城市场景的复杂性。它由不同城市的街道上记录的大型，多样化的立体视频序列组成。为5,000张图像提供了高质量的像素级注释，而使用新颖的人群采购平台获得的粗略标签已经注明了20,000张附加图像。对于两个语义粒度，即类别和类别，他们报告平均绩效评分，并评估实例级别的交叉点平均度量，以评估在标签中表示个体实例的程度。 Wang等人提出的多伦多城市基准（2016年）覆盖多伦多地区，712平方公里的土地，8,439公里的道路和大约40万个建筑物。该基准涵盖了建筑高度估计（重建），道路中心线和路缘提取，建筑物实例分割，建筑轮廓提取，语义标注和场景类型分类等各种任务。数据集被从飞机，无人驾驶飞机和汽车驾驶在城市周围捕获，以提供不同的观点。 Long-Term Autonomy: Several datasets such as KITTI or Cityscapes focus on the development of algorithmic competences for autonomous driving but do not address challenges of long-term autonomy, as for examples environmental changes over time. To address this problem, a novel dataset for autonomous driving has been presented by Maddern et al. (2016). They collected images, LiDAR and GPS data while traversing 1,000 km in central Oxford in the UK during one year. This allowed them to capture large variations in scene appearance due to illumination, weather and seasonal changes, dynamic objects, and constructions. Such long-term datasets allow for in-depth investigation of problems that detain the realization of autonomous vehicles such as localization in different times of the year. 长期自动：几个数据集，如KITTI或Cityscapes，着重于开发自主驾驶的算法能力，但不能解决长期自主的挑战，例如随着时间的推移环境变化。 为了解决这个问题，Maddern等人提出了一个用于自主驾驶的新型数据集。（2016）。 他们在一年内在英国牛津中心穿过1000公里的地方收集图像，LiDAR和GPS数据。 这允许他们捕获由于照明，天气和季节变化，动态对象和结构而导致的场景外观的大变化。 这些长期数据集允许深入调查在一年中的不同时期扣留自主车辆的实现问题，例如本地化。 Synthetic Data The generation of ground truth for real examples is very labor intensive and often not even possible at large scale when pixel-level annotations are required. On the other hand, pixel-level ground truth for large-scale synthetic datasets can be easily acquired. However, the creation of realistic virtual world is time-consuming. The popularity of movies and video games have led to an industry creating very realistic 3D content which nourishes the hope to replace real data completely using synthetic datasets. Consequently, several synthetic datasets have been proposed, recently, but it remains an open question whether the realism and variety attained is sufficient to replace real world datasets. Besides, creating realistic virtual content is a time consuming and expensive process itself and the trade-off between real and synthetic (or augmented) data is not clear yet. 为真实的例子生成地面真相是非常劳动密集型的，并且在需要像素级注释时通常甚至不可能大规模地实现。 另一方面，可以轻松获取大规模合成数据集的像素级地面实况。 然而，创造现实的虚拟世界是耗时的。 电影和视频游戏的普及导致了行业创造了非常逼真的3D内容，这些内容丰富了使用合成数据集完全替代实际数据的希望。 因此，最近已经提出了几个合成数据集，但是现实主义和品种是否足以替代现实世界数据集仍然是一个悬而未决的问题。 此外，创建逼真的虚拟内容是一个耗时且昂贵的过程本身，真实和合成（或增强）数据之间的权衡尚不清楚。 MPI Sintel: The MPI Sintel Flow benchmark22 presented by Butler et al. (2012) takes advantage of the open source movie Sintel, a short animated film, to render scenes of varying complexity with optical flow ground truth. In total, Sintel comprises 1,628 frames. Different datasets obtained using different passes of the rendering pipeline vary in complexity shown in Figure 3. The albedo pass has roughly piecewise constant colors without illumination effects while the clean pass introduces illumination of various kinds. The final pass adds atmospheric effects, blur, color correction and vignetting. In addition to the average endpoint error, the benchmark website provides different rankings of the methods based on speed, occlusion boundaries, and disocclusions. Flying Chairs and Flying Things: The limited size of optical flow datasets hampered the training of deep high-capacity models. To train a convolutional neural network, Dosovitskiy et al.(2015) thus introduced a simple synthetic 2D dataset of flying chairs rendered on top of random background images from Flickr. As the limited realism and size of this dataset proved insufficient to learn highly accurate models, Mayer et al. (2016) presented another large-scale dataset consisting of three synthetic stereo video datasets: FlyingThings3D, Monkaa, Driving. FlyingThings3D provides everyday 3D objects flying along randomized 3D trajectories in a randomly created scene. Inspired by the KITTI dataset a driving dataset has been created which uses car models from the same pool as FlyingThings3D and additionally highly detailed tree and building models from 3D Warehouse. Monkaa is an animated short movie similar to Sintel used in the MPI Sintel benchmark. Game Engines: Unfortunately, data from animated movies is very limited since the content is hard to change and such movies are rarely open source. In contrast, game engines allow for creating an infinite amount of data. One way to create virtual worlds using a game engine is presented by Gaidon et al. (2016) which introduces the Virtual KITTI dataset23. They present an efficient real-to-virtual world cloning method to create realistic proxy worlds. A cloned virtual world allows to vary conditions such as weather or illumination and to use different camera settings. This way, the proxy world can be used for virtual data augmentation to train deep networks. Virtual KITTI contains 35 photo-realistic synthetic videos with a total of 17,000 high resolution frames. They provide ground truth for object detection, tracking, scene and instance segmentation, depth and optical flow. MPI Sintel ：由Butler等人提出的MPI Sintel Flow benchmark22 （2012）利用开源电影Sintel（短片动画），以光流地面的真相呈现不同复杂度的场景。总共有Sintel包括1,628帧。使用不同渲染流程获得的不同数据集的复杂度如图3所示。反照率传递具有大致分段恒定颜色，无照明效果，而清洁通道则引入各种照明。最后的通行证增加了大气效果，模糊，颜色校正和渐晕。除了平均终点误差之外，基准网站还提供了基于速度，遮挡边界和不相关的方法的不同排名。 飞行椅和飞行事物：光流数据集的数量有限，妨碍了深层大容量模型的训练。为了训练卷积神经网络，Dosovitskiy等人（2015）引入了一个简单的合成2D数据集，它们呈现在Flickr的随机背景图像之上。由于该数据集的有限现实性和大小证明不足以学习高精度模型，Mayer等（2016）提出了另外一个由三个合成立体视频数据集组成的大型数据集：FlyingThings3D，Monkaa，Driving。 FlyingThings3D在随机创建的场景中提供随机3D轨迹飞行的每天3D对象。受KITTI数据集的启发，已经创建了一个驱动数据集，它使用与FlyingThings3D相同的池中的汽车模型，以及来自3D Warehouse的另外高度详细的树和建筑模型。 Monkaa是一个类似于Sintel的动画短片，用于MPI Sintel基准测试。 游戏引擎：不幸的是，动画电影的数据非常有限，因为内容很难改变，这样的电影很少是开源的。相比之下，游戏引擎允许创建无限量的数据。 Gaidon等人提出了使用游戏引擎创建虚拟世界的一种方式。 （2016）介绍了虚拟KITTI数据集23。他们提出了一种高效的实时虚拟世界克隆方法来创建现实的代理世界。克隆的虚拟世界允许改变诸如天气或照明的条件，并使用不同的相机设置。这样，代理世界可以用于虚拟数据扩充来训练深层网络。虚拟KITTI包含35张照片合成视频，总共17,000个高分辨率帧。它们为物体检测，跟踪，场景和实例分割，深度和光流提供了基础。 In concurrent work, Ros et al. (2016) created SYNTHIA24, a synthetic collection of Imagery and Annotations of urban scenarios for semantic segmentation. They rendered a virtual city with the Unity Engine. The dataset consists of 13,400 randomly taken virtual images from the city and four video sequences with 200,000 frames in total. Pixel-level semantic annotations are provided for 13 classes. Richter et al. (2016) have extracted pixel-accurate semantic label maps for images from the commercial video game Grand Theft Auto V. Towards this goal, they developed a wrapper which operates between the game and the graphics hardware to obtain pixel-accurate object signatures across time and instances. The wrapper allows them to produce dense semantic annotations for 25 thousand images synthesized by the photorealistic open-world computer game with minimal human supervision. However, for legal reasons, the extracted 3D geometry can not be made publicly available. Similarly, Qiu &amp; Yuille (2016) provide an open-source tool to create virtual worlds by accessing and modifying the internal data structure of Unreal Engine 4. They show how virtual worlds can be used to test deep learning algorithms by linking them with the deep learning framework Caffe Jia et al. (2014). 在并行工作中，Ros et al。 （2016）创建了SYNTHIA24，一种用于语义分割的城市场景图像和注释的综合集合。他们用Unity Engine渲染了一个虚拟的城市。该数据集由13,400个随机抽取的城市虚拟图像和四个视频序列组成，共20万帧。为13个类提供像素级语义注释。 Richter et al。 （2016）已经为商业视频游戏“侠盗猎车手”V提取了图像的像素精确语义标签贴图。为了实现这一目标，他们开发了一种在游戏和图形硬件之间运行的包装器，以便跨越时间获得像素精确的对象签名，实例。包装器允许他们通过最小的人力监督来生成由真实感的开放世界电脑游戏合成的2.5万张图像的密集语义注释。然而，出于法律原因，提取的3D几何不能公开获得。同样，Qiu&amp;Yuille（2016）通过访问和修改虚幻引擎4的内部数据结构，提供了一个开源工具来创建虚拟世界。他们展示了虚拟世界如何通过将深度学习算法与深层次学习框架Caffe Jia（2014）。]]></content>
      <categories>
        <category>paper</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[各类排序算法实践]]></title>
    <url>%2F2019%2F03%2F17%2Fsort%2F</url>
    <content type="text"><![CDATA[比较重要的基础算法，简单罗列一下一些排序的实践过程 冒泡排序选择排序从待排序部分a[i,m]选择最小元素，与待排序部分的第一个元素a[i]交换，形成新的有序区间a[1,i+1]选择排序总体实践复杂度O(n^2) void selectSout()&#123; for(int i=1; i&lt;=n; i++) &#123; int flag = i; for(int j=i; j&lt;=n; j++) &#123; if(a[j] &lt; a[flag]) flag = j; &#125; // 交换a[i]和a[flag] int temp = a[i]; a[i] = a[flag]; a[flag] = temp; &#125;&#125; 插入排序 归并排序快速排序sort函数运用]]></content>
      <categories>
        <category>github-repo</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autonomous Vehicles translate -- abstract & previous & history]]></title>
    <url>%2F2019%2F03%2F14%2Fabstract-previous-history%2F</url>
    <content type="text"><![CDATA[Computer Vision for Autonomous Vehicles:Problems, Datasets and State-of-the-Art自动驾驶技术的计算机视觉：问题，数据和前沿技术摘要，前沿和技术历史 Abstract 摘要 Recent years have witnessed amazing progress in AI related fields such as computer vision, machine learning and autonomous vehicles. |As with any rapidly growing field, however, it becomes increasingly difficult to stay up-to-date or enter the field as a beginner. |While several topic specific survey papers have been written, to date no general survey on problems, datasets and methods in computer vision for autonomous vehicles exists.|This paper attempts to narrow this gap by providing a state-of-the-art survey on this topic. Our survey includes both the historically most relevant literature as well as the current state-of-the-art on several specific topics, including recognition, reconstruction, motion estimation, tracking, scene understanding and end-to-end learning. |Towards this goal, we first provide a taxonomy to classify each approach and then analyze the performance of the state-of-the-art on several challenging benchmarking datasets including KITTI, ISPRS, MOT and Cityscapes. |Besides, we discuss open problems and current research challenges. To ease accessibility and accommodate missing references, we will also provide an interactive platform which allows to navigate topics and methods, and provides additional information and project links for each paper.Keywords: Computer Vision, Autonomous Vehicles, Autonomous Vision 概述：人类见证了最近几年AI相关领域的惊人进步，如计算机视觉，机器学习和自动驾驶。然而任何一个快速发展的领域，保持领先或刚开始进入这些领域变得越来越难(业内人员难以跟上行业节奏或者业外人员难入行)。尽管已经(有人)发表了一些这方面的专题研究文章，但在自动驾驶技术中，计算机视觉的问题、数据和方法至今没有普遍的研究。对于这个话题，这篇论文试图通过提供对前沿技术的研究来减少这种缺口。我们的研究包括最相关的历史资料和当前最前沿的技术，包括识别、重建运动估测、追踪场景理解和端到端学习等。为完成这个目标，我们首先通过分类学对每一个方法进行分类，然后在一些具有挑战性的基础数据集上，如KITTI、ISPRS、MOT和Cityscapes上分析每一个方法在前沿技术上的表现此外，我们还讨论了一些开放问题和当前研究的挑战，为了轻松访问和适应缺失的参考，我们将提供一个具有主题和方法的驾驶交互平台，并提供额外信息和每篇论文的项目链接关键词：计算机视觉，自动驾驶，自主视觉 previous 前言 Since the first successful demonstrations in the 1980s (Dick-manns &amp; Mysliwetz (1992); Dickmanns &amp; Graefe (1988); Thorpeet al. (1988)), great progress has been made in the field of autonomous vehicles. |Despite these advances, however, it is safe to believe that fully autonomous navigation in arbitrarily complex environments is still decades away. |The reason for this is two-fold: First, autonomous systems which operate in complex dynamic environments require artificial intelligence which generalizes to unpredictable situations and reasons in a timely manner. |Second, informed decisions require accurate perception, yet most of the existing computer vision systems produce errors at a rate which is not acceptable for autonomous navigation. 从20世纪80年代首次成功展示以来(Dick-manns &amp; Mysliwetz (1992); Dickmanns &amp; Graefe (1988); Thorpeet al. (1988))(Dick-manns &amp; Mysliwetz (1992); Dickmanns &amp; Graefe (1988); Thorpeet al. (1988))，自动驾驶技术领域已经取得了很大进展尽管有了这些进展，但在任意复杂环境中，实现完全自动驾驶仍然被认为需要几十年原因有两点：第一，在复杂的、动态的环境中运行的自动驾驶系统需要人工智能来归纳不可预测的情形和原因，给出及时的方法第二，信息的决策需要准确的感知，目前大多数已有的计算机视觉系统有一定的错误率，这是自动驾驶技术无法接受的 In this paper, we focus on the second aspect which we call autonomous vision and investigate the performance of current perception systems for autonomous vehicles. |Towards this goal, we first provide a taxonomy of problems and classify existing datasets and techniques using this taxonomy, describing the pros and cons of each method. Second, we analyze the current state-of-the-art performance on several popular publicly available benchmarking datasets. |In particular, we provide a novel in-depth qualitative analysis of the KITTI benchmark which shows the easiest and most difficult examples based on the methods submitted to the evaluation server. |Based on this analysis, we discuss open research problems and challenges. To ease navigation, we also provide an interactive online tool which visualizes our taxonomy using a graph and provides additional information and links to project pages in an easily accessible manner. |We hope that our survey will become a useful tool for researchers in the field of autonomous vision and lowers the entry barrier for beginners by providing an exhaustive overview over the field. 在这篇论文中，我们关注第二个方面的问题，也就是自动驾驶视觉，同时调查最近的自动驾驶视觉中感知系统的表现为完成这个目标，我们首先给出了问题的分类，归类了已有的数据和可使用的技术，描述每种方法的优缺点。第二，我们在几个流行的公开数据集上分析了最近前沿成果的表现特别是我们给出一种KITTI基准的新的深入定性分析，这些分析展示了提交给评价服务器的方法中最简单和最困难的例子基于这些分析，我们讨论了开放的研究问题和挑战，为了简化学习，我们也给出一个在线交互式工具，用图像可视化了分类，并提供额外信息和一个简单可行的方法与项目页链接我们希望我们的研究能够成为自动驾驶领域研究人员的一个有用的工具，并通过透彻的概述，降低新人进入该领域的门槛 There exist several other related surveys. Winner et al. (2015) explains in detail systems for active safety and driver assistance, considering both their structure and their function. |Their focus is to cover all aspects of driver assistance systems and the chapter about machine vision covers only the most basic concepts of the autonomous vision problem. |Klette (2015) provide an overview over vision-based driver assistance systems. They describe most aspects of the perception problem at a high level, but do not provide an in-depth review of the state-of-the-art in each task as we pursue in this paper. |Complementary to our survey, Zhu et al. (2017) provide an overview of environment perception for intelligent vehicles, focusing on lane detection, traffic sign/light recognition as well as vehicle tracking. |In contrast, our goal is to bridge the gap between the robotics, intelligent vehicles, photogrammetry and computer vision communities by providing an extensive overview and comparison which includes works from all fields. 目前也有一些其它相关的研究，Winner et al. (2015)详细地解释了主动安全性和驾驶辅助系统，同时考虑了它们的结构和功能这些研究注重覆盖辅助驾驶系统的所有方面，但关于机器视觉的章节只覆盖到了自动驾驶技术中最基础的概念。Klette (2015)提供了一个基于视觉的辅助驾驶系统的概述，他们描述了高层次感知问题的大部分方面，但并没有像我们在论文中追求的一样，给出在各种前沿任务中比较深入的评测Zhu et al. (2017)提出了智能汽车环境感知的概述，聚焦在车道检测，交通信号灯识别和机车追踪问题，这与我们的研究相互补充。相比较下，我们的目标是通过提供广泛的概述和比较，包括在这个领域所有的成果，在机器人、智能汽车、摄影测绘和计算机视觉之间建立起一座桥梁 History of Autonomous Driving 自动驾驶技术历史Autonomous Driving Projects 自动驾驶项目 Many governmental institutions worldwide started various projects to explore intelligent transportation systems (ITS). The PROMETHEUS project started 1986 in Europe and involved more than 13 vehicle manufacturers, several research units from governments and universities of 19 European countries. |One of the first projects in the United States was Navlab Thorpe et al. (1988) by the Carnegie Mellon University which achieved a major milestone in 1995, by completing the first autonomous drive from Pittsburgh, PA and Sand Diego, CA. |After many initiatives were launched by universities, research centers and automobile companies, the U.S. government established the National Automated Highway System Consortium (NAHSC) in 1995. |Similar to the U.S., Japan established the Advanced Cruise-Assist Highway System Research Association in 1996 among many automobile industries and research centers to foster research on automatic vehicle guidance. |Bertozzi et al. (2000) survey many approaches to the challenging task of autonomous road following developed during these projects. They concluded that suffcient computing power is become increasingly available, but diffculties like reflections, wet road, direct sunshine, tunnels and shadows still make data interpretation challenging. |Thus, they suggested the enhancement of sensor capabilities. They also pointed out that the legal aspects related to the responsibility and impact of automatic driving on human passengers need to be considered carefully. |In summary, the automation will likely be restricted to special infrastructures and will be extended gradually. 世界各地的许多政府机构启动各式各样的项目来开发智能交通系统（ITS）。PROMETHEUS这个项目1986年在欧洲启动，包括超过13个交通工具生产商，当中的许多研究成员来自19个欧洲国家的政府和高校。美国的其中一个项目就是由卡耐基梅隆大学的Navlab Thorpe等人(1988)创建的。这个项目完成了第一次从Pittsburgh，PA,Sand Diego和CA的自动驾驶，在1995年是一个重要的里程碑。在许多大学，研究中心和自动驾驶公司的倡议下，美国政府在1995年成立了自动化公路系统联盟（NAHSC）。和美国一样，日本于1996年成立了高级巡航公路系统研究协会(Advanced Cruise-Assist Highway System Research Association)，包括各大自动驾驶公司和研究中心，来促进自动驾驶导航的研究。Bertozzi等人（2000）调查了许多具有挑战性的任务(通过这些项目发展的自动道路跟随),给出解决方法。他们得出结论，计算能力逐渐得到满足，但像反射，湿面潮湿，阳光直射，隧道和阴影这样的困难仍然使数据解释具有挑战性。因此，他们建议提高传感器性能，同时也指出，关系到自动驾驶对行人法律方面的责任和影响，应该认真的考虑总之，自动化技术(发展)可能会受限于特殊的基础设施，然后再慢慢的普及开来。 Motivated by the success of the PROMETHEUS projects to drive autonomously on highways, Franke et al. (1998) describe a real-time vision system for autonomous driving in complex urban traffic situations. |While highway scenarios have been studied intensively, urban scenes have not been addressed before. Their system included depth-based obstacle detection and tracking from stereo as well as a framework for monocular detection and recognition of relevant objects such as traffic signs. The fusion of several perception systems developed by Vis-Lab have led to several proto-type vehicles including ARGO Broggi et al. (1999), TerraMax Braid et al. (2006), and BRAiVE Grisleri &amp; Fedriga (2010). |BRAiVE is the latest vehicle proto-type which is now integrating all systems that VisLab has developed so far. Bertozzi et al. (2011) demonstrated the robustness of their system at the VisLab Intercontinental Autonomous Challenge, a semi-autonomous drive from Italy to China. |The onboard system allows to detect obstacles, lane marking, ditches,berms and identify the presence and position of a preceding vehicle. The information produced by the sensing suite is used to perform different tasks such as leader-following and stop &amp; go. PROMETHEUS项目可以实现在高速公路上自动驾驶，在这个成功的案例推动下，Franke等人描述了在复杂的城市交通场景下的自动驾驶的实时视觉系统。虽然在此之前公路场景情况已经有很多深入的研究，但城市场景却从未得到解决。他们的系统包括基于深度的障碍检测和立体追踪，以及针对相关物体（比如：交通信号）的单目检测和识别框架。 Vis-Lab发展的多种传感系统的融合促成了几款原型车包括ARGO Broggi（1999），TerraMax Braid（2006）和BRAiVE Grisleri &amp; Fedriga（2010）的出现BRAiVE是目前VisLab开发的整合所有系统的最新车型。 Bertozzi等人（2011）在VisLab洲际自治挑战赛（VisLab Intercontinental Autonomous Challenge，意大利到中国的半自主驾驶）展示了其系统的稳健性（鲁棒性）。车载系统允许检测障碍物，标记车道、沟渠、护堤，并识别前方是否存在车辆和车辆位置。感应套件提供的信息被用于执行不同的任务，如(leader-following)和前进/停止。? The PROUD project Broggi et al. (2015) slightly modified the BRAiVE prototype Grisleri &amp; Fedriga (2010) to drive in urban roads and freeways open to regular traffic in Parma. |Towards this goal they enrich an openly licensed map with information about the maneuver to be managed (e.g. pedestrian crossing, traffic light, . . . ). |The vehicle was able to handle complex situations such as roundabouts, intersections, priority roads, stops, tunnels, crosswalks, traffic lights, highways, and urban roads without any human intervention. The V-Charge project Furgale et al. (2013) presents an electric automated car outfitted with close-to-market sensors. A fully operational system is proposed including vision-only localization, mapping, navigation and control. |The project supported many works on different problems such as calibration Heng et al. (2013, 2015), stereo H¨ane et al. (2014), reconstruction Haene et al. (2012, 2013, 2014), SLAM Grimmett et al.(2015) and free space detection H¨ane et al. (2015). In addition to these research objectives, the project keeps a strong focus on deploying and evaluating the system in realistic environments. PROUD的项目Broggi（2015）略微修改了BRAiVE原型Grisleri &amp; Fedriga（2010）使得汽车可以在parma城市道路和高速公路的常规交通情况下开车。为了实现这一目标，他们丰富了一份公开授权的地图，其中包含有待完成的机动信息（比如行人过路，交通信号灯等）。该车辆能够在没有人为干涉的情况下处理复杂的场景，例如回旋处，交叉口，优先道路，站点，隧道，人行横道，交通信号灯，高速公路和城市道路。 V-Charge项目Furgale等人 （2013年）提供配备了近距离市场（close-to-market）传感器的电动自动车。提出了一个全面可使用的系统，包括视觉定位，映射，导航和控制。该项目解决了诸多困难比如，Heng et al. (2013, 2015)的校准问题, H¨ane(2014)的立体问题,Haene(2012, 2013, 2014)的重建问题, Grimmett(2015)的SLAM问题和 H¨ane(2015)的空白区域检测的问题。除了这些研究目标，该项目还非常重视在现实环境中部署和系统评估。 Google started their self-driving car project in 2009 and completed over 1,498,000 miles autonomously until March 2016 in Mountain View, CA, Austin, TX and Kirkland, WA. |Different sensors (i.a. cameras, radars, LiDAR, wheel encoder, GPS) allow to detect pedestrians, cyclists, vehicles, road work and more in all directions. |According to their accident reports, Google’s self-driving cars were involved only in 14 collisions while 13 times were caused by others. In 2016, the project was split off to Waymo, an independent self-driving technology company. Tesla Autopilot is an advanced driver assistant system developed by Tesla which was first rolled out(推出) in 2015 with version of their software. The automation level of the system allows full automation but requires the full attention of the driver to take control if necessary. |From October 2016, all vehicles produced by Tesla were equipped with eight cameras, twelve ultrasonic sensors and a forward-facing radar to enable full self-driving capability. Google于2009年开始了自驾车项目，直到2016年3月完成了超过1,498,000英里的驾驶距离，在美国加利福尼亚州奥斯汀市的Mountain View，WA和柯克兰。不同的传感器（例如摄像机，雷达，LiDAR，车轮编码器，GPS）可以全方位的检测行人，骑自行车的人，车辆，道路工作等等。据他们的事故报道，Google的自动驾驶车只涉及14次碰撞，13次是由别人造成的。 在2016年，这个项目分引入到了一家独立的自动驾驶技术公司Waymo。 Tesla Autopilot是由特斯拉开发的高级驾驶员辅助系统，该系统于2015年第一次推出其视觉软件。系统的自动化级别允许完全的自动化，但是仍然需要 要求驾驶员集中注意来控制。从2016年10月起，特斯拉生产的所有车辆配备了8台摄像机，12台超声波传感器和一个前置雷达，以实现全自动驾驶能力。 Long Distance Test Demonstrations: In 1995 the team within the PROMETHEUS project Dickmanns et al. (1990); Franke et al. (1994); Dickmanns et al. (1994) performed the first autonomous long-distance drive from Munich, Germany, to Odense, Denmark, at velocities up to 175 km/h with about 95% autonomous driving. |Similarly, in the U.S. Pomerleau &amp; Jochem (1996) drove from Washington DC to San Diego in the ’No hands across America’ tour with 98% automated steering yet manual longitudinal control. In 2014, Ziegler et al. (2014) demonstrated a 103 km ride from Mannheim to Pforzheim Germany, known as Bertha Benz memorial route, in nearly fully autonomous manner. |They present an autonomous vehicle equipped with close-to-production sensor hardware. Object detection and free-space analysis is performed with radar and stereo vision. Monocular vision is used for traffic light detection and object classification. |Two complementary vision algorithms, point feature based and lane marking based, allow precise localization relative to manually annotated digital road maps. They concluded that even thought the drive was successfully completed the overall behavior is far inferior to the performance level of an attentive human driver. 长距离测试演示：1995年，PROMETHEUS项目里Dickmanns（1990）、Franke（1994）、Dickmanns（1994年）的团队演示了从德国慕尼黑（Munich）到丹麦欧登塞（Odense）进行的第一次自动长途驾驶，速度达175公里/小时，其中约95％为自主驾驶。同样，在美国Pomerleau和Jochem（1996）在‘No hands across from America ???’中从华盛顿特区开往圣地亚哥，整个行程中有98％的自动驾驶和偶尔的手动纵向控制。 2014年，Zieglar（2014）以近乎完全自动的方式，展示了从曼海姆（Mannheim）到德国普福尔茨海姆（Pforzheim Germany）的103km的骑行，也就是众人所熟知的Bertha Benz纪念路线。他们展示了一种装配有接近生产(close-to-production)的传感器硬件的自动驾驶车辆。由雷达radar和立体视觉来进行物体检测和空白区域分析。单目视觉用来检测交通信号灯和目标分类。两种互补的算法，基于点特征和基于场景标记，允许相对于手动注释的数字路线图进行精确定位。他们得出结论，甚至认为自动驾驶虽然成功完成了，但是整体行为远远达不到细心的驾驶司机的水平。 Recently, Bojarski et al. (2016) drove autonomously 98% of the time from Holmdel to Atlantic Highlands in Monmouth County NJ as well as 10 miles on the Garden State Parkway without intervention. |Towards this goal, a convolutional neural network which predicts vehicle control directly from images is used in the NVIDIA DRIVETM PX self-driving car. The system is discussed in greater detail in Section 11. While all aforementioned performed impressively, the general assumption of precisely annotated road maps as well as prerecorded maps for localization demonstrates that autonomous systems are still far from human capabilities. |Most importantly, robust perception from visual information but also general artificial intelligence are required to reach human level reliability and react safely even in complex innercity situations. 最近，Bojarski（2016）从霍尔姆德尔（Holmdel）到新泽西州蒙茅斯县（Monmouth）的大西洋高原，以及在花园州立大道没有任何干扰的自动行驶了10英里，其中98%是在自动驾驶。为了实现这一目标，在NVIDIA DRIVETM PX自动驾驶车中使用了一种从图像直接预测车辆控制的卷积神经网络。该系统在第11节中有更详细的讨论。 虽然所有上述表现令人印象深刻，但精确注释路线图的一般假设，以及用于定位的预先载入的地图证实了自主性系统仍然差强人意。最重要的是，这不仅需要视觉信息的强大的感知，也需要一般的人工智能达到和人一样的可靠性，并且在复杂的城市情况下也能安全地做出反应。 Autonomous Driving Competitions 自动驾驶竞赛 The European Land Robot Trial (ELROB) is a demonstration and competition of unmanned systems in realistic scenarios and terrains, focusing mainly on military aspects such as reconnaissance and surveillance, autonomous navigation and convoy transport. In contrast to autonomous driving challenges, ELROB scenarios typically include navigation in rough terrain. The first autonomous driving competition focusing on road scenes (though primarily dirt roads) has been initiated by the American Defense Advanced Research Projects Agency (DARPA) in 2004. The DARPA Grand Challenge 2004 offered a prize money of 1 million for the team first finishing a 150 mile route which crossed the border from California to Nevada. |However, none of the robot vehicles completed the route. One year later, in 2005, DARPA announced a second edition of its challenge with 5 vehicles successfully completing the route (Buehler et al.(2007)). The third competition of the DARPA Grand Challenge, known as the Urban Challenge (Buehler et al. (2009)), took place on November 3, 2007 at the site of the George Air Force Base in California. The challenge involved a 96 km urban area course where traffic regulations had to be obeyed while negotiating with other vehicles and merging into traffic. The Grand Cooperative Driving Challenge (GCDC, see also Geiger et al. (2012a)), a competition focusing on autonomous cooperative driving behavior was held in Helmond, Netherlands in 2011 for the first time and in 2016 for a second edition. During the competition, teams had to negotiate convoys, join convoys and lead convoys. The winner was selected based on a system that assigned points to randomly mixed teams. European Land Robot Trial （ELROB）是现实场景和地形中无人系统的示范与竞赛，主要集中在军事方面，如侦察监视，自动导航和车队运输。与自主驾驶挑战相反，ELROB场景通常包括崎岖地形的导航。 2004年，美国国防高级研究计划署（DARPA）发起了第一个专注于道路场景（主要是泥土路）的自动驾驶比赛。挑战赛提供了100万美元的奖金给首先完成从加利福尼亚州内华达州过境的150英里的路线。然而，机器人车辆都没有完成路线。 一年后，DARPA公布了第二版的挑战，5辆车顺利完成了路线（Buehler（2007））。DARPA大挑战赛的第三场比赛，被称为城市挑战赛（Buehler（2009）），于2007年11月3日在乔治航空加利福尼亚州的基地。这个挑战涉及到一个96公里的城市地区航线，在这段路程中车辆在对其他车辆进行判断并汇合车流时，必须遵守交通法规。 专注于自动合作驾驶行为的大型合作驾驶挑战（GCDC，Geiger et al（2012a））在荷兰赫尔蒙德（Helmond）举行,2011年首次，2016年第二次。在比赛中，团队需要判断，加入和引导车队。获胜者是基于给随机混合团队分配点数的系统选出来的。]]></content>
      <categories>
        <category>paper</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP & MySQL learning notes (4)]]></title>
    <url>%2F2019%2F03%2F03%2Fphp-notes3%2F</url>
    <content type="text"><![CDATA[由于PHP和MySQL版本问题，对 PHP &amp; MySQL learning notes (1) 中曾经写过用的PHP操作MySQL数据库进行笔记更新完善 PHP &amp; MySQL learning notes (3) 中的代码重新用 MySQLi (面向对象) MySQLi (面向过程) PDO 三种方式演示PHP操作MySQL 可以通过 phpinfo() 查看 mysqli 和 PDO 是否可以使用 连接MySQL创建连接面向对象 &lt;?php$servername = "localhost";$username = "username";$password = "password";// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123; die("连接失败: " . $conn-&gt;connect_error);&#125;echo "连接成功";?&gt; 面向过程 &lt;?php$servername = "localhost";$username = "username";$password = "password";// 创建连接$conn = mysqli_connect($servername, $username, $password);// 检测连接if (!$conn) &#123; die("Connection failed: " . mysqli_connect_error());&#125;echo "连接成功";?&gt; PDO &lt;?php$servername = "localhost";$username = "username";$password = "password";try &#123; $conn = new PDO("mysql:host=$servername;", $username, $password); echo "连接成功";&#125;catch(PDOException $e)&#123; echo $e-&gt;getMessage();&#125;?&gt; 关闭链接$conn-&gt;close(); //面向对象mysqli_close($conn); //面向过程$conn = null; //实例PDO 创建数据库面向对象 &lt;?php$servername = "localhost";$username = "username";$password = "password";// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) &#123; die("连接失败: " . $conn-&gt;connect_error);&#125;// 创建数据库$sql = "CREATE DATABASE myDatabase";if ($conn-&gt;query($sql) === TRUE) &#123; echo "数据库创建成功";&#125; else &#123; echo "Error creating database: " . $conn-&gt;error;&#125;$conn-&gt;close();?&gt; 面向过程 &lt;?php$servername = "localhost";$username = "username";$password = "password";// 创建连接$conn = mysqli_connect($servername, $username, $password);// 检测连接if (!$conn) &#123; die("连接失败: " . mysqli_connect_error());&#125;// 创建数据库$sql = "CREATE DATABASE myDatabase";if (mysqli_query($conn, $sql)) &#123; echo "数据库创建成功";&#125; else &#123; echo "Error creating database: " . mysqli_error($conn);&#125;mysqli_close($conn);?&gt; PDO &lt;?php$servername = "localhost";$username = "username";$password = "password";try &#123; $conn = new PDO("mysql:host=$servername", $username, $password); // 设置 PDO 错误模式为异常 $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $sql = "CREATE DATABASE myDatabasePDO"; // 使用 exec() ，因为没有结果返回 $conn-&gt;exec($sql); echo "数据库创建成功&lt;br&gt;";&#125;catch(PDOException $e)&#123; echo $sql . "&lt;br&gt;" . $e-&gt;getMessage();&#125;$conn = null;?&gt; 创建数据表 CREATE创建Mytest表 CREATE TABLE Mytest ( id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL, lastname VARCHAR(30) NOT NULL, email VARCHAR(50), reg_date TIMESTAMP) 面向对象 &lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDatabase";// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123; die("连接失败: " . $conn-&gt;connect_error);&#125;// 使用 sql 创建数据表$sql = "CREATE TABLE Mytest (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)";if ($conn-&gt;query($sql) === TRUE) &#123; echo "Table Mytest created successfully";&#125; else &#123; echo "创建数据表错误: " . $conn-&gt;error;&#125;$conn-&gt;close();?&gt; 面向过程 &lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDatabase";// 创建连接$conn = mysqli_connect($servername, $username, $password, $dbname);// 检测连接if (!$conn) &#123; die("连接失败: " . mysqli_connect_error());&#125;// 使用 sql 创建数据表$sql = "CREATE TABLE Mytest (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)";if (mysqli_query($conn, $sql)) &#123; echo "数据表 Mytest 创建成功";&#125; else &#123; echo "创建数据表错误: " . mysqli_error($conn);&#125;mysqli_close($conn);?&gt; PDO &lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDatabasePDO";try &#123; $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password); // 设置 PDO 错误模式，用于抛出异常 $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // 使用 sql 创建数据表 $sql = "CREATE TABLE MyTest ( id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL, lastname VARCHAR(30) NOT NULL, email VARCHAR(50), reg_date TIMESTAMP )"; // 使用 exec() ，没有结果返回 $conn-&gt;exec($sql); echo "数据表 MyTest 创建成功";&#125;catch(PDOException $e)&#123; echo $sql . "&lt;br&gt;" . $e-&gt;getMessage();&#125;$conn = null;?&gt; 插入数据 INSERT使用INSERT进行插入操作 INSERT INTO table_name (column1, column2, column3,...)VALUES (value1, value2, value3,...) 插入单条数据面向对象 &lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDatabase";// 创建连接$conn = new mysqli($servername, $username, $password, $dbname);// 检测连接if ($conn-&gt;connect_error) &#123; die("连接失败: " . $conn-&gt;connect_error);&#125;$sql = "INSERT INTO MyTest (firstname, lastname, email)VALUES ('John', 'Doe', 'john@example.com')";if ($conn-&gt;query($sql) === TRUE) &#123; echo "新记录插入成功";&#125; else &#123; echo "Error: " . $sql . "&lt;br&gt;" . $conn-&gt;error;&#125;$conn-&gt;close();?&gt; 面向过程 &lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDatabase";// 创建连接$conn = mysqli_connect($servername, $username, $password, $dbname);// 检测连接if (!$conn) &#123; die("Connection failed: " . mysqli_connect_error());&#125;$sql = "INSERT INTO MyTest (firstname, lastname, email)VALUES ('John', 'Doe', 'john@example.com')";if (mysqli_query($conn, $sql)) &#123; echo "新记录插入成功";&#125; else &#123; echo "Error: " . $sql . "&lt;br&gt;" . mysqli_error($conn);&#125;mysqli_close($conn);?&gt; PDO &lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDatabasePDO";try &#123; $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password); // 设置 PDO 错误模式，用于抛出异常 $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $sql = "INSERT INTO MyTest (firstname, lastname, email) VALUES ('John', 'Doe', 'john@example.com')"; // 使用 exec() ，没有结果返回 $conn-&gt;exec($sql); /* $conn-&gt;exec("INSERT INTO MyTest (firstname, lastname, email) VALUES ('John', 'Doe', 'john@example.com')") */ echo "新记录插入成功";&#125;catch(PDOException $e)&#123; echo $sql . "&lt;br&gt;" . $e-&gt;getMessage();&#125;$conn = null;?&gt; 插入多条数据mysqli_multi_query() 函数可用来执行多条SQL语句 $sql = "INSERT INTO MyTest (firstname, lastname, email)VALUES ('John', 'Doe', 'john@example.com');";$sql .= "INSERT INTO MyTest (firstname, lastname, email)VALUES ('Mary', 'Moe', 'mary@example.com');";$sql .= "INSERT INTO MyTest (firstname, lastname, email)VALUES ('Julie', 'Dooley', 'julie@example.com')";$conn-&gt;multi_query($sql) === TRUE // 面向对象mysqli_multi_query($conn, $sql) //面向过程 PDO需要使用事务函数执行多条并提交，执行失败后要使用回滚 &lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDatabasePDO";try &#123; $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password); // set the PDO error mode to exception $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // 开始事务 $conn-&gt;beginTransaction(); // SQL 语句 $conn-&gt;exec("INSERT INTO MyTest (firstname, lastname, email) VALUES ('John', 'Doe', 'john@example.com')"); $conn-&gt;exec("INSERT INTO MyTest (firstname, lastname, email) VALUES ('Mary', 'Moe', 'mary@example.com')"); $conn-&gt;exec("INSERT INTO MyTest (firstname, lastname, email) VALUES ('Julie', 'Dooley', 'julie@example.com')"); // 提交事务 $conn-&gt;commit(); echo "新记录插入成功";&#125;catch(PDOException $e)&#123; // 如果执行失败回滚 $conn-&gt;rollback(); echo $sql . "&lt;br&gt;" . $e-&gt;getMessage();&#125;$conn = null;?&gt; 使用预处理语句优化用于执行多个相同的 SQL 语句，也可以防止 MySQL 注入 主要优势 预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行） 绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句 预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性 流程 预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 ? 标记，可以将其替换为整型，字符串，双精度浮点型和布尔值INSERT INTO MyTest (firstname, lastname, email) VALUES(?, ?, ?) 绑定 SQL 参数并告知相关的值$stmt-&gt;bind_param(&quot;sss&quot;, $firstname, $lastname, $email); “sss” 参数列处理参数的数据类型，参数有以下四种类型:i - integer（整型）d - double（双精度浮点型）s - string（字符串）b - BLOB（binary large object:二进制大对象） 通过告诉数据库参数的数据类型，可以降低 SQL 注入的风险 数据库解析，编译，对SQL语句模板执行查询优化，并存储结果不输出 执行：最后，将应用绑定的值传递给参数（? 标记），数据库执行语句 使用预处理语句插入多条数据 // 检测数据库链接状态 同上// 预处理及绑定$stmt = $conn-&gt;prepare("INSERT INTO MyTest (firstname, lastname, email) VALUES (?, ?, ?)");$stmt-&gt;bind_param("sss", $firstname, $lastname, $email);// 设置参数并执行$firstname = "John";$lastname = "Doe";$email = "john@example.com";$stmt-&gt;execute();$firstname = "Mary";$lastname = "Moe";$email = "mary@example.com";$stmt-&gt;execute();$firstname = "Julie";$lastname = "Dooley";$email = "julie@example.com";$stmt-&gt;execute();echo "新记录插入成功";$stmt-&gt;close();$conn-&gt;close(); PDO &lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDatabasePDO";try &#123; $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password); // 设置 PDO 错误模式为异常 $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // 预处理 SQL 并绑定参数 $stmt = $conn-&gt;prepare("INSERT INTO MyTest (firstname, lastname, email) VALUES (:firstname, :lastname, :email)"); $stmt-&gt;bindParam(':firstname', $firstname); $stmt-&gt;bindParam(':lastname', $lastname); $stmt-&gt;bindParam(':email', $email); // 插入行 $firstname = "John"; $lastname = "Doe"; $email = "john@example.com"; $stmt-&gt;execute(); // 插入其他行 $firstname = "Mary"; $lastname = "Moe"; $email = "mary@example.com"; $stmt-&gt;execute(); // 插入其他行 $firstname = "Julie"; $lastname = "Dooley"; $email = "julie@example.com"; $stmt-&gt;execute(); echo "新记录插入成功";&#125;catch(PDOException $e)&#123; echo "Error: " . $e-&gt;getMessage();&#125;$conn = null;?&gt; 查询数据 SELECT简单查询SELECT 语句用于从数据表中读取数据:SELECT column_name(s) FROM table_name 面向对象 设置 SQL 语句从 MyTest数据表中读取 id, firstname 和 lastname 三个字段。 使用 SQL 语句从数据库中取出结果集并赋给复制给变量 $result。 函数 num_rows() 判断返回的数据。 函数 fetch_assoc() 将结合集放入到关联数组并循环输出 &lt;?php// 创建和检测连接// 建立索引$sql = "SELECT id, firstname, lastname FROM MyTest";$result = $conn-&gt;query($sql);if ($result-&gt;num_rows &gt; 0) &#123; // 输出数据 while($row = $result-&gt;fetch_assoc()) &#123; echo "id: " . $row["id"]. " - Name: " . $row["firstname"]. " " . $row["lastname"]. "&lt;br&gt;"; &#125;&#125; else &#123; echo "0 结果";&#125;$conn-&gt;close();?&gt; 面向过程 &lt;?php// 创建并检测连接$sql = "SELECT id, firstname, lastname FROM MyTest";$result = mysqli_query($conn, $sql);if (mysqli_num_rows($result) &gt; 0) &#123; // 输出数据 while($row = mysqli_fetch_assoc($result)) &#123; echo "id: " . $row["id"]. " - Name: " . $row["firstname"]. " " . $row["lastname"]. "&lt;br&gt;"; &#125;&#125; else &#123; echo "0 结果";&#125;mysqli_close($conn);?&gt; PDO &lt;?php$servername = "localhost";$username = "username";$password = "password";$dbname = "myDatabasePDO";try &#123; $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password); $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $stmt = $conn-&gt;prepare("SELECT id, firstname, lastname FROM MyTest "); $stmt-&gt;execute(); // 设置结果集为关联数组 $result = $stmt-&gt;setFetchMode(PDO::FETCH_ASSOC); foreach(new TableRows(new RecursiveArrayIterator($stmt-&gt;fetchAll())) as $k=&gt;$v) &#123; echo $v; &#125;&#125;catch(PDOException $e) &#123; echo "Error: " . $e-&gt;getMessage();&#125;$conn = null;echo "&lt;/table&gt;";?&gt; 使用 WHERE 子句, ORDER BY 子句进行查询时，必须使用 mysqli::query 或 mysqli_query() ，用于向 MySQL 连接发送查询或命令 修改数据 UPDATEUPDATE table_nameSET column1=value, column2=value2,...WHERE some_column=some_value 必须使用 mysqli::query 或 mysqli_query() &lt;?php$con=mysqli_connect("localhost","username","password","database");// 检测连接if (mysqli_connect_errno())&#123; echo "连接失败: " . mysqli_connect_error();&#125;mysqli_query($con,"UPDATE Persons SET Age=36WHERE FirstName='Peter' AND LastName='Griffin'");mysqli_close($con);?&gt; 删除数据 DELETEDELETE FROM table_nameWHERE some_column = some_value &lt;?php$con=mysqli_connect("localhost","username","password","database");// 检测连接if (mysqli_connect_errno())&#123; echo "连接失败: " . mysqli_connect_error();&#125;mysqli_query($con,"DELETE FROM Persons WHERE LastName='Griffin'");mysqli_close($con);?&gt; 使用的类和函数汇总mysqli PHP和Mysql数据库之间的一个连接mysqli::init — 初始化 MySQLi 并返回一个资源类型的值，这个值可以作为 mysqli_real_connect() 函数的传入参数mysqli::$info — 返回最近执行的 SQL 语句的信息mysqli::stat — 获取当前系统状态信息mysqli::$connect_error/mysqli_connect_error() — 返回最后连接错误描述mysqli::$error/mysqli_error() — 返回最后的错误描述mysqli::__construct/mysqli_connect() — 开始一个新的MySQL服务连接mysqli::real_connect — 建立一个 MySQL 服务器连接mysqli::select_db — 选择用于数据库查询的默认数据库mysqli::query — 对数据库执行一次查询mysqli::real_query — 执行一个mysql查询mysqli::send_query — 发送请求并返回结果mysqli::multi_query — 执行查询mysqli::real_escape_string — 根据当前连接的字符集，对于 SQL 语句中的特殊字符进行转义mysqli::prepare — 准备执行一个 SQL 语句mysqli::stmt_init — 初始化一条语句并返回一个用于mysqli_stmt_prepare(调用)的对象mysqli::rollback — 回退当前事务mysqli::close/mysqli_close() — 关闭先前打开的数据库连接 mysqli::autocommit — 打开或关闭本次数据库连接的自动命令提交事务模式mysqli::change_user — 改变指定数据库连接的用户mysqli::character_set_name — 返回当前数据库连接的默认字符编码mysqli::commit — 提交一个事务mysqli::$connect_errno — 返回最后连接错误代码mysqli::errno — 返回最近函数调用的错误代码mysqli::$error_list — 返回最后命令行执行错误列表mysqli::$field_count — Returns the number of columns for the most recent querymysqli::get_charset — Returns a character set objectmysqli::$client_info — 获取 MySQL 客户端信息mysqli_get_client_version — 作为一个整数返回MySQL客户端的版本mysqli::get_connection_stats — 返回客户端连接的统计数据mysqli::$host_info — 返回一个表述使用的连接类型的字符串mysqli::$protocol_version — 返回MySQL使用的协议版本号mysqli::$server_info — 返回MySQL服务器的版本号mysqli::$server_version — 作为一个整数返回MySQL服务器的版本mysqli::get_warnings — Get result of SHOW WARNINGSmysqli::$insert_id — 返回最后一条插入语句产生的自增 IDmysqli::kill — 让服务器杀掉一个 MySQL 线程mysqli::more_results — 检查批量查询中是否还有查询结果mysqli::next_result — 为读取 multi_query 执行之后的下一个结果集做准备mysqli::options — 设置选项mysqli::ping — ping 一个连接，或者如果连接处于断开状态，重新连接mysqli::poll — 轮询连接mysqli::reap_async_query — 获取异步查询的结果mysqli::refresh — 刷新mysqli::release_savepoint — 从当前事务的保存点中移除一个命名保存点mysqli::rpl_query_type — 返回 RPL 查询类型mysqli::savepoint — 在当前事务中增加一个命名保存点mysqli::set_charset — 设置默认字符编码mysqli::set_local_infile_default — 取消用户指定的回调函数mysqli::set_local_infile_handler — 设置 LOAD DATA LOCAL INFILE 命令的回调函数mysqli::$sqlstate — 返回上一次 SQL 操作的 SQLSTATE 错误信息mysqli::store_result — 转移上一次查询返回的结果集mysqli::$thread_id — 返回当前连接的线程 IDmysqli::thread_safe — 返回是否是线程安全的 mysqli_stmt 预编译 SQL 语句mysqlistmt :: prepare - 准备一条SQL语句以便执行mysqlistmt :: bind_param - 将变量作为参数绑定到预准备语句mysqli_stmt :: construct - 构造一个新的mysqli_stmt对象mysqli_stmt :: $ num_rows/mysqli_num_rows() - 返回语句结果集中的行数mysqli_stmt :: $ param_count - 返回给定语句的参数个数mysqli_stmt :: $ errno - 返回最近语句调用的错误代码mysqli_stmt :: $ error_list - 返回上一个执行语句的错误列表mysqli_stmt :: $ error - 返回上一个语句错误的字符串描述mysqli_stmt :: execute - 执行准备好的Querymysqli_stmt :: fetch - 将预准备语句的结果提取到绑定变量中mysqli_stmt :: close - 关闭准备好的语句 mysqli_stmt :: $ affected_rows - 返回上次执行的语句更改，删除或插入的总行数mysqli_stmt :: attr_get - 用于获取语句属性的当前值mysqli_stmt :: attr_set - 用于修改预准备语句的行为mysqli_stmt :: bind_result - 将变量绑定到结果存储的预准备语句mysqli_stmt :: data_seek - 寻找语句结果集中的任意行mysqli_stmt :: fetch - 将预准备语句的结果提取到绑定变量中mysqli_stmt :: $ field_count - 返回给定语句中的字段数mysqli_stmt :: free_result - 释放给定语句句柄的存储结果内存mysqli_stmt :: get_result - 从预准备语句中获取结果集mysqli_stmt :: get_warnings - 获取SHOW WARNINGS的结果mysqli_stmt :: $ insert_id - 获取先前INSERT操作生成的IDmysqli_stmt :: more_results - 检查多个查询是否有更多查询结果mysqli_stmt :: next_result - 从多个查询中读取下一个结果mysqli_stmt :: reset - 重置预准备语句mysqli_stmt :: result_metadata - 从预准备语句返回结果集元数据mysqli_stmt :: send_long_data - 以块为单位发送数据mysqli_stmt :: $ sqlstate - 从前一个语句操作返回SQLSTATE错误mysqli_stmt :: store_result - 从预准备语句中传输结果集 mysqli_result 从一个数据库查询中获取的结果集mysqli_result :: fetch_all - 将所有结果行提取为关联数组，数字数组或两者mysqli_result :: fetch_array - 将结果行提取为关联行，数字数组或两者mysqli_result :: fetch_assoc/mysqli_fetch_assoc() - 将结果行作为关联数组获取mysqli_result :: $ lengths - 返回结果集中当前行的列长度mysqli_result :: $ num_rows - 获取结果中的行数 mysqli_result :: $ current_field - 获取结果指针的当前字段偏移量mysqli_result :: data_seek - 将结果指针调整为结果中的任意行mysqli_result :: fetch_field_direct - 获取单个字段的元数据mysqli_result :: fetch_field - 返回结果集中的下一个字段mysqli_result :: fetch_fields - 返回表示结果集中字段的对象数组mysqli_result :: fetch_object - 将结果集的当前行作为对象返回mysqli_result :: fetch_row - 将结果行作为枚举数组mysqli_result :: $ field_count - 获取结果中的字段数mysqli_result :: field_seek - 将结果指针设置为指定的字段偏移量mysqli_result :: free - 释放与结果相关的内存 相关链接：mysql 学习笔记PHP &amp; MySQL learning notes (3)PHP &amp; MySQL learning notes (1)]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看论文了嘛]]></title>
    <url>%2F2019%2F03%2F01%2Fpaper%2F</url>
    <content type="text"><![CDATA[paper page test.]]></content>
      <categories>
        <category>paper</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[好耶 是python -- 那些神奇的py代码]]></title>
    <url>%2F2019%2F03%2F01%2Fnice-python%2F</url>
    <content type="text"><![CDATA[nice python page test.]]></content>
      <categories>
        <category>github-repo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[这周上Github了吗 -- 那些有意思的项目收集]]></title>
    <url>%2F2019%2F03%2F01%2Fgithub-repo%2F</url>
    <content type="text"><![CDATA[gtihub repository page test.]]></content>
      <categories>
        <category>github-repo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hunger Game （饥饿游戏 原版）单词笔记]]></title>
    <url>%2F2019%2F03%2F01%2Fhunger-game%2F</url>
    <content type="text"><![CDATA[Chapter 15abrupt美[əˈbrʌpt] 英[əˈbrʌpt]adj. 突然的，意外的;无理的，唐突的;不连贯的;陡峭的; anticipate美[ænˈtɪsəˌpet] 英[ænˈtɪsɪpeɪt]vt. 预感;预见;预料;先于…行动;vi. 过早地提出;过早地考虑（或说、做）一件事;（在口头或用文字）预言;预测; crawl美[krɔl] 英[krɔ:l]vi. 爬行;缓慢行进;巴结;n. 缓慢的爬行;〈美俚〉跳舞，自由式游泳;养鱼（龟）池; dab美[dæb] 英[dæb]n. 少许;是…能手;做某事很在行;在某方面技术熟练;vt. （用某物）轻触;轻而快地擦掉（或抹掉）;快速擦拭;（用某物）轻而快地涂上（或点上）…; damp美[dæmp] 英[dæmp]adj. 微湿的，潮湿的;消沉的，沮丧的;沉闷的;情绪低落的;n. 潮湿;消沉，失望;矿井瓦斯;有毒气体;vt. 使潮湿;使泄气，使沮丧;抑制，阻抑;使减弱;vi. [物]阻尼;减幅; desperate美[ˈdɛspərɪt] 英[ˈdespərət]adj. 绝望的;由绝望而引起的;铤而走险的，孤注一掷的;急切的，极度渴望的; dew美[du] 英[dju:]n. 水珠，露水;vt. 弄湿; dread美[drɛd] 英[dred]vt. 害怕，担心;（古语）敬畏;n. 恐惧，畏惧;令人恐惧的事物;adj. 可怕的;vi. 十分害怕; feeble美[ˈfibəl] 英[ˈfi:bl]adj. 虚弱的，衰弱的;无效的，无意的;缺乏决心的，缺乏活力的; fetal美[ˈfitl] 英[‘fi:tl]adj. 胎儿的，胎的; filthy美[ˈfɪlθi] 英[ˈfɪlθi]adj. 肮脏的，污秽的;猥亵的，淫秽的;下流的; foliage美[ˈfoʊliɪdʒ] 英[ˈfəʊliɪdʒ]n. 植物的叶子（总称），叶子及梗和枝;树叶; grin美[ɡrɪn] 英[grɪn]vi. 露齿而笑;vt. 露齿笑着表示;n. 咧嘴笑，露齿而笑; hallucination美[həˌlusəˈneʃən] 英[həˌlu:sɪˈneɪʃn]n. 幻觉，幻想;错觉; hip美[hɪp] 英[hɪp]n. 臀部;[建筑学]屋脊;臀围（尺寸）;臀部…的;adj. （衣服、音乐等方面）时髦的，赶时髦的;vt. 使…的髋关节脱臼，损伤…的髋部;[建筑学]给（房屋）建屋脊;使知晓，使了解，告诉;使消息灵通; honeysuckle美[ˈhʌniˌsʌkəl] 英[ˈhʌnisʌkl]n. 忍冬，金银花; manifest美[ˈmænəˌfɛst] 英[ˈmænɪfest]vt. 显示，表明;证明;使显现;adj. 明白的，明显的;n. 货单，旅客名单; moss美[mɔs] 英[mɒs]n. 苔藓;藓沼;莫斯（男子名）;泥炭沼;vt. 以苔藓覆盖;使长满苔藓;abbr. 宇载人轨道航天站; nectar美[ˈnɛktɚ] 英[ˈnektə(r)]n. 花蜜;（古希腊、罗马神话中的）众神饮的酒;琼浆玉液;甘美的饮料;adj. &lt;古&gt;充满美酒的，芳香甜蜜的; noxious美[ˈnɑkʃəs] 英[ˈnɒkʃəs]adj. 有害的，有毒的; onslaught美[ˈɑnslɔt] 英[ˈɒnslɔ:t]n. 猛攻，攻击;突击;大量的倾泻; orchard美[ˈɔrtʃərd] 英[ˈɔ:tʃəd]n. （通常指围起来的）果园;果园里的全部果树;&lt;俚&gt;棒球场; pervade美[pərˈveɪd] 英[pəˈveɪd]vt. 遍及，弥漫;渗透，充满; pluck美[plʌk] 英[plʌk]n. 勇气，精神;内脏;快而猛的拉;〈俚〉不及格;vt. 采，摘;拔掉;鼓起（勇气等）;弹（乐器）;vi. 拉，拽; plump美[plʌmp] 英[plʌmp]adj. 丰满的;肥胖的;丰富的;充裕的;adv. 突然地，猛地;vt&amp;vi. （使）圆胖;（使）鼓起;（使）突然沉重地落下;n. 扑通声;〈英〉阵雨;群; prominent美[ˈprɑmɪnənt] 英[ˈprɒmɪnənt]adj. 突出的，杰出的;突起的;著名的; quench美[kwɛntʃ] 英[kwentʃ]vt. 解（渴）;终止（某事物）;（用水）扑灭（火焰等）;将（热物体）放入水中急速冷却; rib美[rɪb] 英[rɪb]n. 肋骨;（船或屋顶等的）肋拱;肋骨状的东西;（织物的）凸条花纹;vt. 嘲笑，逗弄，开（某人的）玩笑;装肋于，给…装肋材; rinse美[rɪns] 英[rɪns]vt. 漂洗;冲洗;漂净;冲掉;n. 冲洗;染发剂;漂洗; rinse out美[rɪns aʊt] 英[rins aut]v. 冲洗掉; rot美[rɑt] 英[rɒt]n. 腐烂，腐朽;vt&amp;vi. （使）腐烂，（使）腐朽; rotten美[ˈrɑtn] 英[ˈrɒtn]adj. 腐烂的;恶臭的;堕落的;极坏的;adv. 非常;极其; slime美[slaɪm] 英[slaɪm]n. 黏质物;黏液;黏泥;软泥;v. （用稀泥等）涂，糊;分泌黏液使黏滑;清除黏液[稀泥等];〈英俚〉滑脱，用狡猾手段脱身溜掉(away through etc.); soot美[sʊt, sut] 英[sʊt]n. 煤烟，烟灰;油烟;v. 煤烟弄脏;弄得尽是煤烟; splash美[splæʃ] 英[splæʃ]vt. 使（液体）溅起;vi. （指液体）溅落;n. （光、色等的）斑点;溅泼声;溅上的斑点;溅泼的量; stiff美[stɪf] 英[stɪf]adj. 严厉的;僵硬的，坚硬的;呆板的，拘谨的;顽固的;adv. &lt;口&gt;极度地，非常;n. 死尸;笨蛋，傻瓜;流动工人;吝啬鬼穷光蛋;vt. 诈骗;失信; stretch美[strɛtʃ] 英[stretʃ]v. 伸展;延伸;持续;包括;n. 伸展;弹性;一片;一段时间;adj. 可伸缩的;弹性的; strip down美[strɪp daʊn] 英[strip daun]脱光衣服; swell美[swɛl] 英[swel]vt&amp;vi. 增强;肿胀;膨胀;充满（激情）;n. 汹涌;重要人士;（尤指身体部位）凸起的形状;声音渐强;adj. 极好的;了不起的;非常棒的; swollen美[ˈswolən] 英[ˈswəʊlən]adj. 膨胀的;肿起的;涨满的;v. 增强，肿胀，鼓起(swell的过去式和过去分词); tangle美[ˈtæŋɡəl] 英[ˈtæŋgl]n. 纠缠，纠纷;混乱，慌乱;昏乱的状态;争论;vt&amp;vi. （使）缠结，（使）乱作一团;使陷入，捕获;使纠纷;参加辩论、争执或冲突; tentative美[ˈtɛntətɪv] 英[ˈtentətɪv]adj. 试探性的;试验的;尝试性的;不确定的;n. 假设;实验;尝试; tread美[trɛd] 英[tred]vi. 踩，踏;行走;交尾;vt. 踩成;踏出;步行于;踩（烂）;n. 踏，踩，走;交尾;（楼梯的）踏板;轮胎接触地面的部分; twig美[twɪɡ] 英[twɪg]n. 细枝，嫩枝;v. 理解，明白; vein美[ven] 英[veɪn]n. 静脉;[地]矿脉，岩脉;[植]叶脉;气质，倾向;v. 使有脉络;使有纹理;象脉络般分布于; venom美[ˈvɛnəm] 英[ˈvenəm]n. （某些蛇、蝎子等分泌的）毒液;恶意;&lt;古&gt;毒物;v. 放毒; wholly美[ˈhoʊlli] 英[ˈhəʊlli]adv. 完全地，全部地;十足，统统;专门;一并;]]></content>
      <categories>
        <category>language-learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[session_cookie]]></title>
    <url>%2F2019%2F02%2F28%2Fsession-cookie%2F</url>
    <content type="text"><![CDATA[Cookie和Session都是会话技术Cookie是运行在客户端，Session是运行在服务器端浅谈一下Session与Cookie之间的区别和联系 SessionSession是服务器端使用的一种记录客户端状态的机制，客户端（浏览器）访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。 步骤 客户端（浏览器）发送请求 服务器端生成Session和一个Session ID来作为这个Session的唯一标识，将Session ID发送到客户端 客户端第二次发送请求，将前一次响应的Session ID一并发送 服务器端从请求中提取出Session ID，和保存的所有Session ID进行对比，找到对应的Session，如果该Session已经被销毁，生成新的Session 服务器端如果保存Session超出时间限制会销毁Session Session的生命周期Session保存在服务器端，为了获得更高的存取速度，服务器一般把Session放在内存里。 如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。 Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。 随着用户访问服务器，Session会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。 Session的用法（不详细展开）void setAttribute(String attribute, Object value)设置Session属性removeAttribute(String attribute)移除Session属性getLastAccessedTime()返回Session的最后活跃时间getMaxInactiveInterval()返回Session的超时时间void invalidate()使该Session失效 CookieCookie技术是客户端的解决方案，由服务器端发给客户端的特殊信息会以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。 步骤 用户使用客户端（浏览器）访问，提供个人信息并且提交至服务器 服务器在向客户端回传的同时发回个人信息，存放于HTTP响应头 当客户端（浏览器）接收到来自服务器的响应之后，浏览器会将这些信息存放在cookie文件夹下，然后再向服务器发送请求，把相应的Cookie再次发回至服务器。信息则存放在HTTP请求头 服务器端在接收到来自客户端浏览器的请求，通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容 Cookie的有效期Cookie的maxAge决定着Cookie的有效期，单位为秒（Second）Cookie会在maxAge秒之后自动失效 Cookie的属性String name：该Cookie的名称Object value：该Cookie的值int maxAge：该Cookie失效的时间，单位秒boolean secure：该Cookie是否仅被使用安全协议传输String domain：可以访问该Cookie的域名String comment：该Cookie的用处说明 difference &amp; connection区别 cookie数据存放在客户的浏览器上，session数据放在服务器上 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE； 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K； 联系 服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>session</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel SQL migration]]></title>
    <url>%2F2019%2F02%2F27%2Fmigration%2F</url>
    <content type="text"><![CDATA[结合Laravel的Schema构建器构建应用的数据库表结构，类似于数据库的版本控制，允许团队成员间编辑并共享应用的数据库表结构Laravel 的 Schema 门面提供了与数据库系统无关的创建和操纵表的支持，在 Laravel 所支持的所有数据库系统中提供一致的、优雅的、流式的 API，将SQL转成PHP去执行 部署环境(WAMP)php 7.3.1composer 1.8.4laravel 5.8.0MySQL 5.7.24 迁移步骤 MySQL数据库创建Database 到laravel目录下修改.env文件符合数据库配置 DB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=your_database_nameDB_USERNAME=rootDB_PASSWORD= 到laravel目录创建新的迁移php artisan make:migration create_table_name创建的数据表在laravel\database\migration目录下 --table和--create选项可以用于指定表名以及该迁移是否要创建一个新的数据表。这些选项只需要简单放在上述迁移命令后面并指定表名php artisan make:migration create_users_table --create=usersphp artisan make:migration add_votes_to_users_table --table=users 编写迁移数据表迁移类包含了两个方法：up和down。up方法用于新增表，列或者索引到数据库，而down方法就是up方法的反操作用到 Laravel 的schema构建器来创建和修改表，后面给出具体实现方法 运行迁移表到数据库php artisan migrate 强制运行这些命令而不被提示，可以使用—force（不推荐）php artisan migrate --force 在MySQL中可以看到Database下有新的表 执行回滚 在Database下有migration表，使得laravel可以回滚 执行文件中的public function down(),回滚最后一批运行的迁移php artisan migrate:rollback回滚所有的应用迁移php artisan migrate:reset先回滚所有数据库迁移php artisan migrate:refresh回滚或重建指定数量的迁移,refresh命令提供的step选项php artisan migrate:refresh --step=5 在迁移之前进行试验php artisan migrate --pretend 创建表使用Schema门面上的create方法来创建新的数据表。create方法接收两个参数，第一个是表名，第二个是获取用于定义新表的Blueprint对象的闭包Schema::create(&#39;table_name&#39;, function (Blueprint $table){ }) 创建表中的列在Schema中创建表中的列结构 $table-&gt;类型(&#39;名称&#39;); 常用属性 $table-&gt;bigIncrements('id'); //自增ID，类型为bigint$table-&gt;bigInteger('votes'); //等同于数据库中的BIGINT类型$table-&gt;binary('data'); //等同于数据库中的BLOB类型$table-&gt;boolean('confirmed'); //等同于数据库中的BOOLEAN类型$table-&gt;char('name', 4); //等同于数据库中的CHAR类型$table-&gt;date('created_at'); //等同于数据库中的DATE类型$table-&gt;dateTime('created_at'); //等同于数据库中的DATETIME类型$table-&gt;dateTimeTz('created_at'); //等同于数据库中的DATETIME类型（带时区）$table-&gt;decimal('amount', 5, 2); //等同于数据库中的DECIMAL类型，带一个精度和范围$table-&gt;double('column', 15, 8); //等同于数据库中的DOUBLE类型，带精度, 总共15位数字，小数点后8位.$table-&gt;enum('choices', ['foo', 'bar']); //等同于数据库中的 ENUM类型$table-&gt;float('amount'); //等同于数据库中的 FLOAT 类型$table-&gt;increments('id'); //数据库主键自增ID$table-&gt;integer('votes'); //等同于数据库中的 INTEGER 类型$table-&gt;ipAddress('visitor'); //等同于数据库中的 IP 地址$table-&gt;json('options'); //等同于数据库中的 JSON 类型$table-&gt;jsonb('options'); //等同于数据库中的 JSONB 类型$table-&gt;longText('description'); //等同于数据库中的 LONGTEXT 类型$table-&gt;macAddress('device'); //等同于数据库中的 MAC 地址$table-&gt;mediumIncrements('id'); //自增ID，类型为无符号的mediumint$table-&gt;mediumInteger('numbers'); //等同于数据库中的 MEDIUMINT类型$table-&gt;mediumText('description'); //等同于数据库中的 MEDIUMTEXT类型$table-&gt;morphs('taggable'); //添加一个 INTEGER类型的 taggable_id 列和一个 STRING类型的 taggable_type列$table-&gt;nullableTimestamps(); //和 timestamps()一样但允许 NULL值.$table-&gt;rememberToken(); //添加一个 remember_token 列： VARCHAR(100) NULL.$table-&gt;smallIncrements('id'); //自增ID，类型为无符号的smallint$table-&gt;smallInteger('votes'); //等同于数据库中的 SMALLINT 类型$table-&gt;softDeletes(); //新增一个 deleted_at 列 用于软删除.$table-&gt;string('email'); //等同于数据库中的 VARCHAR 列 .$table-&gt;string('name', 100); //等同于数据库中的 VARCHAR，带一个长度$table-&gt;text('description'); //等同于数据库中的 TEXT 类型$table-&gt;time('sunrise'); //等同于数据库中的 TIME类型$table-&gt;timeTz('sunrise'); //等同于数据库中的 TIME 类型（带时区）$table-&gt;tinyInteger('numbers'); //等同于数据库中的 TINYINT 类型$table-&gt;timestamp('added_on'); //等同于数据库中的 TIMESTAMP 类型$table-&gt;timestampTz('added_on'); //等同于数据库中的 TIMESTAMP 类型（带时区）$table-&gt;timestamps(); //添加 created_at 和 updated_at列$table-&gt;timestampsTz(); //添加 created_at 和 updated_at列（带时区）$table-&gt;unsignedBigInteger('votes'); //等同于数据库中无符号的 BIGINT 类型$table-&gt;unsignedInteger('votes'); //等同于数据库中无符号的 INT 类型$table-&gt;unsignedMediumInteger('votes'); //等同于数据库中无符号的 MEDIUMINT 类型$table-&gt;unsignedSmallInteger('votes'); //等同于数据库中无符号的 SMALLINT 类型$table-&gt;unsignedTinyInteger('votes'); //等同于数据库中无符号的 TINYINT 类型$table-&gt;uuid('id'); //等同于数据库的UUID 常用约束 -&gt;after('column') //将该列置于另一个列之后 (仅适用于MySQL)-&gt;comment('my comment') //添加注释信息-&gt;default($value) //指定列的默认值-&gt;first() //将该列置为表中第一个列 (仅适用于MySQL)-&gt;nullable() //允许该列的值为NULL-&gt;storedAs($expression) //创建一个存储生成列（只支持MySQL）-&gt;unsigned() //设置 integer 列为 UNSIGNED-&gt;virtualAs($expression) //创建一个虚拟生成列（只支持MySQL） 格式示例 class CreateTableName extends Migration&#123;/** * Run the migrations. * * @return void*/ public function up()&#123; Schema::create('table_name', function (Blueprint $table) &#123; $table-&gt;bigIncrements('id'); $table-&gt;string('name'); $table-&gt;string('email')-&gt;unique(); $table-&gt;timestamp('email_verified_at')-&gt;nullable(); $table-&gt;string('password'); $table-&gt;rememberToken(); $table-&gt;timestamps(); &#125;);&#125;/** * Reverse the migrations. * * @return void*/public function down()&#123; Schema::dropIfExists('table_name');&#125; 修改、重命名、删除列-&gt;change()方法允许你修改已存在的列为新的类型，或者修改列的属性-&gt;renameColumn()方法可以重命名一个列-&gt;dropColumn方法可以删除列 Schema::table('users', function ($table) &#123; $table-&gt;string('name', 50)-&gt;change(); //name列的尺寸从 25 增加到 50 $table-&gt;renameColumn('from', 'to'); //重命名 from 为 to $table-&gt;dropColumn('votes'); //删除一个列 $table-&gt;dropColumn(['votes', 'avatar', 'location']); //删除多个列&#125;); 需要添加doctrine/dbal依赖到composer.json文件 暂不支持enum类型的列的修改和重命名 添加索引键$table-&gt;primary('id'); //添加主键索引$table-&gt;primary(['first', 'last']); //添加混合索引$table-&gt;unique('email'); //添加唯一索引$table-&gt;unique('state', 'my_index_name'); //指定自定义索引名称$table-&gt;index('state'); //添加普通索引 删除索引$table-&gt;dropPrimary(' '); //删除主键索引$table-&gt;dropUnique(' '); //删除唯一索引$table-&gt;dropIndex(' '); //删除普通索引 外键约束（loading…）检查列表是否存在使用 hasTable 和 hasColumn 方法检查表或列是否存在 if (Schema::hasTable('users')) &#123; //&#125;if (Schema::hasColumn('users', 'email')) &#123; //&#125; 设置表的存储引擎，在schema构建器上设置engine属性Schema::create('users', function ($table) &#123; $table-&gt;engine = 'InnoDB'; $table-&gt;increments('id');&#125;); 重命名/删除表在public function up()中添加Schema::rename(&#39;your_table_name&#39;,&#39;change_name&#39;);更新public function down()中的表名 在public function down()中添加Schema::drop(&#39;users&#39;); 或 Schema::dropIfExists(&#39;users&#39;);用于迁移的回滚 参考： Laravel数据库迁移 Database Migration]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql like子句和正则表达式匹配]]></title>
    <url>%2F2019%2F02%2F23%2Fmysql-regular%2F</url>
    <content type="text"><![CDATA[-基础笔记-MySQL like子句和正则表达式的使用MySQL可以通过 LIKE …% 来进行模糊匹配，也可以使用 REGEXP 操作符来进行正则表达式匹配 LIKE当需要获取 WHERE 字段中包含的匹配记录，就需要在 WHERE 子句中使用 LIKE 子句WHERE 子句中可以使用 = 来设定获取数据的条件，LIKE 子句中使用百分号 % 字符来表示任意字符.如果没有使用 %, LIKE子句与 = 的效果是一样的可以使用 AND 或者 OR 指定一个或多个条件,可以在 DELETE 或 UPDATE 命令中使用 WHERE...LIKE 子句来指定条件 SELECT field1, field2,...fieldNFROM table_nameWHERE field1 LIKE `condition` [AND [OR]] filed2 = 'somevalue' 与WHERE条件结合'%a' //以a结尾的数据'a%' //以a开头的数据'%a%' //含有a的数据'_a_' //三位且中间字母是a的'_a' //两位且结尾字母是a的'a_' //两位且开头字母是a的 正则表达式MySQL 正则模式可应用于 REGEXP 操作符中MySQL中正则表达式匹配不区分大小写，如希望区分大小写，可使用binary关键字 模式|描述|—-|—-||^|匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。|$|匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。|.|匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。|[...]|字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。|[^...]|负值字符集合。匹配未包含的任意字符。例如， ‘abc‘ 可以匹配 “plain” 中的’p’。|p1|p2|p3|匹配 p1 或 p2 或 p3。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。|*|匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。|+|匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。|{n}|n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。|{n,m}|m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 示例任意字母数字：[a-zA-Z0-9]任意十六进制：[a-fA-F0-9]任意字符：[a-zA-Z]空格和制表符：[\t]任意空白字符：[\f\n\r\t\v] (换页\换行\回车\制表\纵向制表)x OR y：”x|y”email：”@163[.,]com$”x至少出现一次，最多出现三次：”x{1，3}”]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间序列分析中的资金流入流出问题]]></title>
    <url>%2F2019%2F02%2F20%2Ffund-flow%2F</url>
    <content type="text"><![CDATA[-服务外包项目-资金流入流出问题的研究笔记，数据来自蚂蚁金服大数据赛题笔记持续更新中 研究现状资金流入流出问题 时间序列模型分析：启动时间短，训练数据量不大，成本低自回归算法 AR：呈现过去时刻对预测的直接影响移动平均算法 MA：预测意料之外的事自回归+移动平均 ARMA：综合以上的平衡齐次非平稳 ARIMA：针对非平稳序列 时间序列可较好的预测短期价格变动，时期增长会导致误差率增高 投资分析：长期分析法，利用经济学角度分析内在价值 基本分析：宏观经济分析，行业分析和公司分析应用不够直观，市场反应不够敏锐 技术分析：根据图标信息，技术指标记录推断变化趋势技术指标滞后，无法把控整体趋势 混沌动力学 神经网络利用探索数据间的交叉关系建立模型契合资金波动的高度非线性特点 定性预测：专家意见，德尔菲法 因果预测：回归分析，定性和定量分析 组合算法 统计学+机器学习 灰色系统+神经网络 时间序列+神经网络 集成学习 ensemble learning 串行思路：采用串行的方式生成多个学习器目的在于减少偏差（bias），使用多个弱分类器组合成为一个强分类器，代表算法Bagging，boosting，GBDT 并行思路：通过使用并行的学习，得到多个学习模型然后取其平均结果目的在于减少方差，代表算法 Random Forest 因子分解机 Factorization Machine (loading…)通过特征向量去模拟因子分解模型，利用特征抽取的方法构造出特征并借助因子分解模型对不同变量间的相互作用进行建模 FM算法常用来解决二分类，回归，排序问题 模型构建数据集—&gt;数据预处理—&gt;特征抽取—&gt;预测算法设计—&gt;误差分析—&gt;优化 数据预处理：剔除异常值，表格间数据集成特征抽取：时间特征，用户特征，利率特征预测算法设计(loading…)误差分析：用均方根误差评价 数据预处理余额宝用户数据基本信息数据 user_profile： 列名 类型 含义 示例 user_id bigint 用户 ID 1234 Sex bigint 用户性别（ 1 ：男， 0：女 ） 0 City bigint 所在城市 6081949 constellation string 星座 射手座 申购赎回数据 user_balance： 列名 类型 含义 示例 user_id bigint 用户 id 1234 report_date string 日期 20140407 tBalance bigint 今日余额 109004 yBalance bigint 昨日余额 97389 total_purchase_amt bigint 今日总购买量 = 直接购买 + 收益 21876 direct_purchase_amt bigint 今日直接购买量 21863 purchase_bal_amt bigint 今日支付宝余额购买量 0 purchase_bank_amt bigint 今日银行卡购买量 21863 total_redeem_amt bigint 今日总赎回量 = 消费 + 转出 10261 consume_amt bigint 今日消费总量 0 transfer_amt bigint 今日转出总量 10261 tftobal_amt bigint 今日转出到支付宝余额总量 0 tftocard_amt bigint 今日转出到银行卡总量 10261 share_amt bigint 今日收益 13 category1 bigint 今日类目 1 消费总额 0 category2 bigint 今日类目 2 消费总额 0 category3 bigint 今日类目 3 消费总额 0 category4 bigint 今日类目 4 消费总额 0 收益率数据 mfd_day_share_interest： 列名 类型 含义 示例 mfd_date string 日期 20140102 mfd_daily_yield double 万份收益，即 1 万块钱的收益。 1.5787 mfd_7daily_yield double 七日年化收益率（ % ） 6.307 银行拆借利率数据 mfd_bank_shibor： 列名 类型 含义 示例 mfd_date String 日期 20140102 Interest_O_N Double 隔夜利率（%） 2.8 Interest_1_W Double 1周利率（%） 4.25 Interest_2_W Double 2周利率（%） 4.9 Interest_1_M Double 1个月利率（%） 5.04 Interest_3_M Double 3个月利率（%） 4.91 Interest_6_M Double 6个月利率（%） 4.79 Interest_9_M Double 9个月利率（%） 4.76 Interest_1_Y Double 1年利率（%） 4.78 数据关系今日余额 = 昨日余额 + 今日申购 - 今日赎回今日余额 = 昨日余额 + [直接购买(支付宝+银行)+ 收益] - [消费 + 支出(支付宝+银行)]tBalance = yBalance + (direct_purchase_amt + share_amt) - (consume_amt + transfer_amt) 抽取特征资金流预测采用时间序列预测的ARIMA模型，BP神经网络，集成学习来进行预测，并结合不同的算法进行组合预测 ARIMABPARIMA+BPGBDTRandom Forest]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>time_series</tag>
        <tag>ensemble_learning</tag>
        <tag>bp_nn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas 数据整合、清洗和SQL比较]]></title>
    <url>%2F2019%2F02%2F19%2Fpandas%20compare%20with%20SQL%2F</url>
    <content type="text"><![CDATA[some examples of how various SQL operations would be performed using pandas收集和比较pandas使用过程中和数据库类似的一些操作，方便使用pandas进行数据分析 import pandas and NumPy as follows import numpy as npimport pandas as pd attributions of DataFrame df.dtypes # data type of columnsdf.index # indexesdf.columns # return pandas.indexdf.values # return values of each rowdf.shape # return dimensionality of df 列的修改操作-- addALTER TABLE tipADD column_name NULL--updateUPDATE tipsSET tip = tip*2WHERE tip &lt; 2;--deleteDELETE FROM tipsWHERE tip &gt; 9;--distinct 去重SELECT DISTINCT timeFROM tips 添加tip[&#39;new_col&#39;] = [value1,value2 ...]// 直接添加列tip.assign(new_col = func)// 通过assign使用赋值函数添加tip.loc[df.col==value, &#39;new_col&#39;] = &#39;new_value&#39;// 通过索引到行单独添加 更新tips.loc[tips[&#39;tip&#39;] &lt; 2, &#39;tip&#39;] *= 2// 通过条件筛选出列来直接更新 删除tips = tips.drop(tips[&#39;tip&#39;]&gt;9, axis=1)tips = tips.loc[tips[&#39;tip&#39;] &lt;= 9]Pandas可以把不需要的过滤掉而不是删除 去重tip[tip.duplicated()]// 查看重复的数据tips.drop_duplicates(subset=[&#39;time&#39;], keep=&#39;last&#39;, inplace=True)// subset 选定列// keep {‘first’,’last’,False}， 保留重复元素中的第一个、最后一个，或全部删除// inplace 是否在原对象基础上进行修改 排序sort_value(&#39;col_name&#39;, ascending=True, na_position=&#39;last&#39;)sort_value([&#39;col_name1&#39;, &#39;col_name2&#39;], ascending=True, na_position=&#39;last&#39;)// ascending 设定升降序，na_position 决定 缺失值排列的位置 sort_index(&#39;col_name&#39;)可对索引进行排序 select 查找SELECT 'name_1', 'name_2', ...FROM tipsLIMIT 5; SELECT * = tips 不列举列名，显示所有列tips[[&#39;name_1&#39;,&#39;name_2&#39; ...]].head(5) pandas中利用列名和head()进行筛选 df.loc[1:3, [&#39;name_1,&#39;name_2&#39;,&#39;name_3&#39; ...]] 基于列label，可选取特定行（根据行index）df.iloc[1:3, [0,1,3,5,...]] 基于position(行/列)的位置ix 为loc与iloc的混合体，既支持label也支持positiondf.at[3, &#39;name&#39;] 根据指定行index及列label，快速定位DataFrame的元素；iat 与at类似，不同的是根据position来定位的； whereSELECT *FROM tipsWHERE time = 'Dinner'LIMIT 5;-- tips of more than $5.00 at Dinner mealsSELECT *FROM tipsWHERE time = 'Dinner' AND tip &gt; 5.00;-- tips of more than 5 sizes or more than 45 total_billSELECT *FROM tipsWHERE size &gt;= 5 OR total_bill &gt; 45;SELECT *FROM tipsWHERE total_bill in 20;SELECT *FROM tipsWHERE total_bill not in 20,22,24;SELECT *FROM frameWHERE col2 IS NULL;SELECT *FROM frameWHERE col1 IS NOT NULL; tips[tips[&#39;time&#39;] == &#39;Dinner&#39;].head(5) 最直观的是使用布尔索引 tips[(tips[&#39;time&#39;] == &#39;Dinner&#39;) &amp; (tips[&#39;tip&#39;] &gt; 5.00)]tips[(tips[&#39;size&#39;] &gt;= 5) | (tips[&#39;total_bill&#39;] &gt; 45)]tips[tips[&#39;total_bill].isin([20])]tips[-tips[&#39;total_bill].isin([20,22,24])]搭配and, or, in, not关键词可用 &amp; | isin() 实现查询两者之间记录可以使用between(5, 40, inclusive=True) frame[frame[&#39;col2&#39;].isna()/isnull()]frame[frame[&#39;col1&#39;].notna()/isnull()==False]搭配NULL, NOT NULL，Pandas中使用isna() notna() 或 isnull()==True/False实现 可以使用str.contains()进行正则表达式匹配查询 可以使用pandas提供的query()方法完成指定条件查询tips.query(&#39;指定条件&#39;) group bydf.groupby([&#39;group_name&#39;])[[&#39;col1, col2 ...]].max/min/mean/median/std/count/size()// col_name作为分组变量，对之后给出的统计量进行分组 SELECT sex, count(*)FROM tipsGROUP BY sex;-- Female 87 Male 157 tips.groupby(&#39;sex&#39;).size()//groupby()将数据集拆分为组，应用一些函数(通常是聚合)，然后将这些组组合在一起 ips.groupby(&#39;sex&#39;)[&#39;total_bill&#39;].count()//可以使用count()返回特定列中的非空记录数 SELECT day, AVG(tip), COUNT(*)FROM tipsGROUP BY day;/*Fri 2.734737 19Sat 2.993103 87Sun 3.255132 76Thur 2.771452 62...*/SELECT smoker, day, COUNT(*), AVG(tip)FROM tipsGROUP BY smoker, day; tips.groupby(&#39;day&#39;).agg({&#39;tip&#39;: np.mean, &#39;day&#39;: np.size})//agg()可以使用字典格式描述列，一次汇总多个统计量 tips.groupby([&#39;smoker&#39;, &#39;day&#39;]).agg({&#39;tip&#39;: [np.size, np.mean]})//groupby()支持多条件 对分组之后的数据表可以使用多重索引的方式进行索引df[&#39;group_name&#39;][&#39;col_name&#39;] groupby 其它操作df.groupby([&#39;tips&#39;]).groups // 查看分组对象df.groupby([&#39;tips&#39;]).get_group(&#39;day&#39;) // 得到某一个分组df.groupby([&#39;tips&#39;]).transform(lambda x: ...) // 对分组数据进行lambda公式转换df.groupby([&#39;tips&#39;]).filter(filter_func) // 带数据过滤的分组，filter函数单独书写for group in df.groupby([&#39;tips&#39;]):print (group) // 迭代输出分组内容 数据透视表pd.pivot_table函数用来探索数据集内部的关联性，可实现拆分和堆叠列；数据透视表更像是一种多维的 GroupBy 累计操作。 拆分pd.pivot_table(table, index=&#39;id&#39;, columns=&#39;type&#39;, values=&#39;value&#39;, fill_value=&#39;0&#39;, aggfunc=&#39;sum&#39;).reset_index()// index 原数据中用于分组的列或键，作为新表的行// columns 新数据表中变量所在的列，作为新表的列// values 待拆分的列// fill_value 替换缺失值// aggfunc 聚合函数或函数列表 堆叠pd.melt(table, id_vars=&#39;id&#39;, value_vars=[&#39;value1&#39;,&#39;value2&#39; ...], value_name=&#39;name&#39;, var_name=&#39;type&#39;)// id_vars 用于标示的变量// value_vars 用于堆叠的变量// value_type 堆叠后变量的名称// value_name 堆叠后值的名称 join-- inner joinSELECT *FROM df1INNER JOIN df2 ON df1.key = df2.key;-- left join: show all records from df1SELECT *FROM df1LEFT OUTER JOIN df2 ON df1.key = df2.key;-- right join: show all records from df1SELECT *FROM df1LEFT OUTER JOIN df2 ON df1.key = df2.key;-- full join: show all records from both tablesSELECT *FROM df1FULL OUTER JOIN df2 ON df1.key = df2.key; JOINs can be performed with join() or merge()pd.merge(df1, df2, on=&#39;key&#39;)pd.merge(df1, df2, on=&#39;key&#39;, how=&#39;left&#39;)pd.merge(df1, df2, on=&#39;key&#39;, how=&#39;right&#39;)pd.merge(df1, df2, on=&#39;key&#39;, how=&#39;outer&#39;) 可以设置关键字匹配索引：pd.merge(df1, df2.set_index(&#39;key&#39;), on=&#39;key&#39;, right_index=True) full join 在 RDBMS(关系型数据库)里不适用 unionSELECT city, rankFROM df1UNION ALLSELECT city, rankFROM df2;/* city rank Chicago 1San Francisco 2New York City 3 Chicago 1 Boston 4 Los Angeles 5*/ pd.concat([df1, df2]) // concat()用于链接两个数据表内容pd.concat([df1, df2], axis=1) // axis=1进行横向合并pd.concat([df1, df2]).drop_duplicates() // 可以移除重复行 order and aggregateSELECT * FROM tipsORDER BY tip DESCLIMIT 10 OFFSET 5; tips.nlargest(10 + 5, columns=&#39;tip&#39;).tail(10) // 根据tip降序排序，从最小5开始输出10个结果 -- Oracle's ROW_NUMBER() analytic functionSELECT * FROM ( SELECT t.*, ROW_NUMBER() OVER(PARTITION BY day ORDER BY total_bill DESC) AS rn FROM tips t)WHERE rn &lt; 3ORDER BY day, rn; ROW_NUMBER() OVER (PARTITION BY COL1 ORDER BY COL2)row_number从1开始，为每一条分组记录返回一个数字,根据COL1分组，在分组内部根据 COL2排序，而此函数计算的值就表示每组内部排序后的顺序编号（组内连续的唯一的)MySQL本身不含row_number()函数 tips.assign(rn=tips.sort_values(['total_bill'], ascending=False) .groupby(['day']) .cumcount() + 1) .query('rn &lt; 3') .sort_values(['day', 'rn']) // DataFrame.assign()整理出一个新的列// sort_values([‘total_bill’], ascending=False 根据total_bill的值倒叙排序，赋值rn// groupby([‘day’]) 根据day聚合// query(‘rn &lt; 3’) 筛选rn&lt;3的行// sort_values([‘day’, ‘rn’] 根据day和rn排序 tips.assign(rnk=tips.groupby(['day'])['total_bill'] .rank(method='first', ascending=False)) .query('rnk &lt; 3') .sort_values(['day', 'rnk']) // 使用rank函数返回从小到大排序的下标 SELECT * FROM ( SELECT t.*, RANK() OVER(PARTITION BY sex ORDER BY tip) AS rnk FROM tips t WHERE tip &lt; 2)WHERE rnk &lt; 3ORDER BY sex, rnk; tips[tips['tip'] &lt; 2] .assign(rnk_min=tips.groupby(['sex'])['tip'] .rank(method='min')) .query('rnk_min &lt; 3') .sort_values(['sex', 'rnk_min']) 数据清洗 使用 df.drop_duplicated() 去除重复的数据 使用 df.apply(lambda col:sum(col.isnull())) 计算每列缺失的数据 使用 df.col.fillna(df.col.mean/median()) 填补缺失值 使用盖帽法，分箱法，聚类法去除噪声 盖帽法 def cap(x,quantile=[0.01,0.99]): # 生成分位数 Q01,Q99 = x.quantile(quantile).values.tolist() if Q01 &gt; x.min(): x = x.copy() x.loc(x&lt;Q01) = Q01 if Q99 &lt; x.max(): x = x.copy() x.loc(x&gt;Q99) = Q99new_df = df.apply(cap, quantile=[0.01, 0.99]) 分箱法等深分箱：每个分箱中样本数量一致df.cut(df.col, bins=df.col.quantile([0, 0.25, 0.5, 0.75, 1]))// 利用分位数找到分割点进行4等分箱 等宽分箱：每个分箱中取值范围一致pd.cut(pd.col, 5)// 根据列将数据分成5等分 聚类法多用于多变量处理，常用的有k-means聚类]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[book-list]]></title>
    <url>%2F2019%2F02%2F16%2Fbook-list%2F</url>
    <content type="text"><![CDATA[个人书库，收集正在看的和准备要看的好书，不定期更新 【2018年《华盛顿邮报》推荐书单】本年度推荐的书：《Good Aand Mad》（《善良与狂暴》）、《The Library Book》（图书馆的书）、《The line becomes a river》（《一条线变成一条河》）、《The maze at Windermere》（《温德米尔的迷宫》）、《On desperate ground》（《在绝望的战场上》）、《One person,no vote》（《一人，零票》）、《The Overstory》（《上层林冠》）、《A place for US》（《属于我们的地方》）、《There There》（《好了，没事了》）、《Washington Black》（《华盛顿黑人》）&lt;/br&gt; 【2018年《华尔街日报》十佳书单】本年度推荐的书：《不对称》(ASYMMETRY)《丘吉尔传》(CHURCHILL)《暴风骤雨》(CLOUDBURSTS)《意识的本能》(THE CONSCIOUSNESS INSTINCT)《弗雷德里克·道格拉斯传》(FREDERICK DOUGLASS)《天赐良机》(GODSEND)《伊庇鲁斯的挽歌》(LAMENT FROM EPIRUS)《我自己的生活》(A LIFE OF MY OWN)《头号爱国者》(PATRIOT NUMBER ONE)《暗影季节》(SEASON OF THE SHADOW)&lt;/br&gt; 【2018《金融时报》和麦肯锡年度“最佳商业图书奖”入围书单 】本年度推荐的书：《美国资本主义》（Capitalism in America）《崩溃》（Crashed）《短命的银行》（The Bank That Lived A Little）《受损的商品》（Damaged Goods）《滴血成金》（Bad Blood）《十亿美元鲸鱼》（Billion Dollar Whale）：《简斯维尔》（Janesville），《认清事实》（Factfulness）：《万物价值》（The Value of Everything）《给人民发钱》（Give People Money）《新势力》（New Power）《零工》（Gigged）《亿万富翁的天下》（The Billionaire Raj）《崛起的五千万》（Fifty Million Rising）《极乐男权》（Brotopia）《谁是迈克尔·奥维茨？》（Who Is Michael Ovitz?）&lt;/br&gt; 【2018年比尔·盖茨推荐的5本书】本年度推荐的书：《21世纪的21一个教训 21 Lessons for the 21st Century》《一扫光的武器 Army of None_ Autonomous Weapons and the Future of War》《Educated 》《Bad Blood》《Meditation and Mindfulness》&lt;/br&gt; 【《经济学人》2018年推荐书单】《Moneyland》《Enlightenment Now》《Fascism: A Warning》《First Raise a Flag》《Into the Hands of the Soldiers》《Shadows of Empire》《A History of America in 100 Maps》《Pogrom》《The China Mission》《Rise and Kill First》《We the Corporations》《AI Superpowers》《Radical Markets》《EuroTragedy》《Crashed》《The Wife’s Tale: A Personal History》《Educated》《Barracoon》《Napoleon: A Life》《Churchill: Walking with Destiny》《Gandhi》《The Spy and the Traitor》&lt;/br&gt; 【彭博盘点2018年书单】《high growth handbook》《The Coddling of the American Mind: How Good Intentions and Bad Ideas Are Setting Up a Generation for Failure》《Our Towns: A 100,000-Mile Journey Into the Heart of America》《Educated: A Memoir》《Stubborn Attachments: A Vision for a Society of Free, Prosperous, and Responsible Individuals》《Refugee》《Factfulness: Ten Reasons We’re Wrong About the World—and Why Things Are Better Than You Think》《The Efficiency Paradox: What Big Data Can’t Do》《The Third Plate: Field Notes on the Future of Food》《Inspired: How to Create Tech Products Customers Love》《Bad Blood: Secrets and Lies in a Silicon Valley Startup》《Grant》《Principles: Life and Work》《The Coddling of the American Mind: How Good Intentions and Bad Ideas Are Setting Up a Generation for Failure》《The Culture Code: The Secrets of Highly Successful Groups》《Hit Refresh: The Quest to Rediscover Microsoft’s Soul and Imagine a Better Future for Everyone》《Keeping At It: The Quest for Sound Money and Good Government》《New Power: How Power Works in Our Hyperconnected World—and How to Make It Work for You》《The Complete Personal Memoirs of Ulysses S. Grant》《The Book of Why: The New Science of Cause and Effect》《Powerful: Building a Culture of Freedom and Responsibility》《The Courage to Be Disliked: The Japanese Phenomenon That Shows You How to Change Your Life and Achieve Real 》《Happiness》《Dare to Lead: Brave Work. Tough Conversations. Whole Hearts.》《Without Precedent: Chief Justice John Marshall and His Times》《The Largesse of the Sea Maiden: Stories》《Paris in the Present Tense》《Destined for War: Can America and China Escape Thucydides’s Trap?》《Small Fry》《Life 3.0: Being Human in the Age of Artificial Intelligence》《Love and Ruin》&lt;/br&gt; 来源：jianshu.com/p/0dc43df2c3eb]]></content>
      <categories>
        <category>repo</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 学习笔记]]></title>
    <url>%2F2019%2F02%2F15%2Fmysql%2F</url>
    <content type="text"><![CDATA[-基础笔记-二次回顾，学校课程 + 慕课网 MySQL 详细学习笔记包括MySQL架构，MySQL操作，数据类型，数据库操作，数据表操作（创增删改查排序分组）及子句操作 相关术语DB：数据库(Database)DBS：数据库系统(Database System)DBMS：数据库管理系统(Database Management System) SQL语言： DDL 数据定义语言 DML 数据操作语言 DQL 数据查询语言 DCL 数据控制语言 MySQL架构MySQL是由SQL接口、解析器、优化器、缓存和存储引擎组成 Connectors 指的是不同语言与SQL的交互接口 Management Serivices &amp; Utillities 系统管理和工具 Connection Pool 连接池，管理缓冲用户连接，线程处理等需要缓存的需求 SQL Interface 接收用户的SQL指令，并且返回需要查询的结果 Parser 解析器 Optimizer 查询优化器 选取-投影-联接 Caches &amp; Buffers 查询缓存 Engine 存储引擎 MySQL存储引擎(loading…)memory存储引擎CSV存储引擎archive存储引擎myisam存储引擎innodb存储引擎mysql相关操作my.cnf是MySQL的配置文件 登陆/退出MySQL登陆 mysql -uroot -pmysql -hlocalhost -uroot -p -P3306mysql -uroot -p --prompt=命令提示符 //登陆的同时修改密令提示符mysql -uroot -p -D db_name //登陆的同时打开指定数据库 \h 主机\u 当前登陆的用户\d 当前打开的数据库\D 当前服务器的日期时间\c取消当前命令的执行help或者\h或者?加上相关关键字来查看手册命令行结束符默认使用;或者\g来结束 退出：exit | quit | \q | ctrl+c MySQL语句SELECT USER() //得到登陆的用户SELECT VERSION() //得到MySQL的版本信息SELECT NOW() //得到当前的日期时间SELECT DATABASE() //得到当前打开的数据库 MySQL常用函数CEIL() 进一取整FLOOR() 舍掉小数部分ROUND() 四舍五入TRUNCATE() 截取小数点后几位MOD() 取余数ABS() 取绝对值POWER() 幂运算PI() 圆周率RAND()或者RAND(X) 0~1之间的随机数SIGN(X) 得到数字符号EXP(X) 计算e的x次方 数据库相关操作 创建数据库CREATE {DATABASE|SCHEMA} db_name;检测数据库名称是否存在，不存在则创建CREATE DATABASE [IF NOT EXISTS] db_name;在创建数据库的同时指定编码方式CREATE DATABASE [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset; 查看当前服务器下全部数据库SHOW DATABASES|SCHEMAS; 查看指定数据库的详细信息SHOW CREATE DATABASE db_name; 修改指定数据库的编码方式ALTER DATABASE db_name [DEFAULT] CHARACTER SET [=] charset; 打开指定数据库USE db_name; 得到当前打开的数据库SELECT DATABASE()|SCHEMA(); 删除指定的数据库DROP DATABASE db_name;如果数据库存在则删除DROP DATABASE [IF EXISTS] db_name; MySQL数据类型 CHAR效率高于VARCHAR,CHAR相当于拿空间换时间，VARCHAR拿时间换空间CHAR默认存储数据的时候，后面会用空格填充到指定长度；而在检索的时候会去掉后面空格；VARCHAR在保存的时候不进行填充，尾部的空格会留下TEXT列不能有默认值,检索的时候不存在大小写转换 数据表相关操作数据表：数据表由行(row)和列(column)来组成。每个数据表中至少有一列，行可以有零行一行或者多行组成。表名要求唯一，不要包含特殊字符，最好含义明确 创建表CREATE TABLE [IF NOT EXISTS] tbl_name( 字段名称 字段类型 [完整性约束条件], 字段名称 字段类型 [完整性约束条件],…)ENGINE=存储引擎 CHARSET=编码方式; 约束条件UNSIGNED 无符号，没有负数，从0开始ZEROFILL 零填充，当数据的显示长度不够的时候可以使用前补0的效果填充至指定长度,字段会自动添加UNSIGNEDNOT NULL 非空约束，也就是插入值的时候这个字段必须要给值,值不能为空DEFAULT 默认值，如果插入记录的时候没有给字段赋值，则使用默认值PRIMARY KEY 主键，标识记录的唯一性，值不能重复，一个表只能有一个主键，自动禁止为空AUTO_INCREMENT 自动增长，只能用于数值列，而且配合索引使用,默认起始值从1开始，每次增长1UNIQUE KEY 唯一性，一个表中可以有多个字段是唯一索引，同样的值不能重复，但是NULL值除外FOREIGN KEY 外键约束 示例1（无约束条件） CREATE TABLE IF NOT EXISTS personal_info(id INT,username VARCHAR(20),password CHAR(32),email VARCHAR(50),age TINYINT,card CHAR(18),tel CHAR(11),salary FLOAT(8,2),married TINYINT(1),addr VARCHAR(100),sex ENUM('男','女','保密'))ENGINE=INNODB CHARSET=UTF8; 示例2（带约束条件） CREATE TABLE IF NOT EXISTS `personal_info2`(`id` INT UNSIGNED AUTO_INCREMENT KEY COMMENT '用户编号',`username` VARCHAR(20) NOT NULL UNIQUE COMMENT '用户名',`password` CHAR(32) NOT NULL COMMENT '密码',`email` VARCHAR(50) NOT NULL UNIQUE COMMENT '邮箱',`age` TINYINT UNSIGNED NOT NULL DEFAULT 18 COMMENT '年龄',`sex` ENUM('男','女','保密') NOT NULL DEFAULT '保密' COMMENT '性别',`tel` CHAR(11) NOT NULL UNIQUE COMMENT '电话',`addr` VARCHAR(50) NOT NULL DEFAULT '北京' COMMENT '地址',`card` CHAR(18) NOT NULL UNIQUE COMMENT '身份证号',`married` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '0代表未结婚，1代表已结婚',`salary` FLOAT(8,2) NOT NULL DEFAULT 0 COMMENT '薪水')ENGINE=INNODB DEFAULT CHARSET=UTF8; 要注意单引号和反引号的使用 查看当前数据库下已有数据表SHOW TABLES;SHOW [FULL] TABLES [{FROM | IN} db_name] [LIKE &#39;pattern&#39; | WHERE expr]; 查看指定数据表的详细信息SHOW CREATE TABLE tbl_name; | personal_info2 | CREATE TABLE `personal_info2` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户编号', `username` varchar(20) NOT NULL COMMENT '用户名', `password` char(32) NOT NULL COMMENT '密码', `email` varchar(50) NOT NULL COMMENT '邮箱', `age` tinyint(3) unsigned NOT NULL DEFAULT '18' COMMENT '年龄', `sex` enum('男','女','保密') NOT NULL DEFAULT '保密' COMMENT '性别', `tel` char(11) NOT NULL COMMENT '电话', `addr` varchar(50) NOT NULL DEFAULT '北京' COMMENT '地址', `card` char(18) NOT NULL COMMENT '身份证号', `married` tinyint(1) NOT NULL DEFAULT '0' COMMENT '0代表未结婚，1代表已结婚', `salary` float(8,2) NOT NULL DEFAULT '0.00' COMMENT '薪水', PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`), UNIQUE KEY `email` (`email`), UNIQUE KEY `tel` (`tel`), UNIQUE KEY `card` (`card`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 | 查看表结构DESC tbl_name;DESCRIBE tbl_name;SHOW COLUMNS FROM tbl_name; +----------+------------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+------------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || username | varchar(20) | NO | UNI | NULL | || password | char(32) | NO | | NULL | || email | varchar(50) | NO | UNI | NULL | || age | tinyint(3) unsigned | NO | | 18 | || sex | enum('男','女','保密') | NO | | 保密 | || tel | char(11) | NO | UNI | NULL | || addr | varchar(50) | NO | | 北京 | || card | char(18) | NO | UNI | NULL | || married | tinyint(1) | NO | | 0 | || salary | float(8,2) | NO | | 0.00 | |+----------+------------------------+------+-----+---------+----------------+ 删除指定的数据表DROP TABLE [IF EXISTS] tbl_name; 表结构相关操作add | drop | modify | change | set default | add/drop primary key | add/drop unique |rename 添加字段ALTER TABLE tbl_nameADD 字段名称 字段属性 [完整性约束条件] [FIRST|AFTER 字段名称] 删除字段ALTER TABLE tbl_nameDROP 字段名称 添加默认值ALTER TABLE tbl_nameALTER 字段名称 SET DEFAULT 默认值; 删除默认值ALTER TABLE tbl_nameALTER 字段名称 DROP DEFAULT 修改字段类型、字段属性ALTER TABLE tbl_nameMODIFY 字段名称 字段类型 [字段属性] [FIRST | AFTER 字段名称] 修改字段名称、字段类型、字段属性ALTER TABLE tbl_nameCHANGE 原字段名称 新字段名称 字段类型 字段属性 [FIRST | AFTER 字段名称] 添加主键ALTER TABLE tbl_nameADD PRIMARY KEY(字段名称) 删除主键ALTER TABLE tbl_nameDROP PRIMARY KEY; 添加唯一ALTER TABLE tbl_nameADD UNIQUE KEY|INDEX [index_name] (字段名称) 删除唯一ALTER TABLE tbl_nameDROP index_name; 修改数据表名称ALTER TABLE tbl_nameRENAME [TO|AS] new_tbl_nameRENAME TABLE tbl_name TO new_tbl_name; 修改AUTO_INCREMENT的值ALTER TABLE tbl_name AUTO_INCREMENT=值 数据内容相关操作增加INSERT [INTO] tbl_name[(col_name,...)] {VALUE|VALUES}(VALUES...); 不指定字段名称，需要按照建表时的字段顺序给每一个字段赋值INSERT tbl_name VALUE(value...) 列出指定字段INSERT tbl_name(字段名称,...) VALUES(值,...) INSERT … SET的形式INSERT tbl_name SET 字段名称=值,...; INSERT … SELECTINSERT tbl_name[(字段名称...)] SELECT 字段名称,... FROM tbl_name [WHERE 条件] 一次添加多条记录INSERT tbl_name[(字段名称,...)] VALUES(VALUES,...),(VALUES,....),()... 示例 -- 测试添加记录CREATE DATABASE IF NOT EXISTS kevin DEFAULT CHARACTER SET 'UTF8';USE kevin;CREATE TABLE IF NOT EXISTS user( id INT UNSIGNED AUTO_INCREMENT KEY COMMENT '编号', username VARCHAR(20) NOT NULL UNIQUE COMMENT '用户名', age TINYINT UNSIGNED DEFAULT 18 COMMENT '年龄', email VARCHAR(50) NOT NULL DEFAULT 'xxxx@qq.com' COMMENT '邮箱')ENGINE=INNODB CHARSET=UTF8;-- 不指定字段名称INSERT user VALUE(1,'kevin',24,'420376@qq.com');INSERT user VALUES(DEFAULT,'hex',26,'hex@qq.com');-- 列出指定字段的形式INSERT user(username,email) VALUES('rose','rose@qq.com');INSERT user(age,email,id,username) VALUES(34,'xxxx@qq.com',5,'xxxx');-- 一次插入3条记录INSERT user VALUES(NULL,'a',DEFAULT,DEFAULT),(NULL,'b',56,'b@qq.com'),(NULL,'c',14,'c@qq.com');-- INSERT ...SET 的形式INSERT user SET username='d',age=45,email='d@qq.com';-- INSERT SELECTINSERT user(username) SELECT a FROM test; 删除DELETE FROM tbl_name [WHERE 条件]如果不添加条件，表中所有记录都会被删除DELETE 清空数据表的时候不会重置AUTO_INCREMENT的值，可以通过ALTER 语句将其重置为1 TRUNCATE [TABLE] tbl_name;清除表中所有记录会重置AUTO_INCREMENT的值 示例 -- 测试删除语句-- 删除用户名DELETE FROM user WHERE username='kevin';-- 删除年龄为24的用户DELETE FROM user WHERE age=24;-- 删除表中所有记录DELETE FROM user; 修改UPDATE tbl_name SET 字段名称=值,字段名称=值 [WHERE 条件]如果不添加条件，整个表中的记录都会被更新 示例 -- 测试修改语句-- 修改第一个用户的信息 id=1UPDATE user SET age=29 WHERE id=1;-- 所有用户年龄+10UPDATE user SET age=age+10;-- 将id&lt;=5的用户年龄改为-20，将邮箱改为默认值UPDATE user SET age=age-20,email=DEFAULT WHERE id&lt;=5; 查询（重点）SELECT select_expr,... FROM tbl_name [WHERE 条件] [GROUP BY {col_name|position} HAVING 二次筛选] [ORDER BY {col_name|position|expr} [ASC|DESC]] [LIMIT 限制结果集的显示条数] 查询表中所有记录SELECT * FROM tbl_name;指定字段的信息SELECT 字段名称,... FROM tbl_name库名.表名SELECT 字段名称,... FROM db_name.tbl_name;给字段起别名SELECT 字段名称 [AS] 别名名称,... FROM db_name.tbl_name;给数据表起别名SELECT 字段名称 ,... FROM tbl_name [AS] 别名;表名.字段名的SELECT tbl_name.col_name,... FROM tbl_name; 示例 -- 查询表中所有记录SELECT * FROM user1;-- username,addr,ageSELECT username,addr,age FROM user1;-- 查询数据库下user1表中的所有记录SELECT * FROM kevin.user1;-- 查询user1表中的id 编号 username 用户名 sex 性别SELECT id AS '编号',username AS '用户名', sex AS '性别'FROM user1;-- 给表起别名SELECT id,username FROM user1 AS u;-- 查找表名中的字段名SELECT user1.id,user1.username,user1.age FROM user1 ;SELECT u.id,u.username,u.addr,u.sex FROM user1 AS u; 避免重复关键词 DISTINCT 用于返回唯一不同的值。SELECT DISTINCT 列名称 FROM 表名称 示例 # 从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t，对于重复的emp_no进行忽略。SELECT title, COUNT(DISTINCT emp_no) AS t FROM titlesGROUP BY title HAVING t &gt;= 2 where条件&gt; &gt;= &lt; &lt;= != &lt;&gt; &lt;=&gt; 比较运算符IS [NOT] NULL 检测值是否为NULL或者NOT NULL[NOT] BETWEEN ... AND 指定范围[NOT] IN(值,...) 指定集合[NOT] LIKE 匹配字符% % 任意长度的字符串___ 任意一个字符 示例 SELECT id,username,age FROM user1WHERE id=5;SELECT id,username,age,userDesc FROM user1WHERE userDesc&lt;=&gt;NULL;SELECT id,username,age,userDesc FROM user1WHERE userDesc IS NULL;SELECT id,username,age,sex FROM user1WHERE age BETWEEN 18 AND 30;-- 查询编号为1,3,5,7,9SELECT id,username,age FROM user1WHERE id IN(1,3,5,7,9,29,45,78);SELECT id,username,age,sex FROM user1WHERE sex='男' AND age&gt;=20;SELECT id,username,age,sex,salary,addr FROM user1WHERE salary BETWEEN 60000 AND 100000 AND sex='男' AND addr='北京';SELECT id,username,age FROM user1WHERE id=1 OR username='kevin';SELECT id,username,age FROM user1WHERE username LIKE '%in%';SELECT id,username,age,sex FROM user1WHERE username LIKE '___'; group by 分组 GROUP_CONCAT()查看组中某个字段的详细信息 配合聚合函数使用COUNT() //统计记录总数。如果写的是COUNT(字段名称)，字段中的值为NULL，不统计进来，写COUNT(*)会统计NULL值SUM() //求和MAX() //求最大值MIN() //求最小值AVG() //求平均值 配合WITH ROLLUP关键使用,会在记录末尾添加一条记录，是上面所有记录的总和 HAVING子句对分组结果进行二次筛选 示例 -- 按照性别分组sexSELECT id,username,age,sex FROM user1GROUP BY sex;-- 按照addr分组SELECT username,age,sex,addr FROM user1GROUP BY addr;-- 按照性别分组，查询组中的用户名有哪些SELECT GROUP_CONCAT(username),age,sex,addr FROM user1GROUP BY sex;-- 测试COUNT()SELECT COUNT(id) FROM user1;-- 按照sex分组，得到用户名详情，并且计算组中的总人数SELECT sex,GROUP_CONCAT(username) AS usersDetail,COUNT(*) AS totalUsers FROM user1GROUP BY sex;-- 按照addr分组，得到用户名的详情，总人数，得到组中年龄的总和，年龄的最大值、最小值、平均值SELECT addr,GROUP_CONCAT(username) AS usersDetail,COUNT(*) AS totalUsers,SUM(age) AS sum_age,MAX(age) AS max_age,MIN(age) AS min_age,AVG(age) AS avg_ageFROM user1GROUP BY addr;SELECT GROUP_CONCAT(username) AS usersDetail,COUNT(*) AS totalUsersFROM user1GROUP BY sexWITH ROLLUP;-- 按照字段的位置来分组SELECT id,sex,GROUP_CONCAT(username) AS usersDetail,COUNT(*) AS totalUsers,SUM(salary) AS sum_salary,MAX(salary) AS max_salary,MIN(salary) AS min_salary,AVG(salary) AS avg_salaryFROM user1GROUP BY 2;-- 查询age&gt;=30的用户并且按照sex分组SELECT sex,GROUP_CONCAT(username) AS usersDetail,COUNT(*) AS totalUsersFROM user1WHERE age&gt;=30GROUP BY sex;-- 对于分组结果进行二次筛选，条件是组中总人数&gt;=3SELECT addr,GROUP_CONCAT(username) AS usersDetail,COUNT(*) AS totalUsersFROM user1GROUP BY addrHAVING COUNT(*)&gt;=3;-- 要求平均薪水&gt;=40000SELECT addr,GROUP_CONCAT(username) AS usersDetail,COUNT(*) AS totalUsers,SUM(salary) AS sum_salary,MAX(salary) AS max_salary,MIN(salary) AS min_salary,AVG(salary) AS avg_salaryFROM user1GROUP BY addrHAVING avg_salary&gt;=40000; order by 排序ORDER BY 字段名称 ASC|DESC 示例 -- 按照id降序排列SELECT id,username,ageFROM user1ORDER BY id DESC;-- 按照age升序SELECT id,username,ageFROM user1ORDER BY age ;-- 按照多个字段排序SELECT id,username,ageFROM user1ORDER BY age ASC,id ASC;-- 测试条件+排序SELECT id,username,ageFROM user1WHERE age&gt;=30ORDER BY age DESC;-- 实现随机记录SELECT id,username,ageFROM user1ORDER BY RAND(); LIMIT 限制结果集显示条数LIMIT 值显示结果集的前几条记录LIMIT offset,row_count从offset开始，显示几条记录,offset从0开始 示例 -- 显示结果集的前5条记录SELECT id,username,age,sexFROM user1LIMIT 5;SELECT id,username,age,sexFROM user1LIMIT 0,5;-- 更新前3条记录，将age+5UPDATE user1 SET age=age+5 LIMIT 3;-- 按照id降序排列，更新前三条记录，将age-10UPDATE user1 SET age=age-10 ORDER BY id DESC LIMIT 3;-- 删除前三条记录DELETE FROM user1LIMIT 3;DELETE FROM user1ORDER BY id DESCLIMIT 3; 多表查询 笛卡尔积的形式 内连接的形式SELECT 字段名称,... FROM tbl_name1 INNER JOIN tbl_name2 ON 连接条件 //查询两个表中符合连接条件的记录 外连接的形式 左外连接SELECT 字段名称,... FROM tbl_name1 LEFT OUTER JOIN tbl_name2 ON 条件;左表为主表，先显示左表中的全部记录，再去右表中查询复合条件的记录，不符合的以NULL代替 右外连接SELECT 字段名称,... FROM tbl_name1 RIGHT [OUTER] JOIN tbl_name2 ON 条件;右表为主表，先显示右表中的全部记录，再去左表中查询复合条件的记录，不符合的以NULL代替 示例 -- 查询emp id username age addr dep id depName depDescSELECT e.id,e.username,e.age,e.addr,d.id,d.depName,d.depDescFROM dep AS dJOIN emp AS eON d.id=e.depId;-- 测试左外连接SELECT e.id,e.username,e.age,d.depName,d.depDescFROM emp AS eLEFT OUTER JOIN dep AS dON e.depId=d.id;-- 测试右外连接SELECT e.id,e.username,e.age,d.depName,d.depDescFROM emp AS eRIGHT JOIN dep AS dON e.depId=d.id; 外键约束(loading…)只有InnoDB存储引擎支持外键 建表时指定外键[CONSTRAINT 外键名称 ]FOREIGN KEY(字段名称) REFERENCES 主表(字段名称)子表的外键字段和主表的主键字段类型要相似；如果是数值型要求一致，并且无符号也要一致；如果是字符型，要求类型一致，长度可以不同如果外键字段没有创建索引，MySQL会自动帮我们添加索引子表的外键关联的必须是父表的主键 外键约束的参照操作CASCADE 从附表删除或更新，子表也跟着删除或者更新，级联的操作SET NULL 从附表删除或者更新记录，并设置子表的外键列为NULL。NO ACTION | RESTRICT 拒绝对父表做更新或者删除操作 动态添加外键ALTER TABLE tbl_name [CONSTRAINT 外键名称] ADD FOREIGN KEY(外键字段) REFERENCES 主表(主键字段);动态添加外键之前表中的记录一定合法的记录，没有脏值，否则外键添加不成功 动态删除外键ALTER TABLE tbl_name DROP FOREIGN KEY fk_name; 特殊形式查询(loading…)子查询SELECT 字段名称 FROM tbl_name WHERE col_name=(SELECT col_name FROM tbl_name) 联合查询 UNIONSELECT 字段名称,... FROM tbl_name1 UNION SELECT 字段名称... FROM tbl_name2; UNION ALLSELECT 字段名称,... FROM tbl_name1 UNION ALL SELECT 字段名称... FROM tbl_name2;UNION ALL 是简单的合并，UNION会去掉表中重复记录 自身连接查询正则表达式查询^ 匹配字符串开始的部分$ 匹配字符串结束部分. 代表一个任意字符[字符集合] [abc] [a-z] [0-9][^字符集合] 除了集合中的内容s1|s2|s3 匹配s1或者s2或者s3* 代表匹配前面的字符0次1次或者多次+ 代表匹配前面的字符至少出现1次字符{n} 前面的字符正好出现n次字符{m,n} 前面的字符至少出现m次，最多出现n次 其它注意事项SQL语句语法规范 常用MySQL的关键字我们需要大写，库名、表名、字段名称等使用小写 SQL语句支持折行操作，拆分的时候不能把完整单词拆开 数据库名称、表名称、字段名称不要使用MySQL的保留字，如果必须要使用，需要用反引号``将其括起来 创建的数据库名称最好有意义，名称不要包含特殊字符或者是MySQL关键字 常用SQL语句 SHOW WARNINGS; //查看上一步操作产生的警告信息 CHECK TABLE tbl_name //检测表 REPAIR TABLE tbl_name //修复表 相关链接：PHP &amp; MySQL learning notes (4)PHP &amp; MySQL learning notes (3)PHP &amp; MySQL learning notes (2)PHP &amp; MySQL learning notes (1)]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[move to windows]]></title>
    <url>%2F2019%2F02%2F14%2Fmove-to-windows%2F</url>
    <content type="text"><![CDATA[由于archlinux上出现了一些bug，而且因为跑SLAM，安装包占去了过多存储空间，临时决定将blog移植到Windows上来方便经常更新。 install necessary modules download nodejs and install download git and install Win+R open cmd to the right direction $ mkdir blog$ npm install hexo -g$ hexo -v //check info$ npm install //install necessary components$ hexo init //initialize folder$ hexo g //Start processing related modules $ npm install //install necessary components$ npm install hexo-deployer-git --save // deploy to git$ npm install hexo-generator-feed --save // build RSS$ npm install hexo-generator-sitemap --save // build sitemap add ssh key$ ssh-keygen -t rsa -C "your email address"$ cat /home/xxx/.ssh/id_rsa.pub //check your key load key to Github (default on Github &amp; default you can use Github) $ ssh -T git@github.com set id &amp; email$ git config --global user.name "your id"$ git config --global user.email "your email" copy previous files copy source files to the new catalog (as follows) _config.yml package.json node_modules scaffolds source themes type hexo s to check]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP & MySQL learning notes (3)]]></title>
    <url>%2F2019%2F01%2F21%2Fphp-notes2%2F</url>
    <content type="text"><![CDATA[-基础笔记-慕课网 PHP基础语法巩固(2) 课堂笔记，包含会话，文件，数据库操作等细碎的摘要 会话控制sessionHTTP是无状态协议，HTTP不知道请求来自哪个客户端，Session提供在PHP脚本中定义全局变量的方法，使全局变量在同一个Session中对所有的PHP脚本文件内都有效,解决HTTP断链接的问题Session可以减轻服务器压力，缺点在于每次请求会传输大量重复的信息Session允许通过将数据存储在HTTP服务器中，使得用户在回话过程中保持该数据 session_start();$_SESSION['id'] = 'info' 每一次请求有SessionID区分不同的信息，SessionID存储到cookie中，Session数据通过变量$_SESSION存储到Session文件中 SessionID： PHP回话启用 检查SessionID，如果没有启动新会话 + SessionID 一直使用的SessionID相同，默认会话在活动，超过一定时间则视为过期 默认情况下SessionID存在Cookie中，也可以存在URL中 Session函数： bool session_start() //启动新会话或重用现有会话string session_id(string $id) //获取/设置当前会话的idstring session_name(string $name) //读取/设置会话名称bool session_destroy(void) //销毁一个会话中的全部数据session.auto_start(bool) //指定会话模块在请求开始时自动启动session.name(string) //指定会话名用作cookie名字session.save_handler(string) //定义用来存储和获取与会话关联的数据处理器的名字session.save_path(string) //定义传递给存储处理器的参数session.gc_maxlifetime(int) //指定数据存在时长session.gc_probability(int) //定义在会话初始化时启动垃圾回收进程的概率 必须在session_start()函数之前调用session_name()函数 垃圾回收进程概率计算：gc_probability/gc_divisor cookiecookie是服务器发送到用户浏览器上并保存在浏览器里的数据，会在浏览器下一次请求时一起发送到服务器上 session是存储在服务器的数据cookie是存储在客户端的数据 cookie的用途：会话状态管理，个性化设置，浏览器行为跟踪 bool setcookie(string $name,string $value,[$expire,$path,$domain]) //名称，值，生命周期，路径，域名范围 文件操作API 文件信息相关 filetype($filename); //获取文件的类型；返回的是文件的类型，可能的值有 fifo，char，dir，block，link，file 和 unknown。如果 stat 调用失败或者文件类型未知的话 filetype() 还会产生一个 E_NOTICE 消息。filesize($filename); //获取文件的大小；返回的是字节数。如果出错返回 FALSE 并生成一条 E_WARNING 级的错误。filectime($filename); //获取文件的创建时间；返回的是时间戳。在失败时返回 FALSE。 时间以 Unix 时间戳的方式返回。filemtime($filename); //获取文件的修改时间；返回的是时间戳。在失败时返回 FALSE。fileatime($filename); //获取文件的最后访问时间；返回的是时间戳。在失败时返回 FALSE。//可以使用date()函数修改日期和时区；date_default_timezone_set('PRC');date('Y-m-d H:i:s',filectime($filename));is_readable($filename); //检测文件是否可读；返回布尔值is_writable($filename)/is_writeable($filename); //检测文件是否可写；返回布尔值is_executable($filename); //检测文件是否可执行；返回布尔值is_file($filename); //检测是否为文件；返回布尔值 文件路经相关 pathinfo($filename, $options); //获取文件路径相关信息；返回一个关联数组，包含有 path 的信息//options如果指定了，将会返回指定元素；它们包括：PATHINFO_DIRNAME，PATHINFO_BASENAME 和 PATHINFO_EXTENSION 或 PATHINFO_FILENAME。dirname($path); //返回文件中的路径部分basename($filename,$suffix); //返回路径文件名部分；file_exists($filename); //检测文件或者目录是否存在；返回布尔值 文件操作相关 touch($filename，$time,$atime); //设定文件的访问和修改时间，如果文件不存在，则会创建文件；返回布尔值//time: 使用当前系统的时间。//atime: 访问时间会被设为 atime，unlink($filename,$context); //删除文件；返回布尔值；rename($oldname,$newname，$path); //重命名或者剪切(给剪切path)一个文件或目录;返回布尔值；copy($filename); //拷贝一个文件或者目录；返回布尔值； 文件内容操作相关 $handle = fopen($filename, r|r+|w|...) //打开指定文件fread($handle, $size) //读取文件内容fwrite($handle, 'info',$size)|fput() //写入内容,之前有内容会覆盖ftell($handle) //读取指针位置fseek($handle,$size) //移动指针的位置fpassthru() //输出文件指针处的所有剩余数据rewind($handle) //重置文件指针ftruncate($handle,$size) //将文件截断到指定长度fgetc($handle) //读取一个字符fgets($handle) //读取一行字符fgetss($handle) //读取一行并过滤掉 HTML 标记fgetcsv() //从文件指针中读入一行并解析 CSV 字段fputcsv() //将行格式化为 CSV 并写入文件指针file_get_contents() //将整个文件读入一个字符串file_put_contents() //将一个字符串写入文件，和依次调用 fopen()，fwrite() 以及 fclose() 功能一样。file() //把整个文件读入一个数组中readfile() //读取文件并写入到输出缓冲feof($handle) //测试文件指针是否到了文件结束的位置fclose() //关闭文件parse_ini_file($filename) //解析一个配置文件parse_ini_string($ini) //解析配置字符串highlight_string($str) //字符串的语法高亮highlight_file() //语法高亮一个文件 ‘r’：只读方式打开，将文件指针指向文件头。‘r+’：读写方式打开，将文件指针指向文件头。‘w’：写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。‘w+’：读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。‘a’：写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。‘a+’：读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。‘x’：创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给 底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。‘x+’：创建并以读写方式打开，其他的行为和 ‘x’ 一样。 函数和类的封装 创建文件 可以用touch()创建，也可以直接file_get_contents() function create_file(string $filename)&#123; //检测文件是否存在，不存在则创建 if(file_exists($filename))&#123; return false; &#125; //检测目录是否存在，不存在则创建 if(!file_exists(dirname($filename)))&#123; //创建目录，可以创建多级 mkdir(dirname($filename),0777,true); &#125; // if(touch($filename))&#123; // return true; // &#125; // return false; if(file_put_contents($filename,'')!==false)&#123; return true; &#125; return false;&#125; 删除文件 function del_file(string $filename)&#123; //检测删除的文件是否存在,并且是否有权限操作 if(!file_exists($filename)||!is_writable($filename))&#123; return false; &#125; if(unlink($filename))&#123; return true; &#125; return false;&#125; 拷贝文件 function copy_file(string $filename,string $dest)&#123; //检测$dest是否是目标并且这个目录是否存在，不存在则创建 if(!is_dir($dest))&#123; mkdir($dest,0777,true); //0777为权限 &#125; $destName=$dest.DIRECTORY_SEPARATOR.basename($filename); //检测目标路径下是否存在同名文件 if(file_exists($destName))&#123; return false; &#125; //拷贝文件 if(copy($filename,$destName))&#123; return true; &#125; return false;&#125; 重命名文件 function rename_file(string $oldName,string $newName)&#123; //检测原文件并且存在 if(!is_file($oldName))&#123; return false; &#125; //得到原文件所在的路径 $path=dirname($oldName); $destName=$path.DIRECTORY_SEPARATOR.$newName; //路径下有文件名，重命名失败 if(is_file($destName))&#123; return false; &#125; if(rename($oldName,$newName))&#123; return true; &#125; return false;&#125; 剪切文件 function cut_file(string $filename,string $dest)&#123; //检查文件和路径是否都存在 if(!is_file($filename))&#123; return false; &#125; if(!is_dir($dest))&#123; mkdir($dest,0777,true); &#125; $destName=$dest.DIRECTORY_SEPARATOR.basename($filename); if(is_file($destName))&#123; return false; &#125; if(rename($filename,$destName))&#123; return true; &#125; return false;&#125; 返回文件信息 function get_file_info(string $filename)&#123; //检查文件存在且可读 if(!is_file($filename)||!is_readable($filename))&#123; return false; &#125; return [ 'atime'=&gt;date("Y-m-d H:i:s",fileatime($filename)), 'mtime'=&gt;date("Y-m-d H:i:s",filemtime($filename)), 'ctime'=&gt;date("Y-m-d H:i:s",filectime($filename)), 'size'=&gt;trans_byte(filesize($filename)), 'type'=&gt;filetype($filename) ];&#125; 字节转换 function trans_byte(int $byte,int $precision=2)&#123; $kb=1024; $mb=1024*$kb; $gb=1024*$mb; $tb=1024*$gb; if($byte&lt;$kb)&#123; return $byte.'B'; &#125;elseif($byte&lt;$mb)&#123; return round($byte/$kb,$precision).'KB'; &#125;elseif($byte&lt;$gb)&#123; return round($byte/$mb,$precision).'MB'; &#125;elseif($byte&lt;$tb)&#123; return round($byte/$gb,$precision).'GB'; &#125;else&#123; return round($byte/$tb,$precision).'TB'; &#125;&#125; 读取文件内容返回字符串 function read_file(string $filename)&#123; //检测是否是一个文件并且文件可读 if(is_file($filename) &amp;&amp; is_readable($filename))&#123; return file_get_contents($filename); &#125; return false;&#125; 读取文件内容返回数组 function read_file_array(string $filename,bool $skip_empty_lines=false)&#123; //检测是否是一个文件并且文件可读 if(is_file($filename)&amp;&amp;is_readable($filename))&#123; if($skip_empty_lines)&#123; //如果有空行就过滤掉 return file($filename,FILE_IGNORE_NEW_LINES|FILE_SKIP_EMPTY_LINES); &#125;else&#123; return file($filename); &#125; &#125; return false;&#125; 文件中写入内容 写入的内容是数组或者对象需要做序列化处理 function write_file(string $filename,$data)&#123; $dirname=dirname($filename); //检测目标路径是否存在 if(!file_exists($dirname))&#123; mkdir($dirname,0777,true); &#125; //判断内容是否是数组或者对象 if(is_array($data)||is_object($data))&#123; //序列化数据 $data=serialize($data); &#125; //向文件中写入内容 if(file_put_contents($filename,$data)!==false)&#123; return true; &#125;else&#123; return false; &#125;&#125; 非空文件中写入内容 function write_file1(string $filename,$data,bool $clearFlag=false)&#123; $dirname=dirname($filename); //检测目标路径是否存在 if(!file_exists($dirname))&#123; mkdir($dirname,0777,true); &#125; //检测文件是否存在并且可读 if(is_file($filename)&amp;&amp;is_readable($filename))&#123; //读取文件内容，之后和新写入的内容拼装到一起 if(filesize($filename)&gt;0)&#123; $srcData=file_get_contents($filename); &#125; &#125; //判断内容是否是数组或者对象 if(is_array($data)||is_object($data))&#123; //序列化数据 $data=serialize($data); &#125; //拼装到一起 $data=$srcData.$data; //向文件中写入内容 if(file_put_contents($filename,$data)!==false)&#123; return true; &#125;else&#123; return false; &#125;&#125; 截断文件到指定大小 function truncate_file(string $filename,int $length)&#123; //检测是否是文件且可写 if(is_file($filename)&amp;&amp;is_writable($filename))&#123; $handle=fopen($filename,'r+'); $length=$length&lt;0?0:$length; ftruncate($handle,$length); fclose($handle); return true; &#125; return false;&#125; 下载文件 在html里添加下载链接 建立down_file()函数 建立php文件进行下载 &lt;a href="download.php?filename=download.zip"&gt;file_name.zip&lt;/a&gt; //$allowDownExt 允许下载的文件类型function down_file(string $filename,array $allowDownExt=array('jpeg','jpg','png','gif','txt','html','php','rar','zip'))&#123; //检测下载文件是否存在，并且可读 if(!is_file($filename)||!is_readable($filename))&#123; return false; &#125; //检测文件类型是否允许下载 $ext=strtolower(pathinfo($filename,PATHINFO_EXTENSION)); if(!in_array($ext,$allowDownExt))&#123; return false; &#125; //通过header()发送头信息 //告诉浏览器输出的是字节流 header('Content-Type:application/octet-stream'); //告诉浏览器返回的文件大小是按照字节进行计算的 header('Accept-Ranges: bytes'); //告诉浏览器返回的文件大小 header('Accept-Length: '.filesize($filename)); //告诉浏览器文件作为附件处理，告诉浏览器最终下载完的文件名称 header('Content-Disposition: attachment;filename=king_'.basename($filename)); //读取文件中的内容 //readfile($filename); //exit; //规定每次读取文件的字节数为1024字节，直接输出数据 $read_buffer=1024; $sum_buffer=0; $handle=fopen($filename,'rb'); while(!feof($handle) &amp;&amp; $sum_buffer&lt;$filesize)&#123; echo fread($handle,$read_buffer); $sum_buffer+=$read_buffer; &#125; fclose($handle); exit;&#125; $filename=$_GET['filename'];down_file($filename); 单文件上传 function upload_file(array $fileInfo,string $uploadPath='./uploads',bool $imageFlag=true,array $allowExt=array('jpeg','jpg','png','gif'),int $maxSize=2097152)&#123; define('UPLOAD_ERRS',[ 'upload_max_filesize'=&gt;'超过了PHP配置文件中upload_max_filesize选项的值', 'form_max_size'=&gt;'超过了表单MAX_FILE_SIZE选项的值', 'upload_file_partial'=&gt;'文件部分被上传', 'no_upload_file_select'=&gt;'没有选择上传文件', 'upload_system_error'=&gt;'系统错误', 'no_allow_ext'=&gt;'非法文件类型', 'exceed_max_size'=&gt;'超出允许上传的最大值', 'not_true_image'=&gt;'文件不是真实图片', 'not_http_post'=&gt;'文件不是通过HTTP POST方式上传上来的', 'move_error'=&gt;'文件移动失败' ]); //检测是否上传是否有错误 if($fileInfo['error']===UPLOAD_ERR_OK)&#123; //检测上传文件类型 $ext=strtolower(pathinfo($fileInfo['name'],PATHINFO_EXTENSION)); if(!in_array($ext,$allowExt))&#123; echo UPLOAD_ERRS['no_allow_ext']; return false; &#125; //检测上传文件大小是否符合规范 if($fileInfo['size']&gt;$maxSize)&#123; echo UPLOAD_ERRS['exceed_max_size']; return false; &#125; //检测是否是真实图片 if($imageFlag)&#123; if(@!getimagesize($fileInfo['tmp_name']))&#123; echo UPLOAD_ERRS['not_true_image']; return false; &#125; &#125; //检测文件是否通过HTTP POST方式上传上来的 if(!is_uploaded_file($fileInfo['tmp_name']))&#123; return UPLOAD_ERRS['not_http_post']; &#125; //检测目标目录是否存在，不存在则创建 if(!is_dir($uploadPath))&#123; mkdir($uploadPath,0777,true); &#125; //生成唯一文件名，防止重名产生覆盖 $uniName=md5(uniqid(microtime(true),true)).'.'.$ext; $dest=$uploadPath.DIRECTORY_SEPARATOR.$uniName; //移动文件 if(@!move_uploaded_file($fileInfo['tmp_name'],$dest))&#123; echo UPLOAD_ERRS['move_error']; return false; &#125; echo '文件上传成功'; return $dest; &#125;else&#123; switch($fileInfo['error'])&#123; case 1: // $mes='超过了PHP配置文件中upload_max_filesize选项的值'; $mes=UPLOAD_ERRS['upload_max_filesize']; break; case 2: $mes=UPLOAD_ERRS['form_max_size']; break; case 3: $mes=UPLAOD_ERRS['upload_file_partial']; break; case 4: $mes=UPLOAD_ERRS['no_upload_file_select']; break; case 6: case 7: case 8: $mes=UPLAOD_ERRS['upload_system_error']; break; &#125; echo $mes; return false; &#125;&#125; 压缩单个文件 ZipArchive()一个用 Zip 压缩的文件存档类 压缩包要打开后将文件添加到压缩包中 function zip_file(string $filename)&#123; if(!is_file($filename))&#123; return false; &#125; $zip=new ZipArchive(); $zipName=basename($filename).'.zip'; //打开指定压缩包，不存在则创建，存在则覆盖 if($zip-&gt;open($zipName,ZipArchive::CREATE|ZipArchive::OVERWRITE))&#123; //将文件添加到压缩包中并删除文件 if($zip-&gt;addFile($filename))&#123; @unlink($filename); &#125; $zip-&gt;close(); return true; &#125;else&#123; return false; &#125;&#125; 多文件压缩 function zip_files(string $zipName,...$files)&#123; //检测压缩包名称是否正确 $zipExt=strtolower(pathinfo($zipName,PATHINFO_EXTENSION)); if('zip'!==$zipExt)&#123; return false; &#125; $zip=new ZipArchive(); if($zip-&gt;open($zipName,ZipArchive::CREATE|ZipArchive::OVERWRITE))&#123; foreach($files as $file)&#123; if(is_file($file))&#123; $zip-&gt;addFile($file); &#125; &#125; $zip-&gt;close(); return true; &#125;else&#123; return false; &#125;&#125; 解压缩 function unzip_file(string $zipName,string $dest)&#123; //检测要解压压缩包是否存在 if(!is_file($zipName))&#123; return false; &#125; //检测目标路径是否存在 if(!is_dir($dest))&#123; mkdir($dest,0777,true); &#125; $zip=new ZipArchive(); if($zip-&gt;open($zipName))&#123; $zip-&gt;extractTo($dest); $zip-&gt;close(); return true; &#125;else&#123; return false; &#125;&#125; 函数和类的封装源码: code/lib/file.func.php MySQL 具体参考PHP &amp; MySQL learning notes (1)-&gt;3.mySQL PHP操作MySQL MySQL：非永久链接，性能低，PHP5.5之后废弃 MySQLi：永久链接，减轻了服务器压力 PDO：实现MySQLi常用功能，支持大部分数据库 连接数据库：mysql -uroot -p password选择数据库：use db设置字符集：set names utf8 mysql_select_db("DATABASE NAME", $con)mysql_connect($server,$username,$password) //链接数据库mysql_select_db($database_name) //选择数据库名mysql_set_charset($charset) //设置字符集mysql_query($query) //执行INSERT，UPDATE，DELETE，DROP之类的操作，返回boolmysql_query($query) //执行SELECT操作，成功返回resource，失败返回FALSE 代码示例 header('content-type:text/html;charset=utf-8');//1、连接数据库$link = @mysql_connect('localhost','root','') or die('数据库连接失败！');//2、选择数据库mysql_select_db('test') or die('选择的数据库不存在！');//3、设置字符集mysql_set_charset('utf8');//添加数据$result = mysql_query("INSERT INTO users VALUES(NULL ,'李四',20)");//var_dump($result);//修改数据$result = mysql_query("UPDATE users SET money=25 where id=3");//var_dump($result);//删除单条数据$result = mysql_query("DELETE FROM users where id=3");//var_dump($result);//删除数据表$result = mysql_query("DROP TABLE test");//var_dump($result);//查询$result = mysql_query("SELECT * FROM users");//$line = mysql_fetch_row($result);//$line = mysql_fetch_assoc($result);while($line = mysql_fetch_array($result,MYSQL_ASSOC))&#123; $data[] = $line;&#125;var_dump($data);//array (size=3)// 'id' =&gt; string '1' (length=1)// 'name' =&gt; string '慕课' (length=6)// 'money' =&gt; string '100' (length=3)//关闭数据库连接mysql_close($link); MySQLi操作$connect = mysqli_connect('host','username','password'.'database'); //面向过程方式链接数据库$result = mysqli_query($connect,$sql); //执行SQL语句mysqli_fetch_all($result) //获取结果集 错误及常用命令 Parse error（解析错误）: syntax error(语法错误), unexpected ‘&lt;’, expecting end of file Notice(通知): Undefined variable（未定义的变量）: sdkljflskdjflksdjflksdjfklj Catchable fatal(致命) error: Object of class stdClass could not be converted to string Warning(警告): settype(): Invalid(非法) type&lt;/br&gt; header('content-type:text/html;charset=utf-8');date_defalut_timezone_set('PRC');@ //PHP提供的错误信息屏蔽的专用符号echo($var,....) //输出一个或者多个字符串var_dump($var) //打印变量的详细信息,可以一次打印一个或者多个变量的详细信息print_r($var) //打印数组的信息unset($var,...) //销毁变量，可以一次销毁一个或者多个，销毁之后变量的值为nulltime() //返回当前的 Unix 时间戳is_[int|float|double|bool...]($var) //判断变量的类型isset() //检测变量是否存在function_exists() //判断函数谁否存在file_exists() //判断文件是否存在$var = file_get_contents($filename) //得到文件中的内容，返回的是字符串serialize() //产生一个可存储的值的表示unserialize() //从已存储的表示中创建 PHP 的值setcookie(string $name, string $value, int $expire = 0, string $path = "", string $domain = "") //设置coockie：$name名称 $value值 $expire生命周期 $path可用路径 $domain可用域名范围$var = strip_tags() //从字符串中去除 HTML 和 PHP 标记exit()|die(); //输出一个消息并且退出当前脚本 相关链接：mysql笔记PHP &amp; MySQL learning notes (2)PHP &amp; MySQL learning notes (1)]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning API Collection]]></title>
    <url>%2F2019%2F01%2F15%2Fml-api%2F</url>
    <content type="text"><![CDATA[无聊收集的一个机器学习的api仓库，不定期更新 人脸与图片识别api Animetrics Face Recognition: 该 API 能够用于图片中的人脸检测，并且将其与已知的部分人脸进行匹配分析；该 API 还支持从某个待搜索的集合中添加或者移除某个分类，或者从某个分类中添加或者删除某张人脸图片。 Betaface: 同样是提供人脸识别与检测的在线服务。它支持多人脸检测、人脸裁剪、123 个人脸特征点提取、人脸验证、识别以及大型数据库中的相似性搜索提取。 Eyedea Recognition: 致力于提供高阶的计算机视觉解决方案，主要包括对象检测与识别。其识别服务提供了常见的眼部、人脸、车辆、版权以及果盘识别，该 API 主要的价值在于对于对象、用户以及行为的快速识别。 Face++: 为应用提供面部的检测、识别以及分析服务，用户可以通过 API 调用训练模型，进行人脸检测、人脸识别、人脸分类、图像修正、创建人脸分组等等服务。 FaceMark: 提供了能够在正面照片中检测 68 个特征点以及侧面照片中检测 35 个特征点的服务。 FaceRect: 提供了非常强力与完整的面部检测的 API ，包括在正面照片与侧面照片中检测面部以及在单张照片中提取多个面部的功能；它还能将结果以 JSON 格式输出，包括检测到的眼睛、鼻子、嘴等等面部特征。 Google Cloud Vision API: 架构于著名的 TensorFlow 之上，能够高效地学习与预测图片中的内容。它能够有助于用户搜索最爱的图片，并且获取图片中丰富的注释。它还能将图片按照船、狮子、埃菲尔铁塔等等不同的类别进行分类，并且对照片中不同表情的面部进行识别，除此之外它还能将图片中不同国家的语言打印出来。 IBM Watson Visual Recognition: 该 API 能够辅助理解图片内容，包括图片标记、人脸识别、年龄估计以及性别判断，还能根据人脸相似度进行搜索。开发者能够在该服务的基础上结合自身业务特点定制出各式各样奇妙的产品。 Kairos: 该平台方便开发者快速添加 情感分析 与 人脸识别 的功能到应用与服务中。 Microsoft Cognitive Service – Computer Vision: 该 API 能够根据用户输入与用户选择分析可视化内容。譬如根据内容来标记图片、进行图片分类、人类识别并且返回他们的相似性、进行领域相关的内容识别、创建图片的内容描述、定位图片中的文本、对图片内容进行成人分级等。 Rekognition: 该 API 能够根据社交图片应用的特点提供快速面部识别与场景识别。譬如基于人眼、嘴、面部以及鼻子等等特征进行性别、年龄以及情绪预测。 Skybiometry Face Detection and Recognition: 该 API 提供人脸检测与识别服务，新版本的 API 还提供了深色微分功能. 文本分析，自然语言处理，情感分析api Bitext 提供了目前市场上来说几乎最准确的基于情感的多主题识别，目前包括四个语义服务：实体与概念抽取、情感分析与文本分类；该 API 总共支持 8 种不同的语言。 Diffbot Analyze: 为开发者提供了从任何网页中识别、分析以及提取主要内容与区块的功能。 Free Natural Language Processing Service: 提供了包括情感分析、内容提取以及语言检测等功能。它同样是 mashape.com 这个大型云 API 市场中的畅销产品之一。 Google Cloud Natural Language API: 该 API 提供了对于文档的架构与含义进行分析的功能，包括情感分析、实体识别以及文本标注等。 IBM Watson Alchemy Language: 该 API 能够辅助电脑学习如何阅读以及进行一些文本分析任务。譬如将非结构化数据按照领域模型转化为结构化数据，使其能够服务于社交媒体监测、商业智能、内容推荐、商业交易以及定向广告等等服务。 MeaningCloud Text Classification: 该 API 提供了部分预分类的功能：文本提取、分词、停用词设置以及同义词提取等等。 Microsoft Azure Text Analytics API 基于 Azure Machine Learning 实现的一系列文本分析服务。该 API 能够用于情感分析、关键语句提取、语言检测以及主题识别这些非结构化文本的处理任务。该 API 并不需要使用者提供相关的训练数据，能够大大降低使用门槛。 Microsoft Cognitive Service – Text Analytics: 提供了情感检测、关键语句提取、主题以及语言分析等功能。该分组中其他的 API 还包括 Bing 拼写检测、语言理解、文本分析、Web 语言模型等等。 nlpTools: 简单的采用 JSON 传输格式的提供了自然语言处理功能的 HTTP RESTful 服务。它能够提供对于在线媒体的情感分析与文本分类等服务。 Semantic Biomedical Tagger: 能够利用文本分析技术提取出文档中的 133 个生物医药学相关的实体词汇并且将它们链接到知识库中。 Thomson Reuters Open Calais™: Calais 基于自然语言处理与机器学习技术，能够分类与关联文档中的实体信息（人名、地名、组织名等）、事实信息（员工 x 为公司 y 工作）、事件信息（员工 z 在 x 日被任命为 y 公司的主席） 。 Yactraq Speech2Topics 提供了基于语音识别与自然语言处理技术的将语音内容转化为主题数据的云服务。 语言翻译api Google Cloud Translation: 能够在数以千计的语言之间完成文本翻译工作。该 API 允许网页或者程序方便地接入这些翻译服务。 IBM Watson Language Translator: 能够在不同语言之间进行文本翻译，该服务允许开发者基于独特的领域术语与语言特性进行自定义模型开发。 LangId: 能够快速地从多语言中检索结果的服务，并不需要使用者指定哪种语言，并且能够返回结果对应的语言类型。 Microsoft Cognitive Service – Translator: 能够自动地在翻译之前进行语言类型检测，支持 9 种语言的语音翻译以及 60 种语言的文本翻译。 MotaWord: 快速地人工翻译平台，提供了超过 70 种语言支持。该 API 同样允许开发者查询翻译报价、上传带有文档说明与样式指南的翻译项目请求、自动追踪翻译进度以及进行实时反馈等。 WritePath Translation: API 允许开发者将 WritePath 功能集成到自定义应用中，包括字数检索、提交文本翻译任务、以及获取翻译信息等等。 预测与其他机器学习api Amazon Machine Learning: 寻找数据中的隐藏模式信息，典型的用法包括诈骗检测、天气预报、市场营销以及点击预测等。 BigML: 提供基于云的机器学习与数据分析服务，允许用户以 HTTP 请求的方式自己创建数据源以及选择合适的模型来处理有监督或者无监督的机器学习任务。 Ersatz: 基于 GPU 支持的深度神经网络提供的预测服务，允许用户以 API 方式进行交互。Ersatz 中还利用增强学习来合并不同的神经网络模型来提升整体的效果。 Google Cloud Prediction: 提供了用于构建机器学习模型的 RESTful API 。这些工具能够通过分析数据来提取出应用中数据的不同特征，譬如用户情感、垃圾信息检测、推荐系统等等。 Google Cloud Speech API: 能够提供超过 80 种语言的快速与准确的语音识别以及转化服务。 Guesswork.co: 能够为电商网站提供产品推荐引擎，Guesswork 可以通过基于 Google 预测 API 构建的语义化引擎来对用户行为进行预测。 Hu:toma: 帮助世界各地的开发者构建商用级别的深度学习聊天机器人。 IBM Watson Conversation : 帮助构建可以部署在多个消息平台或者网页上的，能够理解自然语言的聊天机器人。其他类似的 API 还包括 Dialog、Natural Language Classifier、Personality Insights、Document Conversion以及 Tone Analyzer. IBM Watson Speech : 包含了 语音到文本 以及 文本到语音 之间的转化功能（譬如创建语音控制的应用）。 IBM Watson Data Insights: 该系列的服务包含了三个 API ：AlchemyData News、Discovery 以及 Tradeoff Analytics。AlchemyData 提供了对于大量的新闻、博客内容的高级别定向搜索与趋势分析的服务。Tradeoff Analytics 则是帮助用户在多目标优化时进行有效抉择。 IBM Watson Retrieve and Rank: 开发者可以将自定义数据导入到服务中，并且使用相关的关联发算法来训练机器学习模型。服务的输出包括了一系列相关的文档与元数据，譬如某个联络中心的代理能够基于该服务提高呼叫的平均处理时间。 Imagga: 能够为你的图片自动打标签，从而允许你的图片可以被关联搜索到。 indico: 提供了文本分析（情感分析、Twitter 参与度、表情分析等）以及 图片分析（面部表情识别、面部定位）。indico 的 API 可以免费试用并且不需要任何的训练数据。 Microsoft Azure Cognitive Service API : 基于预测分析提供机器学习推荐服务，譬如个性化产品推荐等，可以用来代替传统的 Azure Machine Learning Recommendations 服务。新版本提供了批处理支持，更好地 API 检索服务、更清晰的 API 使用界面以及更好的注册与账单界面等。 Microsoft Azure Anomaly Detection API : 能够在序列数据中检测出异常数据，譬如检测内存使用过程中是否存在内存泄露的情况。 Microsoft Cognitive Service – QnA Maker: 将信息提取为会话式的、易于浏览的数据形式。其他类似的 API 还包括 Academic Knowledge、Entity Linking、Knowledge Exploration以及Recommendations。 Microsoft Cognitive Service – Speaker Recognition: 帮助应用来分析检测出当前的发言者。其他的类似于的 API 还包括Bing Speech （将语音转化为文本并且理解其大致含义）、 Custom Recognition 等等。 NuPIC : 由 NuPIC 社区运行与维护的开源项目，其基于 Python/C++ 实现了 Numenta’s Cortical Learning 算法并对外提供 API 服务。该 API 允许开发者能够使用基本算法或者分层算法，也可以选择使用其他的平台功能。 PredicSis: 能够通过预测分析与大数据技术提供市场营销的效用与收益。 PredictionIO: 基于 Apache Spark、HBase 以及 Spray 这些著名的开源项目搭建的开源机器学习服务。典型的 API 包括了创建与管理用户信息及其行为记录、检索项目与内容、基于用户进行个性推荐等等。 RxNLP – Cluster Sentences and Short Texts: 提供了文本挖掘与自然语言处理的服务。其中语句聚类 API 能够将不同的语句进行分类，譬如将不同新闻文章中的语句或者 Twitter、Facebook 上提取出来的短文本划分到不同的分组中。 Sightcorp F.A.C.E.: 该 API 能够帮助第三方应用来更好地理解用户行为，并且根据年龄、性别、面部表情、头部姿势以及种族划分来进行相似面部的分析与搜索。]]></content>
      <categories>
        <category>repo</category>
      </categories>
      <tags>
        <tag>machine_learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于RGB-D相机数据的三维场景构建]]></title>
    <url>%2F2019%2F01%2F10%2Fslam-rgbd%2F</url>
    <content type="text"><![CDATA[-研究笔记-简要介绍通过RGB-D相机采集到的一个场景的图像数据和深度数据，对这个场景进行三维点云地图的简单构建。整个步骤分为特征提取，特征匹配，位姿估计，三维重建。首先从图像中提取ORB特征，采用暴力匹配的方法得到图像间特征点的匹配结果，然后采用PnP估计相机的位姿筛选出关键帧，最后利用当前帧简历三维场景地图。后端使用Eigen加速矩阵计算，g2o对相机位姿进行优化，使用PCL拼接点云。实验数据采用TUM的RGB-D数据集。 RGB-D相机模型RGB-D 相机能够主动测量每个像素的深度，比双目相机通过视差计算更为主动。相比较单目相机，RGB-D相机没有复杂的深度恢复过程，使得算法更为简单；相较其它于双目相机，RGB-D相机有着更好的经济性，节省了不少成本。但是 RGB-D 相机的深度测量范围有限，只能用于室内，从一定程度上限制了其适用性。RGB-D相机向探测目标发射一束光线，根据返回的结构光图案，计算物体与自身之间的距离。在测量完深度后，自己完成深度与彩色图像像素之间的配对，输出一一对应的彩色图和深度图。之后通过得到的距离和色彩信息，计算像素的三维相机坐标，进行点云构建。 ORB特征提取和匹配直接从图像本身考虑运动估计会比较复杂，也会消耗大量计算资源，所以一般采用选取图像中比较有代表性的点，在这些点的基础上讨论相机的位姿变化并进行定位。特征点由关键点和描述子两部分组成。视觉领域常用的特征检测算法有SIFT、SURF、ORB等。SIFT和SURF算法提取效率和匹配效率都不高，本实验选择实时性更好的ORB (Oriented FAST and Rotated BRIEF) 特征。 ORB算法是Ethan Rublee在2011年提出的，是一种新的特征检测和描述算法。它改进了FAST检测子，并采用速度极快的BRIEF描述子，使图像提取环节得到加速。 FAST主要检测局部像素灰度变化过于明显的地方，如果一个像素和邻域的像素差别比较大，那么他更可能是角点。ORB中对原始的FAST进行改进，ORB指定了要提取的角点数量N，对原始的FAST角点分别计算Harris响应值，然后取Top-N个具有最大响应值得角点作为最终的角点集合。 另外ORB使FAST角点具有尺度和旋转的描述。通过对图像进行不同层次的降采样，获得不同分辨率的图像，并在每一层次进行角点检测得到尺度不变性；特征旋转通过灰度质心法 (Intensity Centroid) 实现： 定义图像块的矩为 通过矩可以找到图像块的质心 连接图像块的几何中心O与质心C，得到从O到C的方向向量，则特征点的方向可以定义为 通过以上方法，FAST具备尺度和旋转描述 本实验采用暴力匹配 (Brute-Force Matcher) 的方法，计算每一个特征点与所有描述子的距离，然后排序。由于描述子距离表示了两个特征之间的相似程度，所以取最近的作为特征点。对于二进制描述子BRIEF采用汉明距离 (Hamming distance) 作为度量。 PnP位姿估计PnP (Perspective-n-Point) 是求解三维到二维点对运动的方法，不需要使用对极约束（存在初始化，纯旋转和尺度问题，且一般需要8对点），可以在较少的匹配点（最少3对点）中获得较好的运动估计。特征点的三维位置可以直接由RGB-D相机的深度图确定。 常用的PnP问题求解有3对点估计位姿P3P、直接线性变换 (DLT) 、EPnP (Efficient PnP) 、UPnP以及非线性优化建立最小二乘求解 (Bundle Adjustment)。本实验采用OpenCV提供的EPnP筛选匹配点来求解相机位姿。将数据集中相邻两帧图像之间进行比较，确认相机的旋转参数和平移参数。 场景地图重建根据估算的相机位姿记录下的相机旋转平移参数，即相机的内参数和外参数，将RGB-D数据转化为点云 (Point Cloud)，然后通过PCL (Point Cloud Library) 进行拼接，最后得到由离散点组成的点云地图。把生成的点云地图以PCD格式存储，可通过PCL可视化程序打开相应文件。 后端优化Eigen：C++开源线性代数库，提供有关矩阵的线性代数运算。g2o：C++开源框架，利用图优化框架对PnP和位姿图进行优化，使用Eigen进行矩阵计算。PCL：C++开源编程库，实现了大量点云相关的通用算法和高效数据结构，涉及到点云获取、滤波、分割、配准、检索、特征提取、识别、追踪、曲面重建、可视化等。 实验结果通过FAST计算出的所有特征结点并通过BRIEF描述子进行配对暴力匹配计算特征点和描述子的距离，进行优化后筛选有效的特征点通过PnP算法估计相机的匹配点并计算出相机的旋转参数R和位移参数t将Tum数据集中的图片信息和深度信息进行两两帧特征提取和匹配，得到一组特征点和相机的位姿变换矩阵，利用PCL进行点云地图构建 总结关键点的提取和描述子的计算非常耗时，尽管ORB已经做到了一定的优化，但进行特征提取仍然会占去实时三维建图的大部分时间。一幅图可以有几十万个像素，只提取特征点会丢弃大部分有用的图像信息，另外面对没有明显纹理的场景，室外亮环境，现有的RGB-D和PnP方案明显还有待完善的地方。两辆帧的比较只能满足局部地图的匹配和优化，面对一个完整的场景还需要对全局进行更加真实和实时的建模。点云建图也需要利用如深度滤波等滤波算法对结果进行优化，最终达到对相机拍摄到的场景进行半稠密地图和稠密地图重建的效果。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 layoutit 设计简易留言板功能]]></title>
    <url>%2F2018%2F11%2F18%2Flayoutit%2F</url>
    <content type="text"><![CDATA[-基础练习-Layoutit是基于bootstrap2.0的一个可视化布局模板, 可以点击模板里的文字进行修改, 也可以通过点击弹出的编辑框进行富文本修改. 拖动区块能实现排序。尝试用Layoutit进行快速可视化布局，练习PHP的_POST和_GET，后台数据用文件存储，未使用数据库 后台步骤 创建msg.md，将文件中的内容创建成 PHP 的值，读取到$msgs：$msgs=unserialize($string); header('content-type:text/html;charset=utf-8');date_default_timezone_set('PRC');$filename="msg.md";$msgs=[];//检测文件是否存在if(file_exists($filename))&#123; //读取文件中的内容 $string=file_get_contents($filename); if(strlen($string)&gt;0)&#123; $msgs=unserialize($string); &#125;&#125; 检测到用户提交留言 读取$username, $title, $content, $time 组成关联数组: $data=compact(&#39;username&#39;,&#39;title&#39;,&#39;content&#39;,&#39;time&#39;); 写入新的数据到$msgs: array_push($msgs,$data); 产生一个存储的值: $msgs=serialize($msgs); 报告留言成功或失败 if(isset($_POST['pubMsg']))&#123; $username=$_POST['username']; $title=strip_tags($_POST['title']); $content=strip_tags($_POST['content']); $time=time(); //将其组成关联数组 $data=compact('username','title','content','time'); array_push($msgs,$data); $msgs=serialize($msgs); if(file_put_contents($filename,$msgs))&#123; echo "&lt;script&gt;alert('留言成功！');location.href='22-msg.php';&lt;/script&gt;"; &#125;else&#123; echo "&lt;script&gt;alert('留言失败！');location.href='22-msg.php';&lt;/script&gt;"; &#125;&#125; 将$msgs中的内容显示在留言板上 检测到$msgs存在且数组有内容 将$msgs中的所有数组键名按顺序读取，分别在网页中输出：foreach($msgs as $val) &lt;?php if(is_array($msgs)&amp;&amp;count($msgs)&gt;0):?&gt;...&lt;?php $i=1;foreach($msgs as $val):?&gt; &lt;tr class="success"&gt; &lt;td&gt; &lt;?php echo $i++;?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo $val['username'];?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo $val['title'];?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo date("m/d/Y H:i:s",$val['time']);?&gt; &lt;/td&gt; &lt;td&gt; &lt;?php echo $val['content'];?&gt; &lt;/td&gt; &lt;/tr&gt;&lt;?php endforeach;?&gt;&lt;?php endif;?&gt; 表格输出 编号 用户 标题 时间 内容 1 KevinW test 11/18/2018 15:59:25 测试留言 Layoutit页面设计 &lt;/head&gt; Kevin_W的留言板-V1.1.0 Hello, Layoutit! 这是一个可视化布局模板, 你可以点击模板里的文字进行修改, 也可以通过点击弹出的编辑框进行富文本修改. 拖动区块能实现排序. 参看更多 » 请留言 用户 标题 内容 L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":100,"height":200},"mobile":{"show":true},"log":false}); msg.phpmsg.md]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>bootstrap2.0</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP & MySQL learning notes (2)]]></title>
    <url>%2F2018%2F11%2F05%2Fphp-notes%2F</url>
    <content type="text"><![CDATA[-基础笔记-慕课网 PHP基础语法巩固(2) 课堂笔记，包含基本语法，变量和数据和函数等细碎的摘要 PHP使用环境和IDE LAMP(build): Linux+Apache+MySQL+PHP LNMP: Linux+Nginx+MySQL+PHP LNMPA: Linux+Nginx+MySQL+PHP+Apache WAMP(build): Window+Apache+MySQL+PHP 集成环境: xampp, wampserver, phpstudy IDE: vscode,Atom, Sublime Text3, PHPStorm, ZendStudio 基础语法 标准风格：&lt;?php 代码段; ?&gt;如果文档中只有PHP代码，结束标记要省略掉如果文档中不只有PHP代码，一定要保证PHP的开始和结束标记成对出现，可以出现任意位置，任意多次都可以 短风格：&lt;? 代码段; ?&gt;需要配置PHP配置文件php.ini中short_open_tag=On,重启Apache服务器即可 ASP风格：&lt;% 代码段; %&gt;需要配置PHP配置文件php.ini中asp_tags=On,重启Apache服务器即可 常量 &amp; 变量定义常量 define($name, $value) const NAME=值&lt;/br&gt;常量名称不加$常量名称最好大写，以字母或者下划线开始常量默认区分大小写常量作用域是全局常量一经定义，在脚本执行期间是不能改变的常量的值可以是标量类型，也可以是数组&lt;/br&gt; - constant($name) //根据常量的名称获取常量的值- defined($name) //检测常量名称是否存在，如果存在返回true，否则返回false- get_defined_constants() //返回的是包含系统常量和自定义常量的数组 魔术常量 __LINE__ //得到当前的行号 __FILE__ //得到当前文件的完整绝对路径和文件名 __DIR__ //得到文件的完整绝对路径 __FUNCTION__ //得到当前函数的名称 __CLASS__ //得到当前类的类名 __METHOD__ //得到当前类的方法名称 __TRAIT__ //得到当前的TRAIT名称 __NAMESPACE__ //得到当前明明空间的名称 定义变量 通过美元$变量名称来表示变量 PHP是弱类型语言，可以声明变量在使用，也可以不声明，可以一次声明一个，也可以一次声明多个 变量命名法 驼峰标记法小骆驼: firstName,lastName,zendControllerFront大骆驼: irstName,LastName,ZendControllerFront 下划线法first_name,last_name,zend_controller_front 预定义变量 $GLOBALS //超全局变量，包含以下所有的预定义变量 $_SERVERS //服务器和执行环境信息变量 $_ENV //环境变量 $_COOKIE //HTTP Cookies $_SESSION //HTTP Session变量 $_FILES //文件上传信息变量 $_GET[&#39;名称&#39;] //主要接收以?形式传递的数据，像表单以get形式发送数据，包括像超链接典型的?形式传递参数 $_POST[&#39;名称&#39;] //主要接收表单以post形式发送的数据 $_REQUEST //$_GET+$_POST+$_COOKIE 数据类型 &amp; 转换临时转换整型: (int)$变量名称|(integer)$变量名称浮点型: (float|double|real)$变量名称字符型: (string)$变量名称布尔型: (bool|boolean)$变量名称空: (unset)$变量名称数组: (array)$变量名称对象: (object)$变量名称 通过系统函数实现intval($var) //返回变量转换成整型之后的值floatval($var)|doubleval($var) //返回变量转换成浮点型的值strval($var) //返回变量转换成字符串的值boolval($var) //返回变量转换成布尔类型的值 永久转换settype($var,$type) //设置变量的类型gettype($var) //返回变量的类型 函数函数变量局部变量 局部动态变量: 变量只在函数内部执行，执行完毕则被销毁 局部静态变量: 在函数内部设置static时，执行完毕变量不被销毁 全局变量: 使用global，在函数内部定义全局变量，当函数执行时先调用函数外面已经定义好的变量再执行，如函数内部有重复定义相同变量不同值，执行出的是函数内部修改过的值 参数传递 值传递: 在函数内部修改变量的值的情况下，在函数调用时调用函数外部的变量，值不变 引用传递: 在函数内部修改变量的值的情况下，在函数调用时，函数的参数前面加一个&amp;符号，值发生改变 在对象中，不加&amp;符号，对象的值也会发生改变 堆内存: 存放占用内存比较大的，如对象 new xxx() 栈内存: 存放基本类型 $obj 可变参数列表 func_num_args：实参个数； func_get_arg：返回某一个实参，必须事实参数组的索引； func_get_args：返回实参数组; 可以返回整型，字符串型，数组等数据类型 复杂函数类型可变函数：通过变量改变函数的名字并调用，让函数的调用更具有多样性 匿名函数：使用变量 = function(){}; ，调用时也是用变量加小括号来进行调用，变量后面要加上分号结尾声明一个函数不给函数起名字，用来以后做回调函数时用 嵌套函数访问外部局部变量：变量名1 = function() use ($变量名2){}; 系统库函数int strlen(string $str) //返回字符串长度string strtolower(string $str) //转换成小写string strtoupper(string $str) //转换成大写string ucfirst(string $str) //句首字母转换成大写string ucwords(string $str) //每个单词首字母转换成大写mixed str_replace(mixed $search, mixed replace, mixed $subject, [int &amp;$count]) //实现字符替换，区分大小写mixed str_ireplace(mixed $search, mixed replace, mixed $subject, [int &amp;$count]) //实现字符替换，不区分大小写float floor(float $svalue) //舍去float ceil(float $svalue) //进位int mt_rand(int $min, int $max) //随机数，比rand()更好 数组创建数组 通过array()形式 array()空数组array(值,…)下标连续的索引数组，下标从0开始array(键名=&gt;键值,…)指定下标的索引数组、关联数组、混合数组通过[]的形式定义数组，代替array() 通过[ ]动态创建 $数组名称[]=值 //下标连续的索引数组$数组名称[键名]=值 //指定下标的索引数组和关联数组 通过range()和compact()快速创建 range() //快速创建下标连续的索引数组compact() //快速创建关联数组,只能写已经存在的变量名称，不能加$ 通过define(), const定义常量数组 数组转换临时转换: (array)$var永久转换: settype($var,$type) 数组运算符+ 合并数组，如果键名相同，使用前面数组的键值== 只比较键名和键值是否相同，如果相同返回true，否则返回false=== 既要比较键名和键值是否相同，还要比较类型和顺序 数组遍历通过foreach遍历数组foreach($数组名称 as $val)&#123;循环体;&#125; //只要键值foreach($数组名称 as $key=&gt;$val)&#123;循环体;&#125; //既要键名又要键值foreach($数组名称 as $key=&gt;&amp;$val)&#123;循环体;&#125; //引用传递 深入理解PHP原理之foreach 可以通过:和endforeach代替{ } PHP7中foreach的改变 foreach遍历对数组内部指针不再起作用 按照值进行遍历的时候，foreach操作的值是数组的副本 按照引用进行遍历的时候，有更好的迭代特性，在遍历体内修改数组对遍历有影响 通过指针函数遍历key($array) //得到当前指针所在位置的键名current($array) //得到当前指针所在位置的键值next($array) //将数组指针向下移动一位，返回当前指针所在位置的键值，否则返回falseprev($array) //将数组指针向上移动一位，返回当前指针所在位置的键值，否则返回falseend($array) //将数组指针移动到末尾，返回当前指针所在位置的键值，否则返回falsereset($array) //将数组指针移动到开始，返回当前指针所在位置的键值，否则返回false 通过each()和list()函数遍历数组each()list() 数组库API创建数组操作range($min,$max[,$step=1]):快速创建下标连续的索引数组compact($varname,$varname...):快速创建关联数组array_fill($start_index,$num,$value):用给定的值填充数组array_fill_keys($keys,$value):使用指定的键和值填充数组array_combine($keys,$values):创建一个数组，用一个数组的值作为其键名，另外一个值作为其键值 键值相关操作count($var[,$mode=COUNT_NORMAL])/sizeof():计算数组中的单元数目或对象中的属性个数 array_keys($array):取得数组的键名作为下标连续的索引数组返回array_values($array):取得数组的键值作为下标连续的索引数组返回array_flip($array):交换数组中的键名和键值in_array($search,$array[,$strict]):检测数组中是否存在某个值array_search($search,$array[,$strict]):在数组中搜索给定的值，如果成功则返回相应的键名array_key_exists($search,$array):检查给定的键名或索引是否存在于数组中array_reverse($array[,$preserve_keys=false]):数组倒置shuffle($array):打乱数组的元素array_rand($array[,$num_req=1]):随机取出数组的键名array_unique($array[,$sort_flag=SORT_STRING]):移除数组中重复的值array_sum($array):统计数组中元素值的总和array_product($array):计算数组中所有值的乘积array_count_values($array):统计数组中值出现的次数extract($array[,$extract_type=EXTR_OVERWRITE[,$prefix=null]]):从数组中将变量导入到当前的符号表 array_pad($array,$size,$value):用值将数组填补到指定长度 数组指针函数key($array):得到当前指针所在位置元素的键名current($array)|pos($array):得到当前指针所在位置元素的键值next($array):将数组指针向下移动一位，并且返回当前指针所在位置元素的键值prev($array):将数组指针向上移动一位，并且返回当前指针所在位置元素的键值end($array):将数组指针移动倒数组的末尾，并且返回当前指针所在位置元素的键值reset($array):将数组指针移动到数组的开始，并且返回当前指针所在位置元素的键值each($array):返回数组中当前的键值对，并将数组指针向下移动一位list($var,...):将数组中元素的值赋给对应的变量array_unshift($array,$value...):在数组开头插入一个元素或者多个元素array_shift($array):弹出数组的第一个元素array_push($array,$value...):在数组末尾压入一个元素或者多个元素array_pop($array):弹出数组的最后一个元素 数组的排序函数sort($array[,$sort_flag=SORT_REGULAR]):对数组的键值按照升序排列，不保留键名rsort($array[,$sort_flag=SORT_REGULAR]):对数组键值按照降序排列，不保留键名asort($array[,$sort_flag=SORT_REGULAR]):对数组键值按照升序排列，保留键值对关系arsort($array[,$sort_flag=SORT_REGULAR]):对数组键值按照降序排列，保留键值对关系ksort($array[,$sort_flag=SORT_REGULAR]):对数组的键名按照升序排列krsort($array[,$sort_flag=SORT_REGULAR]):对数组的键名按照降序排列natsort($array):用自然排序法排序natcasesort($array):用自然排序算法对数组进行不区分大小写字母的排序 array_multisort($arr[,$arg=SORT_STRING...]):对多个数组或多维数组进行排序 数组的交集与差集array_diff($array1,$array2[...]):计算数组的差集array_diff_assoc($array1,$array2[,...]):带索引检查计算数组的差集 array_intersect($array1,$array2[...]):计算数组的交集array_intersect_assoc($array1,$array2[...]):带索引检查计算数组的交集 数组的拆分与合并array_slice($array,$offset[$length=null[,$preserve_keys=false]]):截取数组array_splice($array,$offset[,$length=0,$replacement]]):将数组中一部分去掉并用其它值替代array_merge($arr1[,$arr2...]):合并数组array_chunk($array,$size[,$preserve_keys=false]):将一个数组分割成多个array_column($array,$column_key[,$index_key]):返回数组中指定的一列 错误及常用命令 Parse error（解析错误）: syntax error(语法错误), unexpected ‘&lt;’, expecting end of file Notice(通知): Undefined variable（未定义的变量）: sdkljflskdjflksdjflksdjfklj Catchable fatal(致命) error: Object of class stdClass could not be converted to string Warning(警告): settype(): Invalid(非法) type&lt;/br&gt; header('content-type:text/html;charset=utf-8');date_defalut_timezone_set('PRC');echo($var,....) //输出一个或者多个字符串var_dump($var) //打印变量的详细信息,可以一次打印一个或者多个变量的详细信息print_r($var) //打印数组的信息unset($var,...) //销毁变量，可以一次销毁一个或者多个，销毁之后变量的值为nulltime() //返回当前的 Unix 时间戳is_[int|float|double|bool...]($var) //判断变量的类型isset() //检测变量是否存在function_exists() //判断函数谁否存在file_exists() //判断文件是否存在$var = file_get_contents($filename) //得到文件中的内容，返回的是字符串serialize() //产生一个可存储的值的表示unserialize() //从已存储的表示中创建 PHP 的值setcookie(string $name, string $value, int $expire = 0, string $path = "", string $domain = "") //设置coockie：$name名称 $value值 $expire生命周期 $path可用路径 $domain可用域名范围$var = strip_tags() //从字符串中去除 HTML 和 PHP 标记]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adobe 2019 crack]]></title>
    <url>%2F2018%2F11%2F01%2FAdobe2019%2F</url>
    <content type="text"><![CDATA[Adobe 2019 全家桶和破解包百度云链接，所有安装包和破解未验证具体完整性和安全性，可能出现不完全破解，请谨慎使用文章内容和链接非原创，在此感谢 vposy 胡萝卜周 和 painter 大神们，还有学校 摄影工作室 的小伙伴们。关于破解的最新内容会搬运过来同步更新，不一定及时，有需要可以去关注一下大神们微博：vposy，胡萝卜周，twitter：@painter701 2月更新 转自微博 2.18 SP版已更新，为 Illustrator CC 2019 添加了库功能。Photoshop CC 2019 直接支持视频模块，不再需要登录后激活 2.7 Adobe Lightroom Classic CC 8.2 2.6 Adobe Photoshop CC 2019 (20.0.3.24950) 2.4 CC 2018 WIN SP版/大师版，CC 2019 WIN/MAC SP版/大师版 1月更新 1.31 Camera Raw CC 11.2.0.36 ​​​​ 1.12 为 Animate、Dreamweaver、Illustrator、InCopy、InDesign、Lightroom Classic 添加了文件夹图标 1.10 Adobe Photoshop CC 2019 (20.0.2.22488) 12月更新 12.22 AE16.0.1.48修正HEVC,建议按住ctrl+alt+shift启动程序重置一次 PR修正主页 12.13 Adobe Acrobat Pro DC 2019 连续版 (2019.010.20064) SP 2018.12.13更新 11月更新 11.11 Lightroom Classic 8.0 要求重新登录，但不影响正常使用，功能完整。 11.8 Adobe Photoshop CC 2019.0.1 (20.0.1.17836) 11.2 更新 Adobe Bridge CC 2019.0.1 (9.0.1.216) 更新 Adobe InDesign CC 2019.0.1 (14.0.1.202) 更新 Adobe Media Encoder CC 2019.0.1 (13.0.1.12) 更新 Adobe Premiere Pro CC 2019.0.1 (13.0.1.13) 到10月28日，目前除Lightroom Classic CC没有照片编辑功能外，vposy破解的版本其它貌似都能勉勉强强使用，具体会出现的BUG和解决方案也会持续更新出来（如果有的话）下载链接vposy的原版和SP版（只有win10）百度云下载链接：https://pan.baidu.com/share/init?surl=F1iCpjajAz-Ez5QsJZP5zQhttps://pan.baidu.com/s/1F1iCpjajAz-Ez5QsJZP5zQ提取密码: ewyu vposy的 Adobe CC 2018 大师版百度云下载链接：https://pan.baidu.com/s/1dio1Z4提取密码：w7i4 ZerOCod3 文件替换破解 百度云下载链接：https://pan.baidu.com/s/11msujRxnXgl5wJpHNjd6YA提取码: xjew 破解文件为.exe文件，将Adobe根目录下的文件替换成破解文件就行 或者可以下载ZerOCod破解包合集。https://pan.baidu.com/s/1W3Jnd8w2wMLTVHlsrvYQhw 提取码: zi2u CC Maker 早期版本汇总 百度云下载链接：链接: https://pan.baidu.com/s/14ubOSVQkltVFarvbB7vUXQ提取码: cuvr CC Maker汇总了早期版本的Adobe软件下载，早期版本可用amtlib破解程序破解 关于Adobe CC 2019 系统需求WIN10最新版本。旧版WIN10，WIN8.1不支持，WIN7部分支持（不建议） CC2019开始ADOBE抛弃了十几年的amtlib，新激活模块内置于主程序，正版必须登录ID，所有之前的破解程序都没用,新版本的破解也只是是跳过ID登录，没有授权信息 WIN新版破解会很快，但MAC版短时间就难说了。全系列完美破解短时间就不要想了，只有本地功能，与ACC有关的在线功能如库能否正常使用取决于ADOBE。ACC需单独破解 官方今年还没有给出完整版地址，同时也封掉了CCP。新版版发布时间还不长，不清楚官方是否不打算给完整包了。 新版本BUG问题可以去Adobe官方社区论坛上讨论 painter的emu 他本人说遇到了一点困难，至少目前没有 至少他是想在尽量不动主程序的情况下模拟ID授权激活的，而不是简单的跳过ID登录，完全规避无授权BUG，具体情况可以自己去推上问他]]></content>
      <categories>
        <category>Adobe</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[breast-cancer-diagnose from Kaggle]]></title>
    <url>%2F2018%2F10%2F28%2Fcancer-diagnose%2F</url>
    <content type="text"><![CDATA[学校人工智能导论课程小组作业，乳腺癌检测（from Kaggle）。作业训练基础的数据清理，数据特征分类，验证不同的分类算法之间的分类效果 训练数据集：[Breast Cancer Wisconsin (Diagnostic) Data Set](https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+%28Diagnostic%29) UCI关于此数据集有两份，本实验使用较为完整的一份 实验数据为文本数据，数据量是为569的小型数据，有部分数据缺失 步骤中降维部分，violin图部分为半成品，效果并不显著，可以自动忽略 Attribute Information: 1) ID number 2) Diagnosis (M = malignant, B = benign) 3) Ten real-valued features are computed for each cell nucleus:a) radius (mean of distances from center to points on the perimeter)b) texture (standard deviation of gray-scale values)c) perimeterd) areae) smoothness (local variation in radius lengths)f) compactness (perimeter^2 / area - 1.0)g) concavity (severity of concave portions of the contour)h) concave points (number of concave portions of the contour)i) symmetryj) fractal dimension (“coastline approximation” - 1) 以下列举部分实验结果，具体实现步骤&gt;&gt; breast-cancer-diagnose.ipynb downloadLogisticRegression (逻辑斯蒂回归 分类器) from sklearn.linear_model import LogisticRegressionLR = LogisticRegression()LR.fit(X_train, y_train)LR.predict(X_test)LR.score(X_test,y_test) Out: 0.9883040935672515 结论： 通过比较，逻辑斯蒂模型比随机梯度下降模型在测试集上表现有更高的准确性，因为逻辑斯蒂采用解析的方式精确计算模型参数，而随机梯度下降采用估计值 特点分析： 逻辑斯蒂对参数的计算采用精确解析的方法，计算时间长但是模型性能高，随机梯度下降采用随机梯度上升算法估计模型参数，计算时间短但产出的模型性能略低，一般而言，对于训练数据规模在10万量级以上的数据，考虑到时间的耗用，推荐使用随机梯度算法 SGDClassifier (梯度下降 分类器)from sklearn.linear_model import SGDClassifier SGD = SGDClassifier(loss=&apos;hinge&apos;, penalty=&apos;l2&apos;, alpha=0.001, l1_ratio=0.15, fit_intercept=True, max_iter=None, tol=None, shuffle=True, verbose=0, epsilon=0.1, n_jobs=1, random_state=None, learning_rate=&apos;optimal&apos;, eta0=0.0, power_t=0.5, class_weight=None, warm_start=False, average=False, n_iter=None)SGD.fit(X_train,y_train)SGD.predict(X_test)SGD.score(X_test,y_test) Out: 0.9824561403508771 LinearRegression (线性回归 分类器)from sklearn.linear_model import LinearRegression LR2 = LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=1)LR2.fit(X_train,y_train)LR2.predict(X_test)LR2.score(X_test,y_test) Out: 0.8739645029687063 KNeighborsClassifier (k近邻 分类器)from sklearn.neighbors import KNeighborsClassifier KNN = KNeighborsClassifier(n_neighbors=5, weights=&apos;uniform&apos;, algorithm=&apos;auto&apos;, leaf_size=30, p=2, metric=&apos;minkowski&apos;, metric_params=None, n_jobs=1, **kwargs)KNN.fit(X_train,y_train)KNN.predict(X_test)KNN.score(X_test,y_test) Out: 0.9883040935672515 GaussianNB (朴素贝叶斯 分类器)from sklearn.naive_bayes import GaussianNB GNB = GaussianNB(priors=None)GNB.fit(X_train,y_train)GNB.predict(X_test)GNB.score(X_test,y_test) Out: 0.9766081871345029]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thinkpad fingerprint device on Linux]]></title>
    <url>%2F2018%2F10%2F28%2Ftp-print%2F</url>
    <content type="text"><![CDATA[Thinkpad 在Linux下新版本指纹识别驱动的安装与指纹实现管理员验证 1.Check your finger print devicelsusb example in device ID: 138:0090 and show device ID (for me) Bus xxx Device xxx: ID 138a:0090 Validity Sensors, Inc. here are some integrated fingerprint Reader in thinkwiki USB ID Reader Software 08ff:1600 Authentec AES1610 fprint 08ff:2580 Authentec AES2501 fprint 08ff:2810 Authentec 2810 supported by libfprint v0.5.0 onwards released December 2012 138a:0017 Validity Sensors, Inc. Fingerprint Reader (to test) Driver Patch as use case with T440 or gist sample Supported by libfprint v0.6.0 138a:0090 Validity Sensors RE work for validity90 fingerprint reader 2.Install packages 2.1 Packages for Fingerprint GUI for Ubuntu 14.04, 16.04, 17.10, 18.04 and any distribution based thereupon ! check if your device is in supported readers then install 2.2 Install fprintd (for me in device 138a:0090) read the guide: Validity and libfprint in github for ubuntu/linuxmint sudo apt install fpirntdsudo add-apt-repository -y ppa:3v1n0/libfprint-vfs0090sudo apt updatesudo apt install libpam-fprintd for archlinux sudo pacman -S fprintdyaourt -S libfprint-vfs0090-git 3.Enroll your finger print add your signature for a finger (touch your finger device) fprintd-enroll ! use sudo fprintd-enroll may have some bug if not work for finger in &#123;left,right&#125;-&#123;thumb,&#123;index,middle,ring,little-finger&#125;; do fprintd-enroll -f "$finger" "$USER"; done e.g for finger in {left,right}-{thumb,{index,middle,ring,little-finger}; do fprintd-enroll -f &quot;right-index-finger&quot; &quot;kevin&quot;; done ! here has a bug, you may need to add 10x4 times to add finger signature 4.Login configuration read the guide in archlinux wiki 4.1 For linuxmint Add pam_fprintd.so as sufficient to the top of the auth section of /etc/pam.d/runuser sudo nano /etc/pam.d/runuser---auth sufficient pam_fprintd.soauth sufficient pam_rootok.sosession optional pam_keyinit.so revoke... 4.2 For archlinux Add pam_fprintd.so as sufficient to the top of the auth section of /etc/pam.d/system-local-login 5.Reboot check the light of finger device in linuxmint, print finger then click sign in in archlinux, click enter then print finger]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Linux_device</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP & MySQL learning notes (1)]]></title>
    <url>%2F2018%2F10%2F28%2Fw3school-php%2F</url>
    <content type="text"><![CDATA[W3school PHP 和 MySQL的初次学习包括 PHP基础语法，表单处理，PHP连接MySQL数据库操作 1.PHP基础PHP 脚本以 &lt;?php 开头，以 ?&gt; 结尾,语句以分号结尾: &lt;?php// 此处是 PHP 代码;?&gt; // 这是单行注释 # 这也是单行注释 / /这是多行注释块 变量 变量以 $ 符号开头，其后是变量的名称 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线 A-z、0-9 以及 _ 变量名称对大小写敏感（$y 与 $Y 是两个不同的变量） 松散型语言，不必告知 PHP 变量的数据类型 PHP global 关键词 global 关键词用于访问函数内的全局变量。 要做到这一点，请在（函数内部）变量前面使用 global 关键词 PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。 function myTest() &#123; global $x,$y; $y=$x+$y;&#125;function myTest() &#123; $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];&#125; PHP static 关键词 通常，当函数完成/执行后，会删除所有变量。不过，有时我需要不删除某个局部变量。实现这一点需要更进一步的工作。要完成这一点，请在您首次声明变量时使用 static 关键词 echo 和 print 之间的差异： echo - 能够输出一个以上的字符串 print - 只能输出一个字符串，并始终返回 1 PHP var_dump() 会返回变量的数据类型和值 PHP 对象 对象是存储数据和有关如何处理数据的信息的数据类型。 首先我们必须声明对象的类。对此，我们使用 class 关键词;然后我们在对象类中定义数据类型;然后在该类的实例中使用此数据类型 class Car&#123; var $color; function Car($color="green") &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125;&#125; strlen() 函数返回字符串的长度，以字符计 strpos() 函数用于检索字符串内指定的字符或文本 如需设置常量，请使用 define() 函数 - 它使用三个参数： 首个参数定义常量的名称 第二个参数定义常量的值 可选的第三个参数规定常量名是否对大小写不敏感。默认是 false。 PHP 字符串运算符 运算符 名称 例子 结果 . 串接 $txt1 = “Hello” $txt2 = $txt1 . “ world!” 现在 $txt2 包含 “Hello world!” .= 串接赋值 $txt1 = “Hello” $txt1 .= “ world!” 现在 $txt1 包含 “Hello world!” PHP 递增/递减运算符 运算符 名称 描述 ++$x 前递增 $x 加一递增，然后返回 $x $x++ 后递增 返回 $x，然后 $x 加一递增 —$x 前递减 $x 减一递减，然后返回 $x $x— 后递减 返回 $x，然后 $x 减一递减 在 PHP 中， array() 函数用于创建数组 在 PHP 中，有三种数组类型： 索引数组 - 带有数字索引的数组$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;SAAB&quot;); 关联数组 - 带有指定键的数组$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); 多维数组 - 包含一个或多个数组的数组 count() 函数用于返回数组的长度（元素数） 如需遍历并输出索引数组的所有值，您可以先count数组长度，再使用 for 循环 如需遍历并输出关联数组的所有值，您可以使用 foreach 循环 PHP foreach 循环 foreach 循环只适用于数组，并用于遍历数组中的每个键/值对。 foreach ($array as $value) &#123;code to be executed;&#125; PHP - 数组的排序函数 sort() - 以升序对数组排序 rsort() - 以降序对数组排序 asort() - 根据值，以升序对关联数组进行排序 ksort() - 根据键，以升序对关联数组进行排序 arsort() - 根据值，以降序对关联数组进行排序 krsort() - 根据键，以降序对关联数组进行排序 超全局变量： $GLOBALS 引用全局作用域中可用的全部变量$_SERVER 保存关于报头、路径和脚本位置的信息$_REQUEST 用于收集 HTML 表单提交的数据$_POST 广泛用于收集提交 method=&quot;post&quot; 的 HTML 表单后的表单数据。$_POST 也常用于传递变量$_GET 用于收集提交 HTML 表单 (method=&quot;get&quot;) 之后的表单数据,也可以收集 URL 中的发送的数据$_ENV$_COOKIE$_SESSION &lt;html&gt;&lt;body&gt;&lt;form method="post" action="&lt;?php echo $_SERVER['PHP_SELF'];?&gt;"&gt;Name: &lt;input type="text" name="fname"&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;?php$name = $_REQUEST['fname'];echo $name;?&gt;&lt;/body&gt;&lt;/html&gt; 2.PHP表单HTML表单处理表单界面 &lt;html&gt;&lt;body&gt;&lt;!--form创建表单--&gt;&lt;form action="welcome.php" method="post"&gt;Name: &lt;input type="text" name="name"&gt;&lt;br&gt; &lt;!--文本--&gt;E-mail: &lt;input type="text" name="email"&gt;&lt;br&gt;Gender: &lt;!--选择--&gt;&lt;input type="radio" name="gender" value="female"&gt;Female&lt;input type="radio" name="gender" value="male"&gt;Male&lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; welcome.PHP &lt;html&gt;&lt;body&gt;Welcome &lt;?php echo $_POST["name"]; ?&gt;&lt;br&gt;Your email address is: &lt;?php echo $_POST["email"]; ?&gt;&lt;/body&gt;&lt;/html&gt; 可以将post换成get 后端GET &amp; POST $_GET 是通过 URL 参数传递到当前脚本的变量数组。 通过 GET 方法从表单发送的信息对任何人都是可见的（所有变量名和值都显示在 URL 中）。GET 对所发送信息的数量也有限制。限制在大于 2000 个字符。不过，由于变量显示在 URL 中，把页面添加到书签中也更为方便。 GET 可用于发送非敏感的数据。 $_POST 是通过 HTTP POST 传递到当前脚本的变量数组。 通过 POST 方法从表单发送的信息对其他人是不可见的（所有名称/值会被嵌入 HTTP 请求的主体中），并且对所发送信息的数量也无限制。 一般偏向于POST发送表单数据 表单安全验证&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;&gt; $_SERVER[&quot;PHP_SELF&quot;] 是一种超全局变量，它返回当前执行脚本的文件名 htmlspecialchars() 函数把特殊字符转换为 HTML 实体 $_SERVER[&quot;PHP_SELF&quot;] 变量能够被黑客利用,使用了 PHP_SELF，用户能够输入下划线然后执行跨站点脚本（XSS）,通过使用 htmlspecialchars() 函数能够避免 $_SERVER[&quot;PHP_SELF&quot;] 被利用 利用php函数检查表单 （通过 PHP trim() 函数）去除用户输入数据中不必要的字符（多余的空格、制表符、换行） （通过 PHP stripslashes() 函数）删除用户输入数据中的反斜杠（\） // 定义变量并设置为空值$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; $name = test_input($_POST["name"]); $email = test_input($_POST["email"]); $website = test_input($_POST["website"]); $comment = test_input($_POST["comment"]); $gender = test_input($_POST["gender"]);&#125;function test_input($data) &#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125; 必须输入字段增加了一些新变量：$nameErr、$emailErr、$genderErr 以及 $websiteErr。这些错误变量会保存被请求字段的错误消息。 还需要每个 $_POST 变量添加了一个 if else 语句。这条语句检查 $_POST 变量是否为空（通过 PHP empty() 函数）。如果为空，则错误消息会存储于不同的错误变量中。如果不为空，则通过 test_input() 函数发送用户输入数据 $nameErr = $emailErr = $genderErr = $websiteErr = "";$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; if (empty($_POST["name"])) &#123; $nameErr = "Name is required"; &#125; else &#123; $name = test_input($_POST["name"]); &#125; if (empty($_POST["email"])) &#123; $emailErr = "Email is required"; &#125; else &#123; $email = test_input($_POST["email"]); &#125; if (empty($_POST["website"])) &#123; $website = ""; &#125; else &#123; $website = test_input($_POST["website"]); &#125; if (empty($_POST["comment"])) &#123; $comment = ""; &#125; else &#123; $comment = test_input($_POST["comment"]); &#125; if (empty($_POST["gender"])) &#123; $genderErr = "Gender is required"; &#125; else &#123; $gender = test_input($_POST["gender"]); &#125;&#125; HTML显示错误消息在每个被请求字段后面增加了一点脚本。如果需要，会生成恰当的错误消息 Name: &lt;input type="text" name="name"&gt;&lt;span class="error"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt; //验证E-mail:&lt;input type="text" name="email"&gt;&lt;span class="error"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt;Website:&lt;input type="text" name="website"&gt;&lt;span class="error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;label&gt;Comment: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;/textarea&gt;Gender:&lt;input type="radio" name="gender" value="female"&gt;Female&lt;input type="radio" name="gender" value="male"&gt;Male&lt;span class="error"&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt;&lt;input type="submit" name="submit" value="Submit"&gt; 验证输入数据验证名字：preg_match() 函数检索字符串的模式，如果模式存在则返回 true，否则返回 false $name = test_input($_POST["name"]);if (!preg_match("/^[a-zA-Z ]*$/",$name)) &#123; $nameErr = "只允许字母和空格！";&#125; 验证email $email = test_input($_POST["email"]);if (!preg_match("/([\w\-]+\@[\w\-]+\.[\w\-]+)/",$email)) &#123; $emailErr = "无效的 email 格式！";&#125; 验证URL $website = test_input($_POST["website"]);if (!preg_match("/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i",$website)) &#123; $websiteErr = "无效的 URL";&#125; HTML保留表单中的值在输入字段的 value 属性中增加了一小段 PHP 脚本：name、email 以及 website 在 comment 文本框字段中，把脚本放到了 &lt;textarea&gt; 与 &lt;/textarea&gt; 之间;这些脚本输出 $name、$email、$website 和 $comment 变量的值。 要显示选中了哪个单选按钮，操作 checked 属性（而非单选按钮的 value 属性） Name: &lt;input type="text" name="name" value="&lt;?php echo $name;?&gt;"&gt;E-mail: &lt;input type="text" name="email" value="&lt;?php echo $email;?&gt;"&gt;Website: &lt;input type="text" name="website" value="&lt;?php echo $website;?&gt;"&gt;Comment: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;?php echo $comment;?&gt;&lt;/textarea&gt;Gender:&lt;input type="radio" name="gender"&lt;?php if (isset($gender) &amp;&amp; $gender=="female") echo "checked";?&gt;value="female"&gt;Female&lt;input type="radio" name="gender"&lt;?php if (isset($gender) &amp;&amp; $gender=="male") echo "checked";?&gt;value="male"&gt;Male 完整代码&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.error &#123;color: #FF0000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;?php// 定义变量并设置为空值$nameErr = $emailErr = $genderErr = $websiteErr = "";$name = $email = $gender = $comment = $website = "";if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; if (empty($_POST["name"])) &#123; $nameErr = "姓名是必填的"; &#125; else &#123; $name = test_input($_POST["name"]); // 检查姓名是否包含字母和空白字符 if (!preg_match("/^[a-zA-Z ]*$/",$name)) &#123; $nameErr = "只允许字母和空格"; &#125; &#125; if (empty($_POST["email"])) &#123; $emailErr = "电邮是必填的"; &#125; else &#123; $email = test_input($_POST["email"]); // 检查电子邮件地址语法是否有效 if (!preg_match("/([\w\-]+\@[\w\-]+\.[\w\-]+)/",$email)) &#123; $emailErr = "无效的 email 格式"; &#125; &#125; if (empty($_POST["website"])) &#123; $website = ""; &#125; else &#123; $website = test_input($_POST["website"]); // 检查 URL 地址语法是否有效（正则表达式也允许 URL 中的斜杠） if (!preg_match("/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&amp;@#\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\/%=~_|]/i",$website)) &#123; $websiteErr = "无效的 URL"; &#125; &#125; if (empty($_POST["comment"])) &#123; $comment = ""; &#125; else &#123; $comment = test_input($_POST["comment"]); &#125; if (empty($_POST["gender"])) &#123; $genderErr = "性别是必选的"; &#125; else &#123; $gender = test_input($_POST["gender"]); &#125;&#125;function test_input($data) &#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125;?&gt;&lt;h2&gt;PHP 验证实例&lt;/h2&gt;&lt;p&gt;&lt;span class="error"&gt;* 必需的字段&lt;/span&gt;&lt;/p&gt;&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt; 姓名：&lt;input type="text" name="name"&gt; &lt;span class="error"&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 电邮：&lt;input type="text" name="email"&gt; &lt;span class="error"&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 网址：&lt;input type="text" name="website"&gt; &lt;span class="error"&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; 评论：&lt;textarea name="comment" rows="5" cols="40"&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; 性别： &lt;input type="radio" name="gender" value="female"&gt;女性 &lt;input type="radio" name="gender" value="male"&gt;男性 &lt;span class="error"&gt;* &lt;?php echo $genderErr;?&gt;&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;input type="submit" name="submit" value="提交"&gt;&lt;/form&gt;&lt;?phpecho "&lt;h2&gt;您的输入：&lt;/h2&gt;";echo $name;echo "&lt;br&gt;";echo $email;echo "&lt;br&gt;";echo $website;echo "&lt;br&gt;";echo $comment;echo "&lt;br&gt;";echo $gender;?&gt;&lt;/body&gt;&lt;/html&gt; 3.mySQLPHP连接MySQL通过 mysql_connect() 函数完成 mysql_connect(&#39;servername&#39;,&#39;username&#39;,&#39;password&#39;); 参数 描述 servername 可选。规定要连接的服务器。默认是 “localhost:3306” username 可选。规定登录所使用的用户名。默认值是拥有服务器进程的用户的名称 password 可选。规定登录所用的密码。默认是 “” $con = mysql_connect("localhost","root","");if (!$con) &#123; die('Could not connect: ' . mysql_error()); //连接失败执行die &#125; 创建数据库用 mysql_query() 函数 mysql_query(&quot;CREATE DATABASE database_name&quot;,password) $con = mysql_connect('localhost','root','');if (!$con)&#123; die('Could not connect: ' . mysql_error()); &#125;if (mysql_query("CREATE DATABASE my_db",$con))&#123; //创建数据库 echo "Database created"; &#125;else&#123; echo "Error creating database: " . mysql_error(); &#125;mysql_close($con); 创建表创建表之前，必须首先选择数据库;通过 mysql_select_db() 函数选取数据库mysql_query() 函数添加 CREATE TABLE 语句 // Create table in databasemysql_select_db("DATABASE NAME", $con);$sql = "CREATE TABLE Persons(FirstName varchar(15),LastName varchar(15),Age int)";mysql_query($sql,$con); 表的主键和递增字段：主键字段通常是 ID 号，且通常使用 AUTO_INCREMENT 设置 AUTO_INCREMENT 会在新记录被添加时逐一增加该字段的值。要确保主键字段不为空，我们必须向该字段添加 NOT NULL 设置 personID int NOT NULL AUTO_INCREMENT 插入数据INSERT INTO table_name VALUES (value1, value2,....) SQL 语句对大小写不敏感。INSERT INTO 与 insert into 相同。 为了让 PHP 执行该语句，我们必须使用 mysql_query() 函数。该函数用于向 MySQL 连接发送查询或命令 mysql_select_db("DATABASE NAME", $con);mysql_query("INSERT INTO Persons (FirstName, LastName, Age)VALUES ('Peter', 'Griffin', '35')");mysql_close($con); 表单数据插入数据库 当用户点击上例中 HTML 表单中的提交按钮时，表单数据被发送到 “insert.php”。”insert.php” 文件连接数据库，并通过 $_POST 变量从表单取回值。然后，mysql_query() 函数执行 INSERT INTO 语句，一条新的记录会添加到数据库表中 mysql_select_db("DATABASE NAME", $con);$sql="INSERT INTO Persons (FirstName, LastName, Age)VALUES('$_POST[firstname]','$_POST[lastname]','$_POST[age]')"; //HTML表单中的数据if (!mysql_query($sql,$con))&#123;die('Error: ' . mysql_error());&#125;echo "1 record added";mysql_close($con) 查询数据SELECT column_name(s) FROM table_name 使用 mysql_fetch_array() 函数以数组的形式从记录集返回第一行 使用了 PHP 的 $row 变量 ($row[‘FirstName’] 和 $row[‘LastName’])输出每行的值 mysql_select_db("my_db", $con);$result = mysql_query("SELECT * FROM Persons");while($row = mysql_fetch_array($result)) &#123; echo $row['FirstName'] . " " . $row['LastName']; echo "&lt;br /&gt;"; &#125;mysql_close($con); 显示成表格样式 mysql_select_db("my_db", $con);$result = mysql_query("SELECT * FROM Persons");echo "&lt;table border='1'&gt; &lt;tr&gt; &lt;th&gt;Firstname&lt;/th&gt; &lt;th&gt;Lastname&lt;/th&gt; &lt;/tr&gt;"; while($row = mysql_fetch_array($result)) &#123; echo "&lt;tr&gt;"; echo "&lt;td&gt;" . $row['FirstName'] . "&lt;/td&gt;"; echo "&lt;td&gt;" . $row['LastName'] . "&lt;/td&gt;"; echo "&lt;/tr&gt;"; &#125;echo "&lt;/table&gt;";mysql_close($con); 如需选取匹配指定条件的数据，请向 SELECT 语句添加 WHERE 子句 SELECT column FROM table WHERE column operator value mysql_select_db("my_db", $con);$result = mysql_query("SELECT * FROM PersonsWHERE FirstName='Peter'"); ORDER BY 关键词用于对记录集中的数据进行排序 SELECT column_name(s) FROM table_name ORDER BY column_name ORDER BY 关键词，记录集的排序顺序默认是升序;可用DESC 关键词来设定降序排序 SELECT column_name(s) FROM table_name ORDER BY column_name DESC mysql_select_db("my_db", $con);$result = mysql_query("SELECT * FROM Persons ORDER BY age"); 修改数据UPDATE 语句用于在数据库表中修改数据 UPDATE table_name SET column_name = new_value WHERE column_name = some_value mysql_select_db("my_db", $con);mysql_query("UPDATE Persons SET Age = '36'WHERE FirstName = 'Peter' AND LastName = 'Griffin'");mysql_close($con); 删除数据DELETE FROM 语句用于从数据库表中删除记录 DELETE FROM table_name WHERE column_name = some_value mysql_select_db("my_db", $con);mysql_query("DELETE FROM Persons WHERE LastName='Griffin'");mysql_close($con);]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的欢迎界面]]></title>
    <url>%2F2018%2F10%2F28%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[description: 这是第一次是使用Hexo时Hexo展示的页面，为方便查询移动至此Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tips about building blog]]></title>
    <url>%2F2018%2F10%2F20%2Ftips-about-building-blog%2F</url>
    <content type="text"><![CDATA[安装hexo的笔记,不间断进行更新更新目录： 安装和部署必要模组 页面模板 写文章 本地查看和Github部署 分类和标签须知 标签插件 建立资源文件夹 更换Maupassant主题 增加右下角动图 添加pdf插件 安装字数统计插件 install nodejs npm git hexo 安装和部署必要模组install on Linuxsudo apt-get install -y nodejssudo apt-get install -y build-essentialsudo apt-get install -y npmsudo apt-get install git related modules npm install //install necessary componentsnpm install hexo-deployer-git --save // deploy to gitnpm install hexo-generator-feed --save // build RSSnpm install hexo-generator-sitemap --save // build sitemap deploy hexo open terminal &amp; cd to the right direction mkdir blognpm install hexo -ghexo -v //check infohexo init //initialize folderhexo g //Start processing add ssh keyssh-keygen -t rsa -C "your email address"cat /home/xxx/.ssh/id_rsa.pub //check your key load key to Github (default on Github &amp; default you can use Github) ssh -T git@github.com set id &amp; emailgit config --global user.name "your id"git config --global user.email "your email" install on Windows download nodejs and install download git and install Win+R open cmd to the right direction mkdir blognpm install hexo -ghexo -v //check infonpm install //install necessary componentshexo init //initialize folderhexo g //Start processing add related module &amp; ssh key &amp; set id+email (the same as linux) template 模板 各页面相对应的模板名称 模板 用途 回退 index 首页 post 文章 index page 分页 index archive 归档 index category 分类归档 archive tag 标签归档 archive write pages 写文章init pagehexo new post "post_name" edit title:date:categories:tags:description:###### tags 目前的标签 | Kaggle | Linux device | hexo | php | mysql | others | categories 目前的分类 Adobe: about any update &amp; crack of CC software notes: personal thoughts &amp; ideas others: just others study: study notes local server &amp; deploy 本地查看和部署hexo clean //clean cachehexo generate //generate static fileshexo seserver //localhost:4000hexo deploy //open server update notes 2019.2.14 更新 categories &amp; tags 分类和标签须知 只有文章支持分类和标签 分类具有顺序性和层次性,标签没有顺序和层次 Hexo不支持指定多个同级分类 categories:- Diarytags:- PS3- Games Tag Plugins 标签插件quote 在文章中插入引言，可包含作者、来源和标题 &#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; example &#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125; Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake code 插入代码&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; image 插入图片&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; link 插入链接&#123;% link text url [external] [title] %&#125; Assert fold 资源文件夹 如果需要插入图片,最简单的方法就是将它们放在 source/pic 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们. 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。需要使用标签插件 &#123;% asset_img example.jpg This is an example image %&#125;&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;... 2.18日更新 因NexT不可描述的页面无法跳转原因，更换主题到Maupassant，大道至简 给文章添加目录：开头加上 toc: true 首页自定义显示文章摘录：在摘录后加上&lt;!--more--&gt; 2.22日更新 增加萌宠或二次元动图hexo live2d插件 2.0Github地址 npm install --save hexo-helper-live2d然后挑一个npm install live2d-widget-model-xxxxx 向Hexo的 _config.yml 文件添加配置 live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-xxxxx display: position: right width: 150 height: 300 mobile: show: true 添加pdf插件npm install --save hexo-pdfhexo new page book .md文件中添加pdf 外部链接：&#123;% pdf http://xxx.pdf %&#125;本地连接：&#123;% pdf ./pdf名字.pdf %&#125; 安装字数统计插件npm i --save hexo-wordcount将自己所用主题中的 _config.yml 文件中的 wordcount 设置为true 增加instagram链接npm install hexo-tag-instagram --save &#123;% instagram post-url %&#125;or&#123;% instagram BXkz1bYB1-N %&#125;or&#123;% instagram false 50% https://www.instagram.com/p/BXkz1bYB1-N/ %&#125; —-Reference hexo.io cnblogs: hexo+Github搭建自己的博客]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to Kevin_W's attic,filled with whispers & murmurs]]></title>
    <url>%2F2018%2F10%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Kevin_W 创立于这个世界在10月10日，2018。 他可以是一本日志,也可以是一篇日记，一个仓库，或者一个告解室，一个树洞，亦或什么都不是。 但这里，的确是独立于外部的一个世界。 Kevin 不清楚这个世界能存在多久，会放置些什么，有多少谁在看，更新频率是多快，更新的知识有多深奥，只能保证这个世界创造的一切，都是十分重要的信息。 Kevin 也不清楚能把这个世界创造得多好，不清楚这个世界会往哪里发展，不清楚到底有多少个类似这样的平行世界，只能保证创造这个世界的Kevin 是最Kevin’s 的一个Kevin. Wubba lubba dub dubHey，what are you in for ?]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
</search>
