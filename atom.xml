<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MonoShow</title>
  
  <subtitle>Monologue from Kevin_W</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hyqskevin.github.io/"/>
  <updated>2020-11-23T05:38:22.078Z</updated>
  <id>https://hyqskevin.github.io/</id>
  
  <author>
    <name>Kevin W</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue功能实现和使用技巧</title>
    <link href="https://hyqskevin.github.io/2020/11/10/vue-notes/"/>
    <id>https://hyqskevin.github.io/2020/11/10/vue-notes/</id>
    <published>2020-11-10T02:20:03.000Z</published>
    <updated>2020-11-23T05:38:22.078Z</updated>
    
    <content type="html"><![CDATA[<p>汇总记录前端开发时，使用 Vue 框架遇到的功能实现和开发技巧。</p><a id="more"></a><h2 id="Vue-动态组件使用"><a href="#Vue-动态组件使用" class="headerlink" title="Vue 动态组件使用"></a>Vue 动态组件使用</h2><p>动态组件功能用于在不同组件之间进行动态切换，可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 is attribute 来实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `currentComponent` 改变时显示的组件同时改变</span></span><br><span class="line">&lt;component :is=<span class="string">"currentComponent"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;button @click=<span class="string">"(currentComponent === 'A') ? 'B':'A'"</span>&gt;Switch&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/引入组件A以及组件B</span></span><br><span class="line"><span class="regexp">import A from "./</span>a<span class="string">"</span></span><br><span class="line"><span class="string">import B from "</span>./b<span class="string">"</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  components: &#123;A, B&#125;,</span></span><br><span class="line"><span class="string">  data () &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      //默认显示组件A，若字符串为B则显示组件B,name为component声明</span></span><br><span class="line"><span class="string">      currentComponent: 'A'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>v-show，v-if，:is 之间的区别</li></ul><p><code>v-show</code> 会同时加载两个组件，两个组件的生命周期都会触发，会造成不必要的性能浪费，而且切换的时候不会再创造挂载一次，无法重新渲染。<br><code>v-if</code> 不会造成同时加载两个组件，但 v-if 每次切换都会创造挂载一次，如果没有重新渲染的需要，会造成性能浪费。<br><code>:is</code> 可以通过 keep-alive 标签缓存，被该标签包裹的组件会被缓存下来，每次点击都不会重新渲染，避免了重渲染导致的性能问题。<code>include</code> 和 <code>exclude</code> 属性也允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 逗号分隔字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"a,b"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (使用 v-bind) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"/a|b/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Array (use v-bind) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"['a', 'b']"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>动态路由用于把某种模式匹配到的所有路由，全都映射到同个组件，可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果。一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，可以在每个组件内使用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">routes: [</span><br><span class="line"><span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User &#125;,</span><br><span class="line">],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="页面跳转和导航"><a href="#页面跳转和导航" class="headerlink" title="页面跳转和导航"></a>页面跳转和导航</h2><h3 id="定义链接实现声明式导航"><a href="#定义链接实现声明式导航" class="headerlink" title=" 定义链接实现声明式导航"></a><router-link> 定义链接实现声明式导航</router-link></h3><p><code>&lt;router-link :to=&quot;...&quot;&gt;</code> 内部调用 <code>router.push</code> 方法实现页面导航</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name: 'detail', params: &#123;name: 1&#125;&#125;"</span>&gt;</span> xxx <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name: 'detail', query: &#123;id: 1&#125;&#125;"</span>&gt;</span> xxx <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>this.$route.params</code> 或 <code>this.$route.params</code> 获取路由参数。</li></ul><h3 id="router-实例实现编程式导航"><a href="#router-实例实现编程式导航" class="headerlink" title="router 实例实现编程式导航"></a>router 实例实现编程式导航</h3><p>在 Vue 实例内部，可以通过 <code>$router</code> 访问路由实例，可以调用 <code>this.$router.push</code> 方法，向 history 栈添加一个新的记录，点击浏览器后退按钮时也可以回到之前的 URL。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">'home'</span>)</span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"><span class="comment">// 命名的路由/user/123</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">uid</span>: <span class="string">'123'</span> &#125; &#125;) <span class="comment">// 刷新后参数会被清空</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// 刷新后参数不会被清空</span></span><br><span class="line"><span class="comment">// 带查询参数，/home?uid=123</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span>, <span class="attr">query</span>: &#123; <span class="attr">uid</span>: <span class="string">'123'</span> &#125; &#125;) <span class="comment">// 刷新后不会被清空</span></span><br></pre></td></tr></table></figure><ul><li><code>router.replace(&#39;&#39;)</code> 跳转页面会替换掉原有的 history 记录</li><li><code>router.go(n)</code> 在 history 记录中前进或后退多少步</li></ul><h2 id="keep-alive-网页性能优化"><a href="#keep-alive-网页性能优化" class="headerlink" title="keep-alive 网页性能优化"></a>keep-alive 网页性能优化</h2><p>keep-alive 主要用于保留组件状态或避免重新渲染 DOM 导致性能降低，通常都会在 <code>app.vue</code> 的 <code>&lt;router-view/&gt;</code> 外面加一层 <code>&lt;keep-alive&gt;</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做也会导致一些问题，当组件的值更新后组件没有被重新渲染，做到动态显示需要使用额外生命周期函数 <code>activated</code><br>进入页面会执行 mounted 和 activated，当修改值后再次进入首页不会再执行 mounted 触发新的数据请求，但是 activated 会继续执行。可以在 activated 函数中判断新数据和前一次显示是否相同，如果不同再次触发 ajax 数据请求。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">   <span class="keyword">this</span>.lastData = <span class="keyword">this</span>.data;</span><br><span class="line">   <span class="keyword">this</span>.getNewData();</span><br><span class="line">&#125;</span><br><span class="line">activated () &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.lastData !== <span class="keyword">this</span>.data) &#123;</span><br><span class="line">      <span class="keyword">this</span>.lastData = <span class="keyword">this</span>.data;</span><br><span class="line">      <span class="keyword">this</span>.getNewData();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在路由更新后页面由于 keep-alive 的缓存不会执行 mounted 触发刷新，需要设置路由的 key 值，在每次进入页面时比较路由名称，若不相同则刷新页面。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*App.vue*/</span></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">   &lt;router-view :key=<span class="string">"key"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  computed: &#123;</span></span><br><span class="line"><span class="regexp">    key () &#123;</span></span><br><span class="line"><span class="regexp">      return this.$route.name !== undefined</span></span><br><span class="line"><span class="regexp">        ? this.$route.name + +new Date()</span></span><br><span class="line"><span class="regexp">        : this.$route + +new Date()</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="Vuex-数据防刷新丢失"><a href="#Vuex-数据防刷新丢失" class="headerlink" title="Vuex 数据防刷新丢失"></a>Vuex 数据防刷新丢失</h2><p>引入 vuex-persist 插件将状态保存至 cookie 或者 localStorage 中，刷新后数据不丢失。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VuexPersistence <span class="keyword">from</span> <span class="string">'vuex-persist'</span></span><br><span class="line"><span class="keyword">const</span> vuexLocal = <span class="keyword">new</span> VuexPersistence(&#123;</span><br><span class="line">storage: <span class="built_in">window</span>.localStorage,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  plugins: [vuexLocal.plugin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="自定义指令避免误触和多次点击"><a href="#自定义指令避免误触和多次点击" class="headerlink" title="自定义指令避免误触和多次点击"></a>自定义指令避免误触和多次点击</h2><p>使用 Vue.directive 自定义防误触指令</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> preventReClick = Vue.directive(<span class="string">'preventReClick'</span>, &#123;</span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 增加监听事件</span></span><br><span class="line">el.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (!el.disabled) &#123;</span><br><span class="line">el.disabled = <span class="literal">true</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">el.disabled = <span class="literal">false</span></span><br><span class="line">&#125;, binding.value || <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; preventReClick &#125;</span><br></pre></td></tr></table></figure><h2 id="制作可复用组件"><a href="#制作可复用组件" class="headerlink" title="制作可复用组件"></a>制作可复用组件</h2><p>复用组件需要在样式和功能上做到继承和迭代，是在系统整体设计时抽象出的组件，多为布局组件，不涉及详细的功能实现。组件需要做到高内聚低耦合，组件内独立交互，功能受控于组件本身。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按钮组件抽象，样式设置为外部继承 cname，和内部自定义 button，留出按钮名称 title 和 &lt;slot&gt; 插槽作为具体内容的补充空间</span></span><br><span class="line">&lt;div :<span class="class"><span class="keyword">class</span></span>=<span class="string">"[button, cname]"</span>&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; title &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;slot /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'BigBtn',</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 通过 props 传入外部参数</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    cname: &#123;</span></span><br><span class="line"><span class="regexp">      type: String,</span></span><br><span class="line"><span class="regexp">      default: ''</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    title: &#123;</span></span><br><span class="line"><span class="regexp">      type: String,</span></span><br><span class="line"><span class="regexp">      default: 'title'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 设置内部定义的样式</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      button: 'button'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=<span class="string">"stylus"</span>&gt;</span><br><span class="line"><span class="comment">// 引入样式</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"~@/styles/button.styl"</span></span><br><span class="line">.button</span><br><span class="line">  bigBtn() <span class="comment">// 默认样式</span></span><br><span class="line">.blueBtn</span><br><span class="line">  bigBtn($btnColor: $btnBlue) <span class="comment">// cname 传入 blueBtn 设置颜色为蓝色</span></span><br><span class="line">.greenBtn</span><br><span class="line">  bigBtn($btnColor: $btnGreen) <span class="comment">// cname 传入 greenBtn 设置颜色为绿色</span></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><h2 id="上传文件功能"><a href="#上传文件功能" class="headerlink" title="上传文件功能"></a>上传文件功能</h2><p>使用 element-ui 的 upload 功能实现图片展示，上传和读取，on-change 触发文件状态改变时的钩子，调用上传照片 api 将照片数据传递到后台；on-preview 用于显示已上传的图片的缩略图；传递多个文件时文件列表存储在 file-list 中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span></span></span><br><span class="line"><span class="tag"><span class="attr">action</span>=<span class="string">"actionUrl"</span></span></span><br><span class="line"><span class="tag"><span class="attr">list-type</span>=<span class="string">"picture-card"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"upload"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:file-list</span>=<span class="string">"fileList"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:auto-upload</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:on-change</span>=<span class="string">"getFile"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:on-preview</span>=<span class="string">"handlePictureCardPreview"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"tip"</span> <span class="attr">class</span>=<span class="string">"el-upload__tip"</span>&gt;</span>上传一张jpg/png文件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-icon</span> <span class="attr">class</span>=<span class="string">"el-icon-plus"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文件信息</span></span><br><span class="line">getFile (file) &#123;</span><br><span class="line">  <span class="keyword">let</span> uid = <span class="keyword">this</span>.$store.state.currentUid</span><br><span class="line">  <span class="comment">// 调用上传照片的api</span></span><br><span class="line">  api._updImage(uid, <span class="keyword">this</span>.aid, res).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若上传 base64 位图片需要进行转码之后调用 api 上传：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图片转base64</span></span><br><span class="line">getBase64 (file) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">    <span class="keyword">let</span> imgResult = <span class="string">''</span></span><br><span class="line">    reader.readAsDataURL(file)</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      imgResult = reader.result</span><br><span class="line">    &#125;</span><br><span class="line">    reader.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(imgResult)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vuex-监听状态变更"><a href="#Vuex-监听状态变更" class="headerlink" title="Vuex 监听状态变更"></a>Vuex 监听状态变更</h2><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">  updFlag: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 添加计算属性，依赖值改变时重新计算</span></span><br><span class="line">getters: &#123;</span><br><span class="line">  updFlag: <span class="function"><span class="params">state</span> =&gt;</span> state.updFlag</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 执行状态变更</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  updateFlag (state, update) &#123;</span><br><span class="line">    state.updFlag = update</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表单设置日期限制"><a href="#表单设置日期限制" class="headerlink" title="表单设置日期限制"></a>表单设置日期限制</h3><h3 id="表单设置"><a href="#表单设置" class="headerlink" title="表单设置"></a>表单设置</h3><h2 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h2><ol><li><p>监听组件原生事件<br><code>@click.native=</code>可以在子组件监听根元素的原生事件，不需要通过<code>$emit</code>事件</p></li><li><p>ref 属性<br>给 DOM 元素或子组件注册引用信息，引用信息将会注册在父组件的 <code>$refs</code> 对象上，如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。<br>通过<code>this.$refs.ref</code>访问 dom 节点或组件实例(data)</p></li><li><p>回到顶部功能<br>使用 element-ui 中提供的功能实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;el-backtop</span><br><span class="line">target=<span class="string">".page-component__scroll .el-scrollbar__wrap"</span></span><br><span class="line">visibility-height=<span class="string">"200"</span></span><br><span class="line">right=<span class="string">"30"</span></span><br><span class="line">bottom=<span class="string">"30"</span></span><br><span class="line">&gt;</span><br><span class="line">up</span><br><span class="line">&lt;<span class="regexp">/el-backtop&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用 better-scroll 插件实现，通过监听下拉时 y 轴的移动距离显示上拉按钮，点击后触发返回顶部事件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回到开头</span></span><br><span class="line">toTop () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.toTop) &#123;</span><br><span class="line">    <span class="comment">// 延迟20ms后在1s内回到顶部</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    &#125;, <span class="number">20</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p>参考资料：<br><a href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/essentials/navigation.html</a><br><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh/</a><br><a href="https://better-scroll.github.io/docs/zh-CN/" target="_blank" rel="noopener">https://better-scroll.github.io/docs/zh-CN/</a><br><a href="https://element.faas.ele.me/#/zh-CN/" target="_blank" rel="noopener">https://element.faas.ele.me/#/zh-CN/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇总记录前端开发时，使用 Vue 框架遇到的功能实现和开发技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="Vue" scheme="https://hyqskevin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>BetterScroll插件实现页面滚动效果</title>
    <link href="https://hyqskevin.github.io/2020/05/28/better-scroll/"/>
    <id>https://hyqskevin.github.io/2020/05/28/better-scroll/</id>
    <published>2020-05-28T03:08:18.000Z</published>
    <updated>2020-11-19T09:17:47.822Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;BetterScoll 用于解决列表的动态滚动，实现移动端列表上拉加载，下拉刷新，水平/垂直滚动，滚动至指定高度等功能。BetterScroll 支持大量参数配置，提供很多灵活的 api 实现指定功能。<br>&emsp;&emsp;实现 BetterScroll 滚动时父元素的高度或宽度需要进行固定，同时确保父元素和子元素内容正确渲染；在 DOM 结构发生改变时需要重新调用 <code>scroll.refresh()</code> 方法重新计算来确保滚动效果正常。</p><a id="more"></a><ul><li><p>安装：<code>npm install better-scroll --save</code></p></li><li><p>基本结构：</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其它的 DOM --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">import BScroll from 'better-scroll'</span></span><br><span class="line"><span class="undefined">let scroll = new BScroll('.wrapper', &#123;</span></span><br><span class="line"><span class="undefined">pullUpLoad: true,</span></span><br><span class="line"><span class="undefined">scrollbar: true,</span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Scroll-配置项"><a href="#Scroll-配置项" class="headerlink" title="Scroll 配置项"></a>Scroll 配置项</h2><h2 id="Scroll-常用方法"><a href="#Scroll-常用方法" class="headerlink" title="Scroll 常用方法"></a>Scroll 常用方法</h2><h2 id="Scroll-事件监听"><a href="#Scroll-事件监听" class="headerlink" title="Scroll 事件监听"></a>Scroll 事件监听</h2><h2 id="Vue-中实现-BetterScroll"><a href="#Vue-中实现-BetterScroll" class="headerlink" title="Vue 中实现 BetterScroll"></a>Vue 中实现 BetterScroll</h2><p>&emsp;&emsp;Vue.js 提供了我们一个获取 DOM 对象的接口 <code>vm.$refs</code>，可以通过 <code>this.$refs.wrapper</code> 访问 DOM 对象。在 mounted 钩子函数里，使用回调函数保证初始化时 wrapper 的 DOM 已经渲染，可以正确计算它以及它内层 content 的高度以确保滚动正常。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span> <span class="attr">ref</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">import BScroll from 'better-scroll'</span></span><br><span class="line"><span class="undefined">export default &#123;</span></span><br><span class="line"><span class="undefined">mounted() &#123;</span></span><br><span class="line"><span class="undefined">this.$nextTick(() =&gt; &#123;</span></span><br><span class="line"><span class="undefined">this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;)</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined">&#125;,</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h2><p>Scroll 组件的 DOM 结构包括顶部和底部的提示信息以及中间部分的列表组件，使用插槽 <code>&lt;slot&gt;</code> 进行占位。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"wrapper"</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"scroll-content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 刷新提示信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top-tip"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"refresh-hook"</span>&gt;</span>&#123;&#123;pullDownMsg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内容列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 底部提示信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom-tip"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"loading-hook"</span>&gt;</span>'-到底了-'<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件的 js 部分对 Scroll 做 Vue 的封装，在 prop 里重写 Scroll 配置项，将控制权交给调用 Scroll.vue 的父组件；通过 methods 暴露的一些方法对 better-scroll 的方法做一层代理；watch 监听 data 的改变，及时调用 refresh 方法重新计算 better-scroll 确保滚动效果正常。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">'better-scroll'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// 常用配置和自定义配置</span></span><br><span class="line">props: &#123;</span><br><span class="line">probeType: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">1</span> &#125;, <span class="comment">// 何时派发滚动事件</span></span><br><span class="line">click: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">true</span> &#125;, <span class="comment">// 点击时是否派发click事件</span></span><br><span class="line">scrollX: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 横向滚动</span></span><br><span class="line">scrollY: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 纵向滚动</span></span><br><span class="line">bounce: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 边缘弹回动画</span></span><br><span class="line">    autoBlur: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 滚动之前激活元素失去焦点</span></span><br><span class="line">    <span class="comment">// 自定义事件</span></span><br><span class="line">pullup: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 上拉动作触发事件</span></span><br><span class="line">    pulldown: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 下拉动作出发事件</span></span><br><span class="line">listenScroll: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 监听滚动距离触发滚动事件</span></span><br><span class="line">data: &#123; <span class="attr">type</span>: <span class="built_in">Array</span>, <span class="attr">default</span>: <span class="literal">null</span> &#125;, <span class="comment">// 父组件的列表数据</span></span><br><span class="line">beforeScroll: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 列表滚动开始事件</span></span><br><span class="line">    refreshDelay: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">20</span> &#125;, <span class="comment">// 数据更新后刷新Scroll延时</span></span><br><span class="line">    showIcon: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">true</span> &#125;, <span class="comment">// 下拉后显示返回按钮事件</span></span><br><span class="line">    toTop: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125; <span class="comment">// 返回顶部事件</span></span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">_initScroll() &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.$refs.wrapper) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// better-scroll的初始化</span></span><br><span class="line"><span class="keyword">this</span>.scroll = <span class="keyword">new</span> BScroll(<span class="keyword">this</span>.$refs.wrapper, &#123;</span><br><span class="line">probeType: <span class="keyword">this</span>.probeType,</span><br><span class="line">click: <span class="keyword">this</span>.click,up</span><br><span class="line">        scrollX: <span class="keyword">this</span>.scrollX,</span><br><span class="line">        pullup: <span class="keyword">this</span>.pullup,</span><br><span class="line">        pulldown: <span class="keyword">this</span>.pulldown</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派发滚动事件，下拉一定距离后提示可刷新</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.listenScroll) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scroll.on(<span class="string">'scroll'</span>, (pos) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (pos.y &gt; <span class="number">120</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pullDownMsg = <span class="string">'释放后进行刷新'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行下拉刷新操作</span></span><br><span class="line">      <span class="keyword">this</span>.scroll.on(<span class="string">'pullingDown'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'pulldown'</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.scroll.finishPullDown()</span><br><span class="line">          <span class="keyword">this</span>.scroll.refresh()</span><br><span class="line">          <span class="keyword">this</span>.pullDownMsg = <span class="string">'-下拉刷新-'</span></span><br><span class="line">        &#125;, <span class="number">600</span>)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派发列表滚动开始的事件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beforeScroll) &#123;</span><br><span class="line"><span class="keyword">this</span>.scroll.on(<span class="string">'beforeScrollStart'</span>, () =&gt; &#123;</span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'beforeScroll'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">disable() &#123;</span><br><span class="line"><span class="comment">// 代理better-scroll的disable方法</span></span><br><span class="line"><span class="keyword">this</span>.scroll &amp;&amp; <span class="keyword">this</span>.scroll.disable()</span><br><span class="line">&#125;,</span><br><span class="line">enable() &#123;</span><br><span class="line"><span class="comment">// 代理better-scroll的enable方法</span></span><br><span class="line"><span class="keyword">this</span>.scroll &amp;&amp; <span class="keyword">this</span>.scroll.enable()</span><br><span class="line">&#125;,</span><br><span class="line">refresh() &#123;</span><br><span class="line"><span class="comment">// 代理better-scroll的refresh方法</span></span><br><span class="line"><span class="keyword">this</span>.scroll &amp;&amp; <span class="keyword">this</span>.scroll.refresh()</span><br><span class="line">&#125;,</span><br><span class="line">scrollTo() &#123;</span><br><span class="line"><span class="comment">// 代理better-scroll的scrollTo方法</span></span><br><span class="line"><span class="keyword">this</span>.scroll &amp;&amp; <span class="keyword">this</span>.scroll.scrollTo.apply(<span class="keyword">this</span>.scroll, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;,</span><br><span class="line">scrollToElement() &#123;</span><br><span class="line"><span class="comment">// 代理better-scroll的scrollToElement方法</span></span><br><span class="line"><span class="keyword">this</span>.scroll &amp;&amp; <span class="keyword">this</span>.scroll.scrollToElement.apply(<span class="keyword">this</span>.scroll, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line"><span class="comment">// DOM渲染完毕后初始化better-scroll</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>._initScroll()</span><br><span class="line">&#125;, <span class="keyword">this</span>.refreshDelay)</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line"><span class="comment">// 监听数据的变化，延时refreshDelay时间后调用refresh方法重新计算，保证滚动效果正常</span></span><br><span class="line">data() &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.refresh()</span><br><span class="line">&#125;, <span class="keyword">this</span>.refreshDelay)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://github.com/ustbhuangyi/better-scroll" target="_blank" rel="noopener">https://github.com/ustbhuangyi/better-scroll</a><br><a href="https://better-scroll.github.io/docs/zh-CN/" target="_blank" rel="noopener">https://better-scroll.github.io/docs/zh-CN/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;BetterScoll 用于解决列表的动态滚动，实现移动端列表上拉加载，下拉刷新，水平/垂直滚动，滚动至指定高度等功能。BetterScroll 支持大量参数配置，提供很多灵活的 api 实现指定功能。&lt;br&gt;&amp;emsp;&amp;emsp;实现 BetterScroll 滚动时父元素的高度或宽度需要进行固定，同时确保父元素和子元素内容正确渲染；在 DOM 结构发生改变时需要重新调用 &lt;code&gt;scroll.refresh()&lt;/code&gt; 方法重新计算来确保滚动效果正常。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="Vue" scheme="https://hyqskevin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>swiper滑动插件</title>
    <link href="https://hyqskevin.github.io/2020/05/12/swiper/"/>
    <id>https://hyqskevin.github.io/2020/05/12/swiper/</id>
    <published>2020-05-12T06:27:12.000Z</published>
    <updated>2020-11-19T06:55:28.435Z</updated>
    
    <content type="html"><![CDATA[<p>Swiper 和 vue-awesome-swiper 插件用于页面内容的触摸滑动，每个展示块为一个 slide，全部 slide 包含在包装器 wrapper 中，外部的总容器 container 又包裹着 wrapper 和箭头按钮控件 navigation 以及分页器控件 pagination。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-wrapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span>Slide 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span>Slide 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span>Slide 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--分页器。如果放置在swiper-container外面，需要自定义样式。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--左箭头。如果放置在swiper-container外面，需要自定义样式。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-button-prev"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--右箭头。如果放置在swiper-container外面，需要自定义样式。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-button-next"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果需要滚动条 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-scrollbar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="swiper"><a href="#swiper" class="headerlink" title="swiper"></a>swiper</h2><h3 id="初始结构"><a href="#初始结构" class="headerlink" title="初始结构"></a>初始结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Swiper <span class="keyword">from</span> <span class="string">'swiper'</span></span><br><span class="line"><span class="keyword">var</span> mySwiper = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line">direction: <span class="string">'vertical'</span>, <span class="comment">// 垂直切换选项</span></span><br><span class="line">  loop: <span class="literal">true</span>, <span class="comment">// 循环模式选项</span></span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// 如果需要分页器</span></span><br><span class="line">pagination: &#123;</span><br><span class="line">el: <span class="string">'.swiper-pagination'</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要前进后退按钮</span></span><br><span class="line">navigation: &#123;</span><br><span class="line">nextEl: <span class="string">'.swiper-button-next'</span>,</span><br><span class="line">prevEl: <span class="string">'.swiper-button-prev'</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要滚动条</span></span><br><span class="line">scrollbar: &#123;</span><br><span class="line">el: <span class="string">'.swiper-scrollbar'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="container-常用选项"><a href="#container-常用选项" class="headerlink" title="container 常用选项"></a>container 常用选项</h3><ul><li>initialSlide：初始化时显示的 slide，默认为第一个 slide</li><li>direction：slide 滑动方向，默认为水平方向</li><li>speed：切换速度，单位 ms</li><li>slidesPerView：设置同时显示的 slides 数量</li><li>slidesPerGroup：定义滑动时几个 slide 为一组</li><li>spaceBetween：在 slide 之间设置距离</li><li>loop：会在原本 slide 前后复制若干个 slide 并在合适的时候切换</li><li>preventClicks：防止滑动时执行链接跳转</li><li>touchRatio：设置触摸距离与 slide 滑动距离的比率</li><li>threshold：设置拖动临界值</li><li>touchAngle：设置触发拖动的角度值。默认 45 度，即使触摸方向不是完全水平也能拖动 slide</li><li>autoplay：设置为 true 启动自动切换，可设置延迟 delay 参数</li><li>effect：设置切换效果，’slide’（普通切换、默认）,”fade”（淡入）”cube”（方块）”coverflow”（3d 流）”flip”（3d 翻转）</li></ul><h3 id="组件功能"><a href="#组件功能" class="headerlink" title="组件功能"></a>组件功能</h3><ul><li>lazy：设为 true 开启图片延迟加载默认值</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 延迟加载图片的结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">"path/to/picture-1.jpg"</span> <span class="attr">class</span>=<span class="string">"swiper-lazy"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-lazy-preloader"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> mySwiper = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</span></span><br><span class="line"><span class="undefined">lazy: &#123;</span></span><br><span class="line"><span class="javascript">loadPrevNext: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">&#125;,</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>zoom：开启焦距功能：双击 slide 会放大/缩小，并且在手机端可双指触摸缩放</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-zoom-container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"path/to/image"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>thumbs：专门用于制作带缩略图的 swiper</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> thumbsSwiper = <span class="keyword">new</span> Swiper(<span class="string">'#thumbs'</span>, &#123;</span><br><span class="line">spaceBetween: <span class="number">10</span>,</span><br><span class="line">slidesPerView: <span class="number">4</span>,</span><br><span class="line">watchSlidesVisibility: <span class="literal">true</span>, <span class="comment">//防止不可点击</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> gallerySwiper = <span class="keyword">new</span> Swiper(<span class="string">'#gallery'</span>, &#123;</span><br><span class="line">spaceBetween: <span class="number">10</span>,</span><br><span class="line">thumbs: &#123;</span><br><span class="line">swiper: thumbsSwiper,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>mySwiper.slideNext(speed, runCallbacks)</code> 滑动到下一个滑块</li><li><code>mySwiper.slidePrev(speed,runCallbacks)</code> 滑动到前一个滑块</li><li><code>mySwiper.slideTo(index, speed, runCallbacks)</code> 切换到指定 slide</li><li><code>mySwiper.on(event,handler)</code> 添加回调函数或者事件</li></ul><h2 id="vue-awesome-swiper"><a href="#vue-awesome-swiper" class="headerlink" title="vue-awesome-swiper"></a>vue-awesome-swiper</h2><p>vue-awesome-swiper 是 vue 的 swiper 插件，<code>npm install swiper vue-awesome-swiper --save</code>安装导入后即可在组件中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*main.js 全局安装*/</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueAwesomeSwiper <span class="keyword">from</span> <span class="string">'vue-awesome-swiper'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import style (&gt;= Swiper 6.x)</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'swiper/swiper-bundle.css'</span></span><br><span class="line"><span class="comment">// import style (&lt;= Swiper 5.x)</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'swiper/css/swiper.css'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueAwesomeSwiper <span class="comment">/* &#123; default options with global component &#125; */</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*.vue 组件内*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; Swiper, SwiperSlide, directive &#125; <span class="keyword">from</span> <span class="string">'vue-awesome-swiper'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import style (&gt;= Swiper 6.x)</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'swiper/swiper-bundle.css'</span></span><br><span class="line"><span class="comment">// import style (&lt;= Swiper 5.x)</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'swiper/css/swiper.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">components: &#123;</span><br><span class="line">Swiper,</span><br><span class="line">SwiperSlide,</span><br><span class="line">&#125;,</span><br><span class="line">directives: &#123;</span><br><span class="line">swiper: directive,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始结构-1"><a href="#初始结构-1" class="headerlink" title="初始结构"></a>初始结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;swiper ref=<span class="string">"mySwiper"</span> :options=<span class="string">"swiperOptions"</span>&gt;</span><br><span class="line">    &lt;swiper-slide&gt;Slide <span class="number">1</span>&lt;<span class="regexp">/swiper-slide&gt;</span></span><br><span class="line"><span class="regexp">    &lt;swiper-slide&gt;Slide 2&lt;/</span>swiper-slide&gt;</span><br><span class="line">    &lt;swiper-slide&gt;Slide <span class="number">3</span>&lt;<span class="regexp">/swiper-slide&gt;</span></span><br><span class="line"><span class="regexp">    &lt;swiper-slide&gt;Slide 4&lt;/</span>swiper-slide&gt;</span><br><span class="line">    &lt;swiper-slide&gt;Slide <span class="number">5</span>&lt;<span class="regexp">/swiper-slide&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="swiper-pagination" slot="pagination"&gt;&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/swiper&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'carrousel'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      swiperOptions: &#123;</span><br><span class="line">        pagination: &#123;</span><br><span class="line">          el: <span class="string">'.swiper-pagination'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// Some Swiper option/callback...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    swiper() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$refs.mySwiper.$swiper</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://www.swiper.com.cn/" target="_blank" rel="noopener">https://www.swiper.com.cn/</a><br><a href="https://github.com/surmon-china/vue-awesome-swiper" target="_blank" rel="noopener">https://github.com/surmon-china/vue-awesome-swiper</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swiper 和 vue-awesome-swiper 插件用于页面内容的触摸滑动，每个展示块为一个 slide，全部 slide 包含在包装器 wrapper 中，外部的总容器 container 又包裹着 wrapper 和箭头按钮控件 navigation 以及分页器控件 pagination。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-wrapper&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-slide&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Slide 1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-slide&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Slide 2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-slide&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Slide 3&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--分页器。如果放置在swiper-container外面，需要自定义样式。--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-pagination&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--左箭头。如果放置在swiper-container外面，需要自定义样式。--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-button-prev&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--右箭头。如果放置在swiper-container外面，需要自定义样式。--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-button-next&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 如果需要滚动条 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-scrollbar&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="Vue" scheme="https://hyqskevin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>javascript异步，消息队列和事件循环</title>
    <link href="https://hyqskevin.github.io/2020/05/10/js%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/"/>
    <id>https://hyqskevin.github.io/2020/05/10/js同步和异步/</id>
    <published>2020-05-10T01:33:58.000Z</published>
    <updated>2020-11-19T08:17:13.838Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;JavaScript 是单线程的，在 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，而异步容易实现非阻塞，所以在 JavaScript 中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。</p><a id="more"></a><h2 id="1-异步过程"><a href="#1-异步过程" class="headerlink" title="1. 异步过程"></a>1. 异步过程</h2><p>异步过程：主线程发起一个异步请求 -&gt; 工作线程接收请求(异步函数返回) -&gt; 主线程继续执行后面的代码，同时工作线程执行异步任务 -&gt; 工作线程完成工作后，通知主线程 -&gt; 主线程收到通知后，执行一定的动作(调用回调函数)。</p><p>实现异步过程包括发起函数和回调函数，发起函数用于发起异步过程，回调函数用来处理调用的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发起函数</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 回调函数内容</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h2 id="2-消息队列和事件循环"><a href="#2-消息队列和事件循环" class="headerlink" title="2. 消息队列和事件循环"></a>2. 消息队列和事件循环</h2><p>异步过程中，工作线程在异步操作完成后需要通知主线程。这个通知机制需要通过消息队列和事件循环完成。</p><p>消息队列是一个先进先出的队列，它里面存放着各种消息。JS 引擎线程执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中执行新的同步任务。</p><p>每次栈被清空后，JS 引擎线程都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务。</p><p><img src="https://hyqskevin.github.io/pic/yibu.webp" alt="消息队列和事件循环"></p><h2 id="3-异步编程方法"><a href="#3-异步编程方法" class="headerlink" title="3. 异步编程方法"></a>3. 异步编程方法</h2><ol><li>回调函数</li></ol><p>将后者的执行改写为前者的回调函数。回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="comment">//f1方法</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">callback(f2) <span class="comment">// f2执行改写为f1的回调函数</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//f2方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的回调函数有 setTimeout，setInterval 和 nextTick</p><ul><li><code>setTimeout</code> 设定为一段时间后执行异步任务，且在主线程执行完成后才被调用。</li><li><code>setInterval</code> 是一个定时器函数，按照指定周期不断调用函数，在每次主线程完成后执行。常用于获取数据量过大的列表，先获取一部分用于 DOM 挂载和页面展示，之后再不断从后台获取全部数据。</li><li><code>process.nextTick()</code> 是 Node.js 提供的异步执行函数，执行顺序会早于 setTimeout 和 setTimeInterval，在主线程完成后，任务队列调用之前执行，即在当前”执行栈”的尾部 -&gt; 下一次 Event Loop（主线程读取”任务队列”）之前 -&gt; 触发 process 指定的回调函数。</li></ul><ol><li>Promise 对象</li></ol><p>ECMAscript 6 原生提供了 Promise 对象，代表了未来将要发生的事件，用来传递异步操作的消息，调用 resolve 或 reject 方法返回。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Promise</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步处理</span></span><br><span class="line">  <span class="keyword">if</span> () &#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(); <span class="comment">// 异步调用失败</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调再判断结果，也可以调用 promise.catch()方法捕捉错误的回调函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">(res) =&gt; &#123;</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line">&#125;,</span><br><span class="line">(err) =&gt; &#123;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// catch error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p><ol><li>async/await</li></ol><p>async/await 基于 Promise 实现，它不能用于普通的回调函数。使用 await，函数必须用 async 标识，await 后面跟的是一个 Promise 实例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> f1();</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> f2();</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// 处理报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// f1方法</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// f2方法</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://github.com/ljianshu/Blog/issues/53" target="_blank" rel="noopener">https://github.com/ljianshu/Blog/issues/53</a><br><a href="https://www.runoob.com/w3cnote/javascript-promise-object.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/javascript-promise-object.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;JavaScript 是单线程的，在 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，而异步容易实现非阻塞，所以在 JavaScript 中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="JavaScript" scheme="https://hyqskevin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>json数据模拟</title>
    <link href="https://hyqskevin.github.io/2019/11/10/json-server/"/>
    <id>https://hyqskevin.github.io/2019/11/10/json-server/</id>
    <published>2019-11-10T11:33:58.000Z</published>
    <updated>2020-11-19T06:55:49.557Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;进行 web 网站开发时，前后端分离导致开发进度不同，前端经常需要等待后端的接口数据完成开发才可以继续调试。且开发环境，测试环境和线上环境分离，本地开发时无法运用测试环境的接口，开发时的接口和最终部署的接口也并不相同，每次测试时来回部署代码要耗费很多时间。<br>&emsp;&emsp;使用 json-server + mockjs 编写 json 格式的模拟数据接口，在等待后端准备接口期间，前端可以使用假数据进行模拟。</p><a id="more"></a><h2 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h2><p>json-server 是可以在本地运行，存储 json 数据的服务端。通过<code>npm install -g json-server</code>安装。</p><p>database.json 文件格式：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data1"</span>: &#123;</span><br><span class="line">    <span class="attr">"subdata1"</span>: <span class="string">"value1"</span>,</span><br><span class="line">    <span class="attr">"subdata2"</span>: <span class="string">"value2"</span>,</span><br><span class="line">    <span class="attr">"subdata3"</span>: <span class="string">"value3"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"data2"</span>: &#123;<span class="attr">"subdata1"</span>: , <span class="attr">"subdata2"</span>: , <span class="attr">"subdata3"</span>: &#125;,</span><br><span class="line">  <span class="attr">"data3"</span>: &#123;<span class="attr">"subdata1"</span>: , <span class="attr">"subdata2"</span>: , <span class="attr">"subdata3"</span>: &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置完 json 文件后，使用<code>json-server --watch --port 3001 database.json</code> 命令，启动服务 database.json。访问<code>localhost:3001</code>可以查看 json 数据。</p><h3 id="实现各类数据请求"><a href="#实现各类数据请求" class="headerlink" title="实现各类数据请求"></a>实现各类数据请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /</span><br><span class="line">GET|POST /post</span><br><span class="line">GET|POST /post/<span class="number">1</span></span><br><span class="line">GET /post?param1=&amp;param2=</span><br><span class="line">GET /post/post?_page=<span class="number">1</span></span><br><span class="line">GET /posts?_sort=views&amp;_order=asc</span><br><span class="line">GET /posts?_start=<span class="number">20</span>&amp;_end=<span class="number">30</span></span><br><span class="line">GET /posts?q=xxx <span class="comment">// 搜索功能</span></span><br></pre></td></tr></table></figure><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>json-server 可以自定义路由，检验条件或输出格式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonServer = <span class="built_in">require</span>(<span class="string">'json-server'</span>) <span class="comment">// 创建json-server服务</span></span><br><span class="line"><span class="keyword">const</span> server = jsonServer.create() <span class="comment">// 创建http服务</span></span><br><span class="line"><span class="keyword">const</span> router = jsonServer.router(<span class="string">'db.js'</span>) <span class="comment">// 路由匹配的js数据</span></span><br><span class="line"><span class="keyword">const</span> middleWares = jsonServer.defaults() <span class="comment">// 使用默认中间件</span></span><br><span class="line"></span><br><span class="line">server.use(jsonServer.bodyParser) <span class="comment">// 安装json-server自带的body-parser，用于获取非地址栏传递的数据</span></span><br><span class="line">server.use(middleWares)</span><br><span class="line">server.use(router)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听自定义路由</span></span><br><span class="line">server.listen(&#123; <span class="attr">host</span>: <span class="string">'192.168.137.1'</span>, <span class="attr">post</span>: <span class="number">3000</span> &#125;, () =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'JSON Server is running'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其它功能：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义js数据地址</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> router = jsonServer.router(path.join(__dirname, <span class="string">'db.json'</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义注册操作</span></span><br><span class="line"><span class="comment">// 注意： 自定义路由响应需要在安装json-server的router之前</span></span><br><span class="line">server.post(</span><br><span class="line"><span class="string">'/mock/register'</span>,</span><br><span class="line">(&#123; <span class="attr">body</span>: &#123; username = <span class="string">''</span>, password = <span class="string">''</span> &#125; &#125;, res) =&gt; &#123;</span><br><span class="line"><span class="comment">// console.log(username,password);</span></span><br><span class="line">username !== <span class="string">'admin'</span> &amp;&amp; password</span><br><span class="line">? res.jsonp(&#123;</span><br><span class="line">err: <span class="number">0</span>,</span><br><span class="line">msg: <span class="string">'注册成功'</span>,</span><br><span class="line">data: &#123;</span><br><span class="line">username,</span><br><span class="line">password,</span><br><span class="line">&#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">: res.jsonp(&#123;</span><br><span class="line">err: <span class="number">1</span>,</span><br><span class="line">msg: <span class="string">'注册失败'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  增加检验条件 isAuthorized</span></span><br><span class="line">server.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isAuthorized(req)) &#123;</span><br><span class="line"><span class="comment">// add your authorization logic here</span></span><br><span class="line">next() <span class="comment">// continue to JSON Server router</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.sendStatus(<span class="number">401</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义返回内容</span></span><br><span class="line">router.render = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> status</span><br><span class="line"><span class="keyword">let</span> len = <span class="built_in">Object</span>.keys(res.locals.data).length <span class="comment">// 判断是否获取到mockJS模拟的数据</span></span><br><span class="line"><span class="keyword">if</span> (res.req.originalMethod === <span class="string">'DELETE'</span>) &#123;</span><br><span class="line">status = len === <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">status = !!len</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 由于本地请求速度较快，不方便loading动效显示利用延时器，模拟真实服务器请求速度</span></span><br><span class="line">res.jsonp(&#123;</span><br><span class="line"><span class="comment">// 使用res.jsonp()方法将mockJS模拟生成的数据进行自定义包装后输出</span></span><br><span class="line">err: status ? <span class="number">0</span> : <span class="number">1</span>,</span><br><span class="line">msg: <span class="string">'操作'</span> + (status ? <span class="string">'成功'</span> : <span class="string">'失败'</span>),</span><br><span class="line">data: res.locals.data,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mockjs"><a href="#mockjs" class="headerlink" title="mockjs"></a>mockjs</h2><p>Mock.js 是一款模拟数据生成器，可以根据数据模板生成模拟数据，模拟 Ajax 请求，基于 HTML 模板生成模拟数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install mockjs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> Mock = <span class="built_in">require</span>(<span class="string">'mockjs'</span>);</span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Mock.js 使用数据模板定义生成模拟数据，数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：<code>&#39;name|rule&#39;: value</code>。也可以使用<code>Mock.Random</code> 工具类生成各种随机数据。具体语法在<a href="http://mockjs.com/0.1/#" target="_blank" rel="noopener">Mock.js 官网</a>中有详细说明。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Mock = <span class="built_in">require</span>(<span class="string">"mockjs"</span>); <span class="comment">// 引入mockJS</span></span><br><span class="line"><span class="keyword">const</span> MR = Mock.Random; <span class="comment">// 提mock的随机对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">"home|5"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"id|+1"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"@cname"</span>,</span><br><span class="line">        <span class="string">"imgURL"</span>: MR.image(<span class="string">'750X200'</span>,MR.color(),MR.cword(<span class="number">4</span>,<span class="number">10</span>))</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-配置数据地址"><a href="#webpack-配置数据地址" class="headerlink" title="webpack 配置数据地址"></a>webpack 配置数据地址</h2><hr><p><a href="https://blog.csdn.net/qq_41629150/article/details/99645632" target="_blank" rel="noopener">https://blog.csdn.net/qq_41629150/article/details/99645632</a><br><a href="https://github.com/typicode/json-server#getting-started" target="_blank" rel="noopener">https://github.com/typicode/json-server#getting-started</a></p><p><a href="http://mockjs.com/0.1/#" target="_blank" rel="noopener">Mock.js 官网</a><br><a href="https://github.com/typicode/json-server#getting-started" target="_blank" rel="noopener">json-server</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;进行 web 网站开发时，前后端分离导致开发进度不同，前端经常需要等待后端的接口数据完成开发才可以继续调试。且开发环境，测试环境和线上环境分离，本地开发时无法运用测试环境的接口，开发时的接口和最终部署的接口也并不相同，每次测试时来回部署代码要耗费很多时间。&lt;br&gt;&amp;emsp;&amp;emsp;使用 json-server + mockjs 编写 json 格式的模拟数据接口，在等待后端准备接口期间，前端可以使用假数据进行模拟。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="JavaScript" scheme="https://hyqskevin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>imblearn API</title>
    <link href="https://hyqskevin.github.io/2019/08/20/imbalanced_data_analysis/"/>
    <id>https://hyqskevin.github.io/2019/08/20/imbalanced_data_analysis/</id>
    <published>2019-08-20T01:31:47.000Z</published>
    <updated>2020-11-19T06:55:50.457Z</updated>
    
    <content type="html"><![CDATA[<p>imblearn 是 python 的第三方库，用于处理不平衡数据(imbalanced data)的分类，一般分为降采样，过采样和综合采样</p><a id="more"></a><h2 id="imblearn-under-sampling-降采样"><a href="#imblearn-under-sampling-降采样" class="headerlink" title="imblearn.under_sampling 降采样"></a>imblearn.under_sampling 降采样</h2><p>使用<code>imblearn.under_sampling.prototype_generation</code>来生成新样本</p><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p>sampling_strategy<br>return_indices<br>random_state<br>n_neighbors<br>n_seeds_S<br>kind_sel<br>n_jobs<br>ratio</p><h3 id="原型选择"><a href="#原型选择" class="headerlink" title="原型选择"></a>原型选择</h3><p><code>CondensedNearestNeighbour(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=None, n_seeds_S=1, n_jobs=1, ratio=None)</code><br>基于压缩最近邻方法执行欠采样<br><code>EditedNearestNeighbours(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=3, kind_sel=&#39;all&#39;, n_jobs=1, ratio=None)</code><br>基于编辑的最近邻居方法执行欠采样<br><code>RepeatedEditedNearestNeighbours(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=3, max_iter=100, kind_sel=&#39;all&#39;, n_jobs=1, ratio=None)</code><br>基于重复编辑的最近邻居方法执行欠采样<br><code>AllKNN(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=3, kind_sel=&#39;all&#39;, allow_minority=False, n_jobs=1, ratio=None)</code><br>基于 AllKNN 方法执行欠采样<br><code>InstanceHardnessThreshold(estimator=None, sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, cv=5, n_jobs=1, ratio=None)</code><br>根据实例硬度阈值执行欠采样<br><code>NearMiss(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, version=1, n_neighbors=3, n_neighbors_ver3=3, n_jobs=1, ratio=None)</code><br>基于 NearMiss 方法执行欠采样<br><code>NeighbourhoodCleaningRule(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=3, kind_sel=&#39;all&#39;, threshold_cleaning=0.5, n_jobs=1, ratio=None)</code><br>根据邻居清洁规则进行欠采样<br><code>OneSidedSelection(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=None, n_seeds_S=1, n_jobs=1, ratio=None)</code><br>基于单侧选择方法执行欠采样<br><code>RandomUnderSampler(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, replacement=False, ratio=None)[source]</code><br>用于执行随机欠采样<br><code>TomekLinks(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_jobs=1, ratio=None)</code><br>通过删除 Tomek 的链接来执行欠采样 s</p><h2 id="imblearn-over-sampling-过采样"><a href="#imblearn-over-sampling-过采样" class="headerlink" title="imblearn.over_sampling 过采样"></a>imblearn.over_sampling 过采样</h2><p>ADASYN（[sampling_strategy，…]） 使用自适应合成（ADASYN）采样方法对不平衡数据集执行过采样。<br>BorderlineSMOTE（[…]） 使用 Borderline SMOTE 进行过采样。<br>KMeansSMOTE（[…]） 在使用 SMOTE 进行过采样之前应用 KMeans 聚类。<br>RandomOverSampler（[…]） 用于执行随机过采样的类。<br>SMOTE（[sampling_strategy，…]） 使用 SMOTE 执行过采样的类。<br>SMOTENC（categorical_features） 标称和连续的合成少数过采样技术（SMOTE-NC）。<br>SVMSMOTE（[sampling_strategy，…]） 使用 SVM-SMOTE 进行过采样。</p><h2 id="imblearn-combine-组合采样"><a href="#imblearn-combine-组合采样" class="headerlink" title="imblearn.combine 组合采样"></a>imblearn.combine 组合采样</h2><p>SMOTEENN（[sampling_strategy，…]） 使用 SMOTE 执行过采样并使用 ENN 进行清洁的类。<br>SMOTETomek（[sampling_strategy，…]） 使用 SMOTE 执行过采样并使用 Tomek 链接进行清洁的类。</p><h2 id="imblearn-ensemble-方法整合"><a href="#imblearn-ensemble-方法整合" class="headerlink" title="imblearn.ensemble 方法整合"></a>imblearn.ensemble 方法整合</h2><p>BalancedBaggingClassifier（[…]） Bagging 分级机，具 ​​ 有额外的平衡功能。<br>BalancedRandomForestClassifier（[…]） 平衡的随机森林分类器。<br>EasyEnsemble（** kwargs） 通过迭代应用随机欠采样来创建集合集。<br>EasyEnsembleClassifier（[…]） 一袋平衡的提升学习者也被称为 EasyEnsemble。<br>RUSBoostClassifier（[…]） 随机欠采样集成在 AdaBoost 分类器的学习中。</p><hr><p>参考资料：<br><a href="https://imbalanced-learn.org/en/stable/index.html" target="_blank" rel="noopener">https://imbalanced-learn.org/en/stable/index.html</a><br><a href="https://github.com/scikit-learn-contrib/imbalanced-learn" target="_blank" rel="noopener">https://github.com/scikit-learn-contrib/imbalanced-learn</a><br><a href="https://blog.csdn.net/qq_31813549/article/details/79964973" target="_blank" rel="noopener">https://blog.csdn.net/qq_31813549/article/details/79964973</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;imblearn 是 python 的第三方库，用于处理不平衡数据(imbalanced data)的分类，一般分为降采样，过采样和综合采样&lt;/p&gt;
    
    </summary>
    
      <category term="repo" scheme="https://hyqskevin.github.io/categories/repo/"/>
    
    
      <category term="python" scheme="https://hyqskevin.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>tip:决策树、随机森林结果可视化</title>
    <link href="https://hyqskevin.github.io/2019/08/10/decision-tree-visualization/"/>
    <id>https://hyqskevin.github.io/2019/08/10/decision-tree-visualization/</id>
    <published>2019-08-10T08:56:30.000Z</published>
    <updated>2020-11-19T06:55:59.831Z</updated>
    
    <content type="html"><![CDATA[<p>scikit-learn 决策树结果的可视化,方便观察模型，以及发现模型中的问题。<br>需要安装 <code>graphviz</code></p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装-graphviz"><a href="#安装-graphviz" class="headerlink" title="安装 graphviz"></a>安装 graphviz</h3><p>linux：<code>sudo apt install graphviz</code><br>windows: 去官网下载 <a href="http://www.graphviz.org/" target="_blank" rel="noopener">http://www.graphviz.org/</a></p><p>设置环境变量：将 graphviz 的 bin 目录加到 PATH</p><p>安装 python 库 graphviz，pydotplus：<br><code>pip install graphviz, pydotplus</code></p><h2 id="可视化模型"><a href="#可视化模型" class="headerlink" title="可视化模型"></a>可视化模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = DecisionTreeClassifier(max_depth=max_depth_val)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用graphviz提取出节点数据</span></span><br><span class="line">dot_data = tree.export_graphviz(clf, out_file=<span class="keyword">None</span>, feature_names=feature_names, class_names=target_names, filled=<span class="keyword">True</span>, rounded=<span class="keyword">True</span>, special_characters=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h2 id="生成可视化文件"><a href="#生成可视化文件" class="headerlink" title="生成可视化文件"></a>生成可视化文件</h2><p>可利用 pydotplus 生成 pdf 文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = pydotplus.graph_from_dot_data(dot_data)</span><br><span class="line">graph.write_pdf(<span class="string">"dataset.pdf"</span>)</span><br></pre></td></tr></table></figure><p>也可以利用 Ipython 的图片显示功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</span><br><span class="line">graph = pydotplus.graph_from_dot_data(dot_data)</span><br><span class="line">Image(graph.create_png())</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://blog.csdn.net/ydyang1126/article/details/78842952" target="_blank" rel="noopener">https://blog.csdn.net/ydyang1126/article/details/78842952</a><br><a href="https://github.com/ljpzzz/machinelearning/blob/master/classic-machine-learning/decision_tree_classifier.ipynb" target="_blank" rel="noopener">https://github.com/ljpzzz/machinelearning/blob/master/classic-machine-learning/decision_tree_classifier.ipynb</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;scikit-learn 决策树结果的可视化,方便观察模型，以及发现模型中的问题。&lt;br&gt;需要安装 &lt;code&gt;graphviz&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="https://hyqskevin.github.io/categories/notes/"/>
    
    
      <category term="sklearn" scheme="https://hyqskevin.github.io/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>如何写日志</title>
    <link href="https://hyqskevin.github.io/2019/08/04/write_log/"/>
    <id>https://hyqskevin.github.io/2019/08/04/write_log/</id>
    <published>2019-08-04T08:56:30.000Z</published>
    <updated>2020-11-19T06:55:20.217Z</updated>
    
    <content type="html"><![CDATA[<p>在开发时学习书写日志的方法，方便做测试。<br>例举使用 python 和 java 上的日志记录<br>—loading…—</p><a id="more"></a><h2 id="常用日志框架"><a href="#常用日志框架" class="headerlink" title="常用日志框架"></a>常用日志框架</h2><p>log4j、Logging、commons-logging、slf4j、logback</p><p>Logging：Java 自带的日志工具类<br>Log4j：Apache 的一个开源日志框架，log4j 在 2015/08/05 这一天被 Apache 宣布停止维护了，用户需要切换到 Log4j2 上面去<br>commons-logging：日志的门面接口，它也是 apache 最早提供的日志门面接口，用户可以根据喜好选择不同的日志实现框架，而不必改动日志定义<br>Slf4j：Simple Logging Facade for Java，即简单日志门面接口<br>Logback：Slf4j 的原生实现框架，同样也是出自 Log4j 一个人之手，但拥有比 log4j 更多的优点、特性和更做强的性能，现在基本都用来代替 log4j 成为主流</p><ol><li>commons-loggin、slf4j 只是一种日志抽象门面，不是具体的日志框架。</li><li>log4j、logback 是具体的日志实现框架。</li><li>推荐使用 <code>slf4j + logback</code> 还有<code>slf4j + log4j</code> <code>commons-logging + log4j</code> 这两种日志组合框架。</li></ol><ul><li>Python 的 logging 模块提供了通用的日志系统。logging 模块与 log4j 的机制相同，只是具体的实现细节不同。</li></ul><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><div class="table-container"><table><thead><tr><th>日志级别(Java)</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>OFF</td><td style="text-align:left">关闭：最高级别，不输出日志。</td></tr><tr><td>FATAL</td><td style="text-align:left">致命：输出非常严重的可能会导致应用程序终止的错误。</td></tr><tr><td>ERROR</td><td style="text-align:left">错误：输出错误，但应用还能继续运行。</td></tr><tr><td>WARN</td><td style="text-align:left">警告：输出可能潜在的危险状况。</td></tr><tr><td>INFO</td><td style="text-align:left">信息：输出应用运行过程的详细信息。</td></tr><tr><td>DEBUG</td><td style="text-align:left">调试：输出更细致的对调试应用有用的信息。</td></tr><tr><td>TRACE</td><td style="text-align:left">跟踪：输出更细致的程序运行轨迹。</td></tr><tr><td>ALL</td><td style="text-align:left">所有：输出所有级别信息。</td></tr></tbody></table></div><p>Java：ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF<br>Python：NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</p><h2 id="Log4J-的运用"><a href="#Log4J-的运用" class="headerlink" title="Log4J 的运用"></a>Log4J 的运用</h2><p>Log4j 有三个主要的组件：Loggers(记录器)，Appenders(输出源)和 Layouts(布局)，这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出</p><h2 id="logging-的运用"><a href="#logging-的运用" class="headerlink" title="logging 的运用"></a>logging 的运用</h2><p>logging 模块提供 logger、handler、filter、formatter</p><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><p>记录获取到的数据，通过模块的 getLogger(name)函数获得</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger = logging.getLogger(<span class="string">'test'</span>)    <span class="comment"># 获取名为 test 的 logger</span></span><br><span class="line">logger.addHandler(handler)           <span class="comment"># 为 logger 添加 handler</span></span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>setLevel(lvl)</td><td>设置日志级别</td></tr><tr><td>isEnabledFor(lvl)</td><td>检查某级别的日志是否启用</td></tr><tr><td>getEffectiveLevel()</td><td>获取实际的日志级别</td></tr><tr><td>debug/warning/info/error(msg, *args, **kwargs)</td><td>输出对应级别的日志</td></tr><tr><td>log(lvl, msg, *args, **kwargs)</td><td>输出指定级别的日志</td></tr><tr><td>addFilter(filt)/removeFilter(filt)</td><td>添加或删除指定的过滤器</td></tr><tr><td>addHandler(hdlr)/removeHandler(hdlr)</td><td>添加或删除指定的处理器</td></tr></tbody></table></div><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>用于指定日志向哪里输出（文件、终端等等）</p><p>常用的 Handler 有以下几种：</p><ul><li>StreamHandler， 用于向标准输入输出流等输出日志。</li><li>FileHandler，用于向文件输出日志。</li><li>NullHandler，什么也不输出。</li><li>RotatingFileHandler，向文件输出日志，如果文件到达指定大小，创建新文件并继续输出日志。</li></ul><p>相关 handler 类型参考<a href="https://docs.python.org/zh-cn/3/library/logging.handlers.html#module-logging.handlers" target="_blank" rel="noopener">python 官方文档</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler = logging.handlers.RotatingFileHandler(LOG_FILE,axBytes=<span class="number">1024</span>*<span class="number">1024</span>, backupCount = <span class="number">5</span>) <span class="comment"># 实例化 handler</span></span><br></pre></td></tr></table></figure><h3 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h3><p>指定日志记录输出的具体格式，采用的是 %(key)s 的形式<br>formatter 构造方法需要两个参数：消息的格式字符串和日期字符串</p><div class="table-container"><table><thead><tr><th>日志格式</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td>%(name)s</td><td style="text-align:left">生成日志的 Logger 名称</td></tr><tr><td>%(levelno)s</td><td style="text-align:left">数字形式的日志级别，包括 DEBUG, INFO, WARNING, ERROR 和 CRITICAL</td></tr><tr><td>%(levelname)s</td><td style="text-align:left">文本形式的日志级别，包括’DEBUG’、 ‘INFO’、 ‘WARNING’、 ‘ERROR’ 和’CRITICAL’</td></tr><tr><td>%(pathname)s</td><td style="text-align:left">输出该日志的语句所在源文件的完整路径（如果可用）</td></tr><tr><td>%(filename)s</td><td style="text-align:left">文件名</td></tr><tr><td>%(module)s</td><td style="text-align:left">输出该日志的语句所在的模块名</td></tr><tr><td>%(funcName)s</td><td style="text-align:left">调用日志输出函数的函数名</td></tr><tr><td>%(lineno)d</td><td style="text-align:left">调用日志输出函数的语句所在的代码行（如果可用）</td></tr><tr><td>%(created)f</td><td style="text-align:left">日志被创建的时间，UNIX 标准时间格式，表示从 1970-1-1 00:00:00 UTC 计算起的秒数</td></tr><tr><td>%(relativeCreated)d</td><td style="text-align:left">日志被创建时间与日志模块被加载时间的时间差，单位为毫秒</td></tr><tr><td>%(asctime)s</td><td style="text-align:left">日志创建时间。默认格式是 “2003-07-08 16:49:45,896”，逗号后为毫秒数</td></tr><tr><td>%(msecs)d</td><td style="text-align:left">毫秒级别的日志创建时间</td></tr><tr><td>%(thread)d</td><td style="text-align:left">线程 ID（如果可用）</td></tr><tr><td>%(threadName)s</td><td style="text-align:left">线程名称（如果可用）</td></tr><tr><td>%(process)d</td><td style="text-align:left">进程 ID（如果可用）</td></tr><tr><td>%(message)s</td><td style="text-align:left">日志信息</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 日志样例</span><br><span class="line">2019-08-04 23:21:59,682 - log_test.py:16 - test - first info message</span><br><span class="line">2019-08-04 23:21:59,682 - log_test.py:17 - test - first debug message</span><br><span class="line"></span><br><span class="line"># 日志格式</span><br><span class="line">%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出</p><h4 id="config-模块配置日志"><a href="#config-模块配置日志" class="headerlink" title="config 模块配置日志"></a>config 模块配置日志</h4><p>logging.basicConfig()<br>logging</p><h3 id="python-日志示例"><a href="#python-日志示例" class="headerlink" title="python 日志示例"></a>python 日志示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"></span><br><span class="line">LOG_FILE = <span class="string">'test.log'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">'test'</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化handler</span></span><br><span class="line">consoleHandler = logging.StreamHandler()</span><br><span class="line">Filehandler = logging.handlers.RotatingFileHandler(LOG_FILE,axBytes = <span class="number">1024</span>*<span class="number">1024</span>, backupCount = <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化formatter</span></span><br><span class="line">fmt = <span class="string">'%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s'</span></span><br><span class="line">formatter = logging.Formatter(fmt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 handler 添加 formatter</span></span><br><span class="line">consoleHandler.setFormatter(formatter)</span><br><span class="line">Filehandler。setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加到logger中</span></span><br><span class="line">logger.addHandler(consolehandler)</span><br><span class="line">logger.addHandler(Filehandler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印日志</span></span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.warning(<span class="string">'warn message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical meaasge'</span>)</span><br><span class="line">logger.debug(<span class="string">'%s 自定义信息'</span> % <span class="string">'define message'</span>)</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://blog.csdn.net/wud_jiyanhui/article/details/6213443" target="_blank" rel="noopener">https://blog.csdn.net/wud_jiyanhui/article/details/6213443</a><br><a href="https://blog.csdn.net/u011054333/article/details/69215660" target="_blank" rel="noopener">https://blog.csdn.net/u011054333/article/details/69215660</a><br><a href="https://help.aliyun.com/document_detail/28990.html?spm=a2c4g.11186623.6.746.7cfa66d8dwy2XO" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/28990.html?spm=a2c4g.11186623.6.746.7cfa66d8dwy2XO</a><br><a href="https://help.aliyun.com/document_detail/28989.html?spm=a2c4g.11186623.6.745.3ef949faCiQ7PW" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/28989.html?spm=a2c4g.11186623.6.745.3ef949faCiQ7PW</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发时学习书写日志的方法，方便做测试。&lt;br&gt;例举使用 python 和 java 上的日志记录&lt;br&gt;—loading…—&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="python" scheme="https://hyqskevin.github.io/tags/python/"/>
    
      <category term="log" scheme="https://hyqskevin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>boosting</title>
    <link href="https://hyqskevin.github.io/2019/08/01/boosting/"/>
    <id>https://hyqskevin.github.io/2019/08/01/boosting/</id>
    <published>2019-08-01T01:56:30.000Z</published>
    <updated>2020-11-19T06:56:07.853Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xgboost.ai/" target="_blank" rel="noopener">XgBoost</a> 和 <a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="noopener">LightGBM</a> 官方文档阅读和算法学习<br><code>*</code>号为未解释完全，具体使用方法请参考官方文档</p><a id="more"></a><h2 id="XgBoost"><a href="#XgBoost" class="headerlink" title="XgBoost"></a>XgBoost</h2><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p><code>booster</code> [default= gbtree ]  基础模型类型，可选参数包括: gbtree、gblinear、dart，其中 gbtree、dart 为树模型、gblinear 为线性函数模型</p><p><code>eta</code> 学习率</p><p><code>tree_method</code> XGBoost 中树的构造算法，可选项包括: auto, exact, approx, hist, gpu_exact, gpu_hist</p><p><code>eval_metric</code> 依据目标函数选择评估指标<br>rmse: 根均方误差<br>mae: 平均绝对值误差<br>logloss: 负的似然函数<br>error: 二分类问题的分类错误率<br>merror: 多分类问题的分类错误率<br>mlogloss: 多分类问题的负似然函数<br>auc: IOC 曲线下面积<br>aucpr: PR 曲线下面积</p><p><code>updater</code> 线性模型的拟合算法<br>shotgun: 基于 shotgun 算法的坐标下降法<br>coord_descent: 普通的坐标下降法<br>feature_selector: 特征选择和排序算法</p><p><code>objective</code> 训练的模型类型和目标函数<br>reg:linear: 线性回归<br>reg:logistic: 逻辑回归<br>binary:logistic: 二分类问题, 输出概率值<br>binary:logitraw: 二分类问题, 输出得分值，需要通过 sigmoid 函数转化成概率值<br>binary:hinge: 二分类问题，使用铰链损失函数,输出 0 或 1，而不是概率值<br>count:poisson: 用于计数问题的泊松分布，输出泊松分布的均值。<br>survival:cox: Cox regression for right censored survival time data<br>multi:softmax: 多分类目标函数, 使用此目标函数，需要设置样本类别数据： num_class<br>multi:softprob: 同 softmax, 但是输出的结果为 ndata * nclass 维的向量，表示样本属于每个类别的概率</p><p><code>cyclic</code>: 循环变量特征<br><code>shuffle</code>: 类型与循环变量特征，但是在每次更新时都会随机打乱特征的顺序<br><code>random</code>: 随机(带替换)的坐标选择器<br><code>greedy</code>: 选择最大梯度的坐标<br><code>thrifty</code>: 近似 greedy 的坐标选择器<br><code>top_k</code>: greedy 算法和 thrifty 算法选择的最优特征数量，0 表示不限制。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><strong>1. 数据结构类，提供数据的构建和处理</strong><br><code>xgboost.DMatrix(data, label=None, missing=None, weight=None, silent=False, feature_names=None, feature_types=None)</code></p><p><code>data</code>数据源或文件路径<br><code>label</code>训练数据的标签<br><code>missing</code>缺省值表示字符，如果没填, 默认值为：np.nan<br><code>weight</code>每个样本的权重<br><code>silent</code>构造数据结构时是否显示日志<br><code>feature_names</code>各个特征的名称<br><code>feature_types</code>各个特征的数据类型<br><code>nthread</code> 加载数据开启的线程数</p><p><strong>2. 模型类，提供了一些基础的函数，如模型加载、保存、评估和预测等方法</strong><br><code>xgboost.Booster(params=None, cache=(), model_file=None)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">load_model(fname)</span><br><span class="line">从文件或内存中加载模型，参数含义如下：</span><br><span class="line"></span><br><span class="line">fname (string <span class="keyword">or</span> a memory buffer) – 模型文件名称或内存缓存对象</span><br><span class="line"><span class="number">2.</span> save_model(fname)</span><br><span class="line">将模型保存到文件中，参数的含义如下：</span><br><span class="line"></span><br><span class="line">fname (string) – 输出文件的名称</span><br><span class="line"><span class="number">3.</span> eval(data, name, iteration)</span><br><span class="line">用给定的数据评估模型好坏，参数的含义如下:</span><br><span class="line"></span><br><span class="line">data (DMatrix) – 用于评估模型的数据</span><br><span class="line"></span><br><span class="line">name (str, 可选) – 用于评估模型的数据集名称</span><br><span class="line"></span><br><span class="line">iteration (int, 可选) –迭代次数</span><br></pre></td></tr></table></figure><p><strong>3. 对模型进行训练</strong><br><code>xgboost.train(params, dtrain, num_boost_round=10, evals=(), obj=None, feval=None, maximize=False, early_stopping_rounds=None, evals_result=None, verbose_eval=True, learning_rates=None, xgb_model=None, callbacks=None)</code></p><p><code>params</code>配置参数<br><code>dtrain</code>训练数据<br><code>num_boost_round</code>生成树的数量<br><code>evals</code>评估数据<br><code>obj</code>自定义的目标函数<br><code>feval</code>自定义的评价函数<br><code>maximize</code>是否最大化评价指标<br><code>early_stopping_rounds</code>错误率 early_stopping_rounds 轮未下降，则停止训练<br><code>evals_result</code>模型评估结果<br><code>learning_rates</code>学习率<br><code>xgb_model</code>在训练前加载之前训练的模型<br><code>callback</code>设置回调函数，比如重新设置学习率</p><p><strong>4. 对数据分类</strong><br><code>xgboost.XGBClassifier(max_depth=3, learning_rate=0.1, n_estimators=100, silent=True, objective=&#39;binary:logistic&#39;, nthread=-1, gamma=0, min_child_weight=1, max_delta_step=0, subsample=1, colsample_bytree=1, colsample_bylevel=1, reg_alpha=0, reg_lambda=1, scale_pos_weight=1, base_score=0.5, seed=0, missing=None)</code></p><p><code>max_depth</code> 最大树深度<br><code>learning_rate</code> 学习率<br><code>n_estimators</code> 树的迭代次数<br><code>gamma</code> 节点分裂需要下降的最小损失<br><code>min_child_weight</code> 节点中样本的最小权重和<br><code>max_delta_step</code> 每轮允许叶子输出值的最大增量<br><code>subsample</code> 每轮训练使用的样本数量等于样本总数乘以采样率<br><code>colsample_bytree</code> 每轮训练使用的特征占比<br><code>colsample_bylevel</code> 每层训练使用的特征占比<br><code>reg_alpha</code> L1 正则<br><code>reg_lambda</code> L2 正则<br><code>scale_pos_weight</code> 用于控制正例和负例均衡的权重<br><code>base_score</code> 初始时各个样本的得分</p><p><strong>5. 数据拟合和预测</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xgboost.fit(X, y, sample_weight=<span class="keyword">None</span>, eval_set=<span class="keyword">None</span>, eval_metric=<span class="keyword">None</span>, early_stopping_rounds=<span class="keyword">None</span>, verbose=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># sample_weight：每个训练样本的权重</span></span><br><span class="line"><span class="comment"># eval_set：设置验证集</span></span><br><span class="line"><span class="comment"># eval_metric：验证的度量指标</span></span><br><span class="line"><span class="comment"># early_stopping_rounds` 指定连续多少轮未改善后停止</span></span><br><span class="line"></span><br><span class="line">xgboost.predict(data, output_margin=<span class="keyword">False</span>, ntree_limit=<span class="number">0</span>, pred_leaf=<span class="keyword">False</span>, pred_contribs=<span class="keyword">False</span>, approx_contribs=Flase, pred_interactions=<span class="keyword">False</span>, validate_features=Flase)`</span><br><span class="line"></span><br><span class="line"><span class="comment"># output_margin 是否输出原始未经转化的值</span></span><br><span class="line"><span class="comment"># ntree_limit 用于预测的树的数量，默认为0，代表使用所有树进行预测</span></span><br><span class="line"><span class="comment"># pred_leaf 指明每条数据分别落到每棵树的哪个叶子节点上</span></span><br><span class="line"><span class="comment"># pred_contribs 指明每个样本的每个特征对预测结果的贡献值</span></span><br><span class="line"><span class="comment"># approx_contribs 是否启用特征贡献大小的预估功能</span></span><br><span class="line"><span class="comment"># pred_interactions 指明两两特征间相互影响的SHAP值</span></span><br><span class="line"><span class="comment"># validate_features首先验证待预测的数据特征名称是否与模型中的特征名称相同，默认情况下，系统认为他们是相同的，不进行验证</span></span><br></pre></td></tr></table></figure><ul><li><code>class xgboost.XGBRegressor()</code>用于回归任务</li></ul><h3 id="XgBoost-示例"><a href="#XgBoost-示例" class="headerlink" title="XgBoost 示例"></a>XgBoost 示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"></span><br><span class="line">train_data = pd.read_csv(<span class="string">'train.csv'</span>)   <span class="comment"># 读取数据</span></span><br><span class="line">y = train_data.pop(<span class="string">'30'</span>).values   <span class="comment"># 用pop方式将训练数据中的标签值y取出来，作为训练目标，这里的‘30’是标签的列名</span></span><br><span class="line">col = train_data.columns</span><br><span class="line">x = train_data[col].values  <span class="comment"># 剩下的列作为训练数据</span></span><br><span class="line">train_x, valid_x, train_y, valid_y = train_test_split(x, y, test_size=<span class="number">0.333</span>, random_state=<span class="number">0</span>)   <span class="comment"># 分训练集和验证集</span></span><br><span class="line"><span class="comment"># 这里不需要Dmatrix</span></span><br><span class="line"></span><br><span class="line">parameters = &#123;</span><br><span class="line">              <span class="string">'max_depth'</span>: [<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>],</span><br><span class="line">              <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.15</span>],</span><br><span class="line">              <span class="string">'n_estimators'</span>: [<span class="number">500</span>, <span class="number">1000</span>, <span class="number">2000</span>, <span class="number">3000</span>, <span class="number">5000</span>],</span><br><span class="line">              <span class="string">'min_child_weight'</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">              <span class="string">'max_delta_step'</span>: [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              <span class="string">'subsample'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.85</span>, <span class="number">0.95</span>],</span><br><span class="line">              <span class="string">'colsample_bytree'</span>: [<span class="number">0.5</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>],</span><br><span class="line">              <span class="string">'reg_alpha'</span>: [<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],</span><br><span class="line">              <span class="string">'reg_lambda'</span>: [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>],</span><br><span class="line">              <span class="string">'scale_pos_weight'</span>: [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">xlf = xgb.XGBClassifier(max_depth=<span class="number">10</span>,</span><br><span class="line">            learning_rate=<span class="number">0.01</span>,</span><br><span class="line">            n_estimators=<span class="number">2000</span>,</span><br><span class="line">            silent=<span class="keyword">True</span>,</span><br><span class="line">            objective=<span class="string">'binary:logistic'</span>,</span><br><span class="line">            nthread=<span class="number">-1</span>,</span><br><span class="line">            gamma=<span class="number">0</span>,</span><br><span class="line">            min_child_weight=<span class="number">1</span>,</span><br><span class="line">            max_delta_step=<span class="number">0</span>,</span><br><span class="line">            subsample=<span class="number">0.85</span>,</span><br><span class="line">            colsample_bytree=<span class="number">0.7</span>,</span><br><span class="line">            colsample_bylevel=<span class="number">1</span>,</span><br><span class="line">            reg_alpha=<span class="number">0</span>,</span><br><span class="line">            reg_lambda=<span class="number">1</span>,</span><br><span class="line">            scale_pos_weight=<span class="number">1</span>,</span><br><span class="line">            seed=<span class="number">1440</span>,</span><br><span class="line">            missing=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有了gridsearch我们便不需要fit函数</span></span><br><span class="line">gsearch = GridSearchCV(xlf, param_grid=parameters, scoring=<span class="string">'accuracy'</span>, cv=<span class="number">3</span>)</span><br><span class="line">gsearch.fit(train_x, train_y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Best score: %0.3f"</span> % gsearch.best_score_)</span><br><span class="line">print(<span class="string">"Best parameters set:"</span>)</span><br><span class="line">best_parameters = gsearch.best_estimator_.get_params()</span><br><span class="line"><span class="keyword">for</span> param_name <span class="keyword">in</span> sorted(parameters.keys()):</span><br><span class="line">    print(<span class="string">"\t%s: %r"</span> % (param_name, best_parameters[param_name]))</span><br></pre></td></tr></table></figure><h2 id="LightGBM"><a href="#LightGBM" class="headerlink" title="LightGBM"></a>LightGBM</h2><h3 id="paramenter-常用参数"><a href="#paramenter-常用参数" class="headerlink" title="paramenter 常用参数"></a>paramenter 常用参数</h3><p><strong>objective</strong>:<br>‘regression’,’regression_l2’,’mean_squared_error’,’mse’,’l2_root’,’root_mean_squred_error’,’rmse’： 表示回归任务，但是使用 L2 损失函数。默认为’regression’<br>‘binary’： 表示二分类任务，使用对数损失函数作为目标函数。<br>‘multiclass’： 表示多分类任务，使用 softmax 函数作为目标函数。必须设置 num_class 参数<br>‘multiclassova’,’multiclass_ova’,’ova’,’ovr’： 表示多分类任务，使用 one-vs-all 的二分类目标函数。必须设置 num_class 参数<br>‘regression_l1’,’mae’,’mean_absolute_error’： 表示回归任务，但是使用 L1 损失函数。<br>‘huber’： 表示回归任务，但是使用 huber 损失函数。<br>‘fair’： 表示回归任务，但是使用 fair 损失函数。<br>‘poisson’： 表示 Poisson 回归任务。<br>‘quantile’： 表示 quantile 回归任务。<br>‘quantile_l2’：表示 quantile 回归任务，但是使用了 L2 损失函数。<br>‘mape’,’mean_absolute_precentage_error’： 表示回归任务，但是使用 MAPE 损失函数<br>‘gamma’： 表示 gamma 回归任务。<br>‘tweedie’： 表示 tweedie 回归任务。<br>‘xentropy’,’cross_entropy’： 目标函数为交叉熵（同时具有可选择的线性权重）。要求标签是[0,1] 之间的数值。<br>‘xentlambda’,’cross_entropy_lambda’： 替代了参数化的 cross_entropy 。要求标签是[0,1] 之间的数值。<br>‘lambdarank’：表示排序任务。</p><p><strong>boosting_type</strong>: // 基学习器模型算法<br>‘gbdt’： 表示传统的梯度提升决策树。默认值为’gbdt’<br>‘rf’： 表示随机森林。<br>‘dart’： 表示带 dropout 的 gbdt<br>‘goss’：表示 Gradient-based One-Side Sampling 的 gbdt</p><p><strong>metric</strong>：//指定度量的指标<br>‘l1’ 或者 mean_absolute_error 或者 mae 或者 regression_l1： 表示绝对值损失<br>‘l2’ 或者 mean_squared_error 或者 mse 或者 regression_l2 或者 regression：表示平方损失<br>‘l2_root’ 或者 root_mean_squared_error 或者 rmse：表示开方损失<br>‘quantile’ 表示 Quantile 回归中的损失<br>‘mape’ 或者 ‘mean_absolute_percentage_error’ 表示 MAPE 损失<br>‘huber’ 表示 huber 损失<br>‘fair’ 表示 fair 损失<br>‘poisson’ 表示 poisson 回归的负对数似然<br>‘gamma’ 表示 gamma 回归的负对数似然<br>‘gamma_deviance’ 表示 gamma 回归的残差的方差<br>‘tweedie’ 表示 Tweedie 回归的负对数似然<br>‘ndcg’ 表示 NDCG<br>‘map’ 或者’mean_average_precision’ 表示平均的精度<br>‘auc’ 表示 AUC<br>‘binary_logloss’或者’binary’ 表示二类分类中的对数损失函数<br>‘binary_error’ 表示二类分类中的分类错误率<br>‘multi_logloss’或者 ‘multiclass’或者 ‘softmax’或者 ‘multiclassova’或者 ‘multiclass_ova’,或者’ova’或者 ‘ovr’ 表示多类分类中的对数损失函数<br>‘multi_error’ 表示多分类中的分类错误率<br>‘xentropy’或者’cross_entropy’ 表示交叉熵<br>‘xentlambda’ 或者’cross_entropy_lambda’ 表示 intensity 加权的交叉熵<br>‘kldiv’或者’kullback_leibler’ 表示 KL 散度</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>1. 数据结构类，提供数据的构建和处理</strong><br><code>lightgbm.Dataset(data, label=None, max_bin=None, reference=None, weight=None, group=None, init_score=None, silent=False, feature_name=&#39;auto&#39;, categorical_feature=&#39;auto&#39;, params=None, free_raw_data=True)</code></p><p><code>label</code> 指定数据的标签列<br><code>max_bin</code> 特征值最大分类数量<br><code>reference</code> 增加评估参照，评估模型时使用，reference=train<br><code>weight</code> 设置权重<br><code>group</code> 设置数据组的大小<br><code>init_score</code> 加入之前的分数<br><code>silent</code> 是否在训练过程中屏蔽输出<br><code>feature_name</code> 特征名字<br><code>categorical_feature</code>设置分类特征<br><code>free_raw_data</code> 创建完后释放数据</p><p><strong>2. 模型类，提供了一些基础的函数，如模型加载、保存、评估和预测等方法</strong><br><code>lightgbm.Booster(params=None, train_set=None, model_file=None, model_str=None, silent=False)</code><br><code>params</code> 一个字典或者 None，给出了 Booster 的参数。默认为 None<br><code>train_set</code> 一个 Dataset 对象或者 None，给出了训练集。 默认为 None<br><code>model_file</code> 一个字符串或者 None，给出了 model file 的路径。 默认为 None<br><code>silent</code> 一个布尔值，指示是否在构建过程中打印消息。默认为 False</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lightgbm.add_valid(data,name) <span class="comment"># 添加一个验证集。</span></span><br><span class="line">lightgbm.current_iteration() <span class="comment"># 返回当前的迭代的index（即迭代的编号）</span></span><br><span class="line">lightgbm.dump_model(num_iteration=<span class="number">-1</span>) <span class="comment"># dump 当前的Booster 对象为json 格式。</span></span><br><span class="line">lightgbm.eval(data,name,feval=<span class="keyword">None</span>) <span class="comment"># 对指定的数据集evaluate</span></span><br><span class="line">lightgbm.eval_train(feval=<span class="keyword">None</span>) <span class="comment"># 对训练集进行evaluate</span></span><br><span class="line">lightgbm.eval_valid(feval=<span class="keyword">None</span>) <span class="comment"># 对验证集进行evaluate</span></span><br><span class="line">lightgbm.feature_importance(importance_type=<span class="string">'split'</span>, iteration=<span class="number">-1</span>) <span class="comment"># 获取特征的importance</span></span><br><span class="line">lightgbm.feature_name() <span class="comment"># 获取每个特征的名字。</span></span><br><span class="line">lightgbm.free_dataset() <span class="comment"># 释放Booster 对象的数据集</span></span><br><span class="line">lightgbm.free_network() <span class="comment"># 释放Booster 对象的Network</span></span><br><span class="line">lightgbm.get_leaf_output(tree_id, leaf_id) <span class="comment"># 获取指定叶子的输出</span></span><br><span class="line">lightgbm.num_feature() <span class="comment"># 获取特征的数量（即由多少列特征）</span></span><br><span class="line">lightgbm.reset_parameter(params) <span class="comment">#重设Booster 的参数。</span></span><br><span class="line">lightgbm.rollback_one_iter() <span class="comment"># 将Booster 回滚一个迭代步</span></span><br><span class="line">lightgbm.save_model(filename,num_iteration=<span class="number">-1</span>) <span class="comment"># 保存Booster 对象到文件中。</span></span><br><span class="line">lightgbm.set_attr(**kwargs) <span class="comment"># 设置Booster 的属性。</span></span><br><span class="line">lightgbm.set_network(machines,local_listen_port=<span class="number">12400</span>,listen_time_out=<span class="number">120</span>,num_machines=<span class="number">1</span>) <span class="comment"># 配置网络</span></span><br><span class="line">lightgbm.set_train_data_name(name) <span class="comment"># 设置训练集的名字</span></span><br><span class="line">lightgbm.update(train_set=<span class="keyword">None</span>, fobj=<span class="keyword">None</span>) <span class="comment"># 更新一个迭代步</span></span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><strong>1. <code>lightgbm.train()</code>执行训练</strong></p><p><code>lightgbm.train(params, train_set, num_boost_round=100, valid_sets=None, valid_names=None, fobj=None, feval=None, init_model=None, feature_name=&#39;auto&#39;, categorical_feature=&#39;auto&#39;, early_stopping_rounds=None, evals_result=None, verbose_eval=True, learning_rates=None, keep_training_booster=False, callbacks=None)</code></p><p><code>params</code> 相关参数配置，另外导入字典<br><code>train_set</code> 训练数据<br><code>num_boost_round</code> boost 迭代次数<br><code>valid_sets</code>，<code>valid_names</code> 设置训练时用于评估的数据集 <em><br><code>fobj</code> 自定义目标函数 preds, train_data -&gt; grad,hess </em><br><code>feval</code> 自定义评估函数 preds, train<em>data -&gt; eval_name, eval_result, is_higher_better </em><br><code>init_model</code> 导入之前训练数据<br><code>feature_name</code> 指定特征名字，数据源为 pandas DataFrame 会使用里面的 column<em>names<br><code>categorical_feature</code> 指定分类特征<br><code>early_stopping_rounds</code> 指定连续多少轮未改善后停止<br><code>evals_result</code> 指定字典存储 valid_sets 中验证的结果 </em><br><code>verbose_eval</code> 设置打印评估的间隔，可设置每个提升阶段打印或间隔<code>verbose_eval</code>个阶段打印<br><code>learning_rates</code> 设置学习率<br><code>keep_training_booster</code> 设置训练得到的 booster 是否继续训练<br><code>callbacks</code> 设置每次迭代后需要执行的函数</p><p>最后返回 booster 实例</p><p><strong>2. <code>lightgbm.cv()</code> 执行交叉检验</strong></p><p><code>lightgbm.cv(params, train_set, num_boost_round=10, folds=None, nfold=5, stratified=True, shuffle=True, metrics=None, fobj=None, feval=None, init_model=None, feature_name=&#39;auto&#39;,categorical_feature=&#39;auto&#39;, early_stopping_rounds=None, fpreproc=None, verbose_eval=None, show_stdv=True, seed=0, callbacks=None)</code></p><p><code>folds</code>：一个生成器、一个迭代器、或者 None <em><br><code>nfold</code>：指定交叉检验的数量。默认为 5<br><code>stratified</code>：指示是否进行分层拆分<br><code>shuffle</code>：指示是否在拆分之前先混洗数据<br><code>metrics</code>：指定评估度量标准，在 params 中设置<br><code>fpreproc</code>：设置预处理函数，在训练开始之前进行 </em><br><code>show_stdv</code>：在训练过程中展示标准差信息<br><code>seed</code>：一个整数，给出了生成 fold 的随机数种子 *</p><p>最后以字典的形式返回检验结果的均值和标准差</p><h3 id="scikit-learn-API"><a href="#scikit-learn-API" class="headerlink" title="scikit-learn API"></a>scikit-learn API</h3><p><strong>1. LGBMMOdel</strong><br>实现 lightgbm 在 scikir-learn 中的接口，详见分类和回归任务</p><p><strong>2. LGBMClassifier: LGBMModel 的子类，用于分类任务</strong></p><p><code>lightgbm.LGBMClassifier(boosting_type=&#39;gbdt&#39;, num_leaves=31, max_depth=-1, learning_rate=0.1, n_estimators=10, max_bin=255, ubsample_for_bin=200000, objective=None, min_split_gain=0.0, in_child_weight=0.001, min_child_samples=20, subsample=1.0, subsample_freq=1, colsample_bytree=1.0, reg_alpha=0.0, reg_lambda=0.0, random_state=None, n_jobs=-1, silent=True, **kwargs)</code></p><p><code>boosting_type</code>： 指定学习器的算法’gbdt, rf, dart, goss’<br><code>num_leaves</code>：一棵树上的叶子数<br><code>max_depth</code>：树模型的最大深度<br><code>learning_rate</code>：学习率<br><code>n_estimators</code>：提升树的数量<br><code>max_bin</code>： 每个特征的最大分支数量<br><code>class_weight</code>：给出了每个类别的权重占比<br><code>subsample_for_bin</code>：构建直方图的样本的数量 <em><br><code>objective</code>：问题类型以及对应的目标函数，对于 LGBMRegressor 为’regression’；对于 LGBMClassifier 为’binary’ 或者’multiclass’；对于 LGBMRanker 为’lambdarank’<br><code>min_split_gain</code>：执行切分的最小增益<br><code>min_child_weight</code>：一个叶子节点上的最小权重之和，默认为 1e-3<br><code>min_child_samples</code>： 一个叶子节点上包含的最少样本数量<br><code>subsample</code>： 表示训练样本的采样比例，取值范围为[0.0,1.0]。如果小于 1.0，则 lightgbm 会在每次迭代中随机选择部分样本来训练（非重复采样）<br><code>subsample_freq</code>：表示训练样本的采样频率<br><code>colsample_bytree</code>：表示特征的采样比例，取值范围为[0.0,1.0]。如果小于 1.0，则 lightgbm 会在每次迭代中随机选择部分特征<br><code>reg_alpha</code>：L1 正则化系数<br><code>reg_lambda</code>：L2 正则化系数<br><code>random_state</code>：随机数种子 </em><br><code>n_jobs</code>：并行线程数量<br><code>silent</code>：是否在训练过程中屏蔽输出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line">gbm = lgb.LGBMClassifier()</span><br><span class="line">gbm.n_features_：<span class="comment"># 给出了特征的数量</span></span><br><span class="line">gbm.classes_：<span class="comment"># 样本的标签</span></span><br><span class="line">gbm.n_classes_：<span class="comment"># 类别的数量</span></span><br><span class="line">gbm.best_score_：<span class="comment"># 训练完毕模型的最好的score</span></span><br><span class="line">gbm.best_iteration_：<span class="comment"># 训练完毕模型的最好的迭代数</span></span><br><span class="line">gbm.objective_：<span class="comment"># 训练模型的目标函数</span></span><br><span class="line">gbm.booster_：<span class="comment"># 底层的Booster 对象</span></span><br><span class="line">gbm.evals_result_：<span class="comment"># 模型评估结果</span></span><br><span class="line">gbm.feature_importances_： <span class="comment"># 特征的重要性</span></span><br></pre></td></tr></table></figure><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gbm.fit(X, y, sample_weight=<span class="keyword">None</span>, init_score=<span class="keyword">None</span>, eval_set=<span class="keyword">None</span>, eval_names=<span class="keyword">None</span>, eval_sample_weight=<span class="keyword">None</span>, eval_init_score=<span class="keyword">None</span>, eval_metric=<span class="string">'logloss'</span>, early_stopping_rounds=<span class="keyword">None</span>, verbose=<span class="keyword">True</span>, feature_name=<span class="string">'auto'</span>, categorical_feature=<span class="string">'auto'</span>, callbacks=<span class="keyword">None</span>)`</span><br><span class="line"><span class="comment"># sample_weight：每个训练样本的权重</span></span><br><span class="line"><span class="comment"># init_score：每个训练样本的初始分数</span></span><br><span class="line"><span class="comment"># group：每个训练样本的分组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eval_set：设置验证集</span></span><br><span class="line"><span class="comment"># eval_names：设置验证集的名字</span></span><br><span class="line"><span class="comment"># eval_sample_weight：验证集中每个样本的权重</span></span><br><span class="line"><span class="comment"># eval_init_score：每个验证集中，每个样本的init score</span></span><br><span class="line"><span class="comment"># eval_group：每个验证集中，每个样本的分组</span></span><br><span class="line"><span class="comment"># eval_metric：验证的方法</span></span><br><span class="line"></span><br><span class="line">gbm.predict(data, num_iteration=<span class="number">-1</span>, raw_score=<span class="keyword">False</span>, pred_leaf=<span class="keyword">False</span>, pred_contrib=<span class="keyword">False</span>, data_has_header=<span class="keyword">False</span>, is_reshape=<span class="keyword">True</span>, pred_parameter=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># num_iteration`：设置在预测时，使用多少个子树</span></span><br><span class="line"><span class="comment"># raw_score`：是否输出raw score</span></span><br><span class="line"><span class="comment"># pred_leaf： 输出每个样本在每个子树的哪个叶子上</span></span><br><span class="line"><span class="comment"># pred_contrib：输出每个特征对每个样本预测结果的贡献程度</span></span><br><span class="line"><span class="comment"># data_has_header：指示数据集是否含有标题</span></span><br><span class="line"><span class="comment"># is_reshape：是否reshape</span></span><br><span class="line"><span class="comment"># pred_parameter：给出其它的参数</span></span><br><span class="line"></span><br><span class="line">gbm.predict_proba(X, raw_score=<span class="keyword">False</span>, num_iteration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>LGBMRegressor 是 LGBMModel 的子类，它用于回归任务</li><li>LGBMRanker 是 LGBMModel 的子类，它用于排序任务，详见排序学习算法</li></ul><h3 id="绘图-API"><a href="#绘图-API" class="headerlink" title="绘图 API"></a>绘图 API</h3><h3 id="booster-API"><a href="#booster-API" class="headerlink" title="booster API"></a>booster API</h3><h3 id="LightGBM-示例"><a href="#LightGBM-示例" class="headerlink" title="LightGBM 示例"></a>LightGBM 示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> GridSearchCV  <span class="comment"># Perforing grid search</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">train_data = pd.read_csv(<span class="string">'train.csv'</span>)   <span class="comment"># 读取数据</span></span><br><span class="line">y = train_data.pop(<span class="string">'30'</span>).values   <span class="comment"># 用pop方式将训练数据中的标签值y取出来，作为训练目标，这里的‘30’是标签的列名</span></span><br><span class="line">col = train_data.columns</span><br><span class="line">x = train_data[col].values  <span class="comment"># 剩下的列作为训练数据</span></span><br><span class="line">train_x, valid_x, train_y, valid_y = train_test_split(x, y, test_size=<span class="number">0.333</span>, random_state=<span class="number">0</span>)   <span class="comment"># 分训练集和验证集</span></span><br><span class="line">train = lgb.Dataset(train_x, train_y)</span><br><span class="line">valid = lgb.Dataset(valid_x, valid_y, reference=train)</span><br><span class="line"></span><br><span class="line">parameters = &#123;</span><br><span class="line">              <span class="string">'max_depth'</span>: [<span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>],</span><br><span class="line">              <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.15</span>],</span><br><span class="line">              <span class="string">'feature_fraction'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>, <span class="number">0.95</span>],</span><br><span class="line">              <span class="string">'bagging_fraction'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>, <span class="number">0.95</span>],</span><br><span class="line">              <span class="string">'bagging_freq'</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>],</span><br><span class="line">              <span class="string">'reg_alpha'</span>: [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>],</span><br><span class="line">              <span class="string">'reg_lambda'</span>: [<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">40</span>],</span><br><span class="line">              <span class="string">'cat_smooth'</span>: [<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">35</span>]</span><br><span class="line">&#125;</span><br><span class="line">gbm = lgb.LGBMClassifier(boosting_type=<span class="string">'gbdt'</span>,</span><br><span class="line">                         objective = <span class="string">'binary'</span>,</span><br><span class="line">                         metric = <span class="string">'auc'</span>,</span><br><span class="line">                         verbose = <span class="number">0</span>,</span><br><span class="line">                         learning_rate = <span class="number">0.01</span>,</span><br><span class="line">                         num_leaves = <span class="number">35</span>,</span><br><span class="line">                         feature_fraction=<span class="number">0.8</span>,</span><br><span class="line">                         bagging_fraction= <span class="number">0.9</span>,</span><br><span class="line">                         bagging_freq= <span class="number">8</span>,</span><br><span class="line">                         reg_alpha= <span class="number">0.6</span>,</span><br><span class="line">                         reg_lambda= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">gsearch = GridSearchCV(gbm, param_grid=parameters, scoring=<span class="string">'accuracy'</span>, cv=<span class="number">3</span>)</span><br><span class="line">gsearch.fit(train_x, train_y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Best score: %0.3f"</span> % gsearch.best_score_)</span><br><span class="line">print(<span class="string">"Best parameters set:"</span>)</span><br><span class="line">best_parameters = gsearch.best_estimator_.get_params()</span><br><span class="line"><span class="keyword">for</span> param_name <span class="keyword">in</span> sorted(parameters.keys()):</span><br><span class="line">    print(<span class="string">"\t%s: %r"</span> % (param_name, best_parameters[param_name]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://xgboost.ai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XgBoost&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/Microsoft/LightGBM&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LightGBM&lt;/a&gt; 官方文档阅读和算法学习&lt;br&gt;&lt;code&gt;*&lt;/code&gt;号为未解释完全，具体使用方法请参考官方文档&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="boosting" scheme="https://hyqskevin.github.io/tags/boosting/"/>
    
  </entry>
  
  <entry>
    <title>scikit-learn 文档学习笔记(1)</title>
    <link href="https://hyqskevin.github.io/2019/07/30/scikit-learn-note/"/>
    <id>https://hyqskevin.github.io/2019/07/30/scikit-learn-note/</id>
    <published>2019-07-30T01:31:47.000Z</published>
    <updated>2020-11-19T06:55:33.582Z</updated>
    
    <content type="html"><![CDATA[<p><strong>—loading …—</strong><br>scikit-learn 基于 Python 语言,建立在 NumPy ，SciPy 和 matplotlib 上,是简单高效的数据挖掘和数据分析工具<br>文章记录 scikit-learn API 的使用方法，包括监督学习、无监督学习，模型的选择和评估，数据集的加载和转换<br>学习笔记(1) 为监督学习的内容，解决回归和分类问题。包括线性回归，逻辑回归，梯度下降，最近邻，贝叶斯，决策树，支持向量机，集成方法，半监督学习等<br>API 只给出函数结构，参数具体使用参考<a href="https://scikit-learn.org/stable/user_guide.html" target="_blank" rel="noopener">scikit-learn 官方文档</a></p><a id="more"></a><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h3><p>目标值 y 是输入变量 x 的线性组合 $y(w,x) = w_0 +w_1x_1 + … + w_px_p$ 其中 w 为系数(coef) $w_0$ 为截距(intercept)。</p><p><strong>1. 普通最小二乘法 LinearRegression</strong><br>拟合一个带有系数 $w = (w_1, …, w_p)$ 的线性模型，使得数据集实际观测数据和预测数据（估计值）之间的残差平方和最小。<br>$\underset{w}{min\,} {|| X w - y||_2}^2$</p><p><code>sklearn.linear_model.LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=None)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">reg = LinearRegression().fit(X,y) <span class="comment"># 模型拟合</span></span><br><span class="line">reg.cof_  <span class="comment"># 得到系数矩阵</span></span><br><span class="line">reg.intercept_ <span class="comment"># 得到截距矩阵</span></span><br><span class="line">reg.score(X,y) <span class="comment"># 误差</span></span><br><span class="line">reg.predict(X) <span class="comment"># 预测</span></span><br></pre></td></tr></table></figure><p><strong>2. 岭回归 Ridge</strong><br>回归通过对系数的大小<strong>施加惩罚</strong>来解决普通最小二乘法的一些问题。 岭系数最小化的是带罚项的残差平方和。<br>$\underset{w}{min\,} {||X w - y||_2^2 + \alpha ||w||_2^2}$，其中$\alpha \geq 0$ 是控制系数收缩量的复杂性参数(超参数)</p><p><code>sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True, normalize=False, copy_X=True, max_iter=None, tol=0.001, solver=’auto’, random_state=None)</code></p><p>// alpha 可以设超参数大小<br>// tol 设置迭代最小边界<br>// solver : {‘auto’, ‘svd’, ‘cholesky’, ‘lsqr’, ‘sparse_cg’, ‘sag’, ‘saga’} 设置求解器，拟合数据时使用的算法</p><ul><li><code>sklearn.linear_model.RidgeCV( )</code> 内置对$\alpha$的交叉验证实现岭回归</li></ul><p><strong>3. 套索回归 Lasso</strong><br>用于拟合<strong>稀疏系数</strong>的线性模型，使用了 coordinate descent （坐标下降算法）来拟合系数，罚项 为 L1 范数。<br>$\underset{w}{min\,} { \frac{1}{2n_{samples}} ||X w - y||_2 ^ 2 + \alpha ||w||_1}$</p><p><code>sklearn.linear_model.Lasso(alpha=1.0, fit_intercept=True, normalize=False, precompute=False, copy_X=True, max_iter=1000, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’)</code></p><ul><li><code>sklearn.linear_model.LassoCV()</code> // 对超参数$\alpha$采用交叉验证</li><li><code>sklearn.linear_model.LassoLars()</code> // 采用的是最小角回归法，而不是坐标下降法进行优化</li><li><code>sklearn.linear_model.LassoLarsCV()</code> //同时采用不同的验证和优化方法</li><li><p><code>sklearn.linear_model.LassoLarsIC()</code> //对超参数$\alpha$采用 Akaike 信息准则(AIC)和贝叶斯信息准则(BIC),需要假设模型是正确的，对大样本（渐近结果）进行导出</p></li><li><p>LassoLarsCV 在寻找 $\alpha$ 参数值上更具有优势，而且如果样本数量比特征数量少得多时，通常 LassoLarsCV 比 LassoCV 要快</p></li></ul><p><strong>4. 弹性网络 ElasticNet</strong><br>Lasso 和 Ridge 结合，对普通的线性回归做了正则化，但是它的损失函数既不全是 L1 的正则化，也不全是 L2 的正则化，而是用一个权重参数 ρ 来平衡 L1 和 L2 正则化的比重<br>适合只有少量参数是非零稀疏的模型<br>$\underset{w}{min\,} { \frac{1}{2n_{samples}} ||X w - y||_2 ^ 2 + \alpha \rho ||w||_1 +\frac{\alpha(1-\rho)}{2} ||w||_2 ^ 2}$</p><p><code>sklearn.linear_model.ElasticNet(alpha=1.0, l1_ratio=0.5, fit_intercept=True, normalize=False, precompute=False, max_iter=1000, copy_X=True, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’)</code></p><ul><li><code>ElasticNetCV()</code> 可以通过交叉验证来设置参数 $\alpha$ 和 $\rho$</li></ul><p><strong>5. Multitask 多任务</strong><br>可以实现多元回归稀疏模型的预测，即多个线性模型共同拟合<br>有<code>MultiTaskLasso()</code>,<code>MultiTaskLassoCV()</code>,<code>MultiTaskElasticNet()</code>,<code>MultiTaskElasticNetCV()</code></p><p><strong>6. 正交匹配追踪法（OMP）</strong><br><code>OrthogonalMatchingPursuit( )</code><br><code>OrthogonalMatchingPursuitCV( )</code></p><p><strong>7. 贝叶斯回归</strong></p><p><strong>8. 稳健回归</strong></p><p><strong>9. 多项式回归</strong></p><h3 id="logistic-线性分类模型"><a href="#logistic-线性分类模型" class="headerlink" title="logistic 线性分类模型"></a>logistic 线性分类模型</h3><p>解决分类问题的线性模型，将单次实验的结果输出为概率进行分类<br>$C \sum_{i=1}^n \log(\exp(- y_i (X_i^T w + c)) + 1) $<br>可以选择 L1，L2 或 Elastic-Net 正则化进行约束</p><p><code>sklearn.linear_model.LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=’warn’, max_iter=100, multi_class=’warn’, verbose=0, warm_start=False, n_jobs=None, l1_ratio=None)</code><br>// penalty 参数可以设置正则化参数<br>// C 用$1/{\lambda}$表示的正则化强度参数<br>// solver : str, {‘newton-cg’, ‘lbfgs’, ‘liblinear’, ‘sag’, ‘saga’} 选择优化算法，详细使用说明见官方文档<br>// class_weight 可以设置各类型的权重<br>// l1_ration 设置 Elastic-Net 中 ρ 控制正则化 L1 与正则化 L2 的强度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">reg = LogisticRegression().fit(X,y) <span class="comment"># 模型拟合</span></span><br><span class="line">reg.cof_  <span class="comment"># 得到系数矩阵</span></span><br><span class="line">reg.intercept_ <span class="comment"># 得到截距矩阵</span></span><br><span class="line">reg.score(X,y) <span class="comment"># 误差</span></span><br><span class="line">reg.predict(X) <span class="comment"># 得到预测的分类矩阵</span></span><br><span class="line">reg.predict_proba(X) <span class="comment"># 得到预测的概率</span></span><br></pre></td></tr></table></figure><ul><li><code>LogisticRegressionCV( )</code> 实现了内置交叉验证，可以找出最优的 C 和 l1_ratio 参数</li></ul><h3 id="SGD-随机梯度下降"><a href="#SGD-随机梯度下降" class="headerlink" title="SGD 随机梯度下降"></a>SGD 随机梯度下降</h3><p>可以拟合线性的回归和分类模型，在样本量很大时尤为有用，选择和函数时要避免过拟合。<br><code>SGDClassifier()</code> 和 <code>SGDRegressor()</code> 分别用于拟合分类问题和回归问题的线性模型，可使用不同的（凸）损失函数，支持不同的惩罚项。</p><h3 id="最近邻"><a href="#最近邻" class="headerlink" title="最近邻"></a>最近邻</h3><p>能够应用于决策边界非常不规则的分类情景</p><p>NearestNeighbors<br>BallTree<br>KDTree</p><p>最近邻分类属于<strong>基于实例的学习</strong>或<strong>非泛化学习</strong>：它不会去构造一个泛化的内部模型，而是简单地存储训练数据的实例。</p><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>决策树便于理解和解释，能够处理数值型数据和分类数据；但是容易产生一个过于复杂的模型，泛化性能会很差，结果不稳定，可以通过决策树的集成来得到缓解。如果某些类在问题中占主导地位会使得创建的决策树有偏差，建议在拟合前先对数据集进行平衡。</p><p>分类标准为最小化交叉熵（ID3），熵增益（C4.5）或基尼系数（Cart）</p><p><code>sklearn.tree.DecisionTreeClassifier(criterion=’gini’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, class_weight=None, presort=False)</code><br>// criterion 选择分类标准，可以使用”gini”或者”entropy”<br>// splitter 设置特征划分标准<br>// max_feature 划分的最大特征数<br>// max_depth 选择树的最大深度<br>// min_sample_split 设置最小样本分类<br>// min_sample_leaf 设置最小样本叶子数<br>// max_leaf_nodes 最大叶子节点数<br>// class_weight 设置类别权重<br>// presort 设置数据预排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">clf = DecisionTreeClassifier().fit(X,y)</span><br><span class="line">clf.n_class_ <span class="comment"># 分类数量</span></span><br><span class="line">clf.n_features_ <span class="comment"># 特征数量</span></span><br><span class="line">clf.n_outputs_ <span class="comment"># 输出数量</span></span><br><span class="line">clf.tree_ <span class="comment"># 得到分类树</span></span><br><span class="line">clf.get_depth() <span class="comment"># 得到分类深度</span></span><br><span class="line">clf.get_n_leaves() <span class="comment"># 得到叶子节点数</span></span><br><span class="line">clf.predict(X) <span class="comment"># 返回预测矩阵</span></span><br><span class="line">clf.predict_proba(X) <span class="comment"># 返回预测的概率</span></span><br><span class="line">clf.score(X,y) <span class="comment"># 返回训练分数</span></span><br></pre></td></tr></table></figure><ul><li><p>决策树回归模型 <code>sklearn.tree.DecisionTreeRegressor()</code> （不常用）</p></li><li><p>可以使用 export_graphviz 导出器以 Graphviz 格式导出决策树,结果保存为 pdf；Jupyter notebook 也可以自动内联式渲染这些绘制节点</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line">dot_data = tree.export_graphviz(clf, out_file=<span class="keyword">None</span>,\</span><br><span class="line">                    feature_names=iris.feature_names,\</span><br><span class="line">                    class_names=iris.target_names,  \</span><br><span class="line">                    filled=<span class="keyword">True</span>, rounded=<span class="keyword">True</span>,  \</span><br><span class="line">                    special_characters=<span class="keyword">True</span>)</span><br><span class="line">graph = graphviz.Source(dot_data)</span><br><span class="line">graph.render(<span class="string">"classification_result"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show in Jupyter</span></span><br><span class="line">graph</span><br></pre></td></tr></table></figure><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>可用于分类，回归和异常检测，在高维空间中非常高效，<br>SVC, NuSVC 和 LinearSV</p><p>内核岭回归<br>核函数</p><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p>GaussianNB<br>MultinomialNB<br>ComplementNB<br>BernoulliNB</p><h3 id="集成方法"><a href="#集成方法" class="headerlink" title="集成方法"></a>集成方法</h3><p><strong>1. Bagging</strong><br>在原始训练集的随机子集上构建一类黑盒估计器的多个实例，然后把这些估计器的预测结果结合起来形成最终的预测结果，在构建模型的过程中引入随机性，来减少基估计器的方差。</p><p><code>sklearn.ensemble.BaggingClassifier(base_estimator=None, n_estimators=10, max_samples=1.0, max_features=1.0, bootstrap=True, bootstrap_features=False, oob_score=False, warm_start=False, n_jobs=None, random_state=None, verbose=0)</code><br>// base_estimator 设置分类估计器，默认为决策树，可设置其它分类模型<br>// n_estimators 设置估计器的数量<br>// bootstrap 设置样例抽取是否放回<br>// bootstrap_features 设置特征抽取是否有放回<br>// oob_score 设置是否用额外的样本来评估泛化精度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line">clf = BaggingClassifier().fit(X,y)</span><br><span class="line">clf.predict(X)</span><br><span class="line">predict_proba(X)</span><br><span class="line">score(X, y)</span><br></pre></td></tr></table></figure><p><strong>2. 随机森林</strong><br>随机森林中的每棵树构建时的样本都是由训练集经过有放回抽样得到。在构建树的过程中进行结点分割时，选择的分割点不再是所有特征中最佳分割点，而是特征的一个随机子集中的最佳分割点，偏差通常会有略微的增大；但由于取了平均，总体上模型的泛化能力会更好。</p><p><code>sklearn.ensemble.RandomForestClassifier(n_estimators=’warn’, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False, class_weight=None)</code><br>// n_estimators 调整森林里树的数量<br>// max_features 分割节点时考虑的特征的随机子集的大小。使用 max_features = sqrt(n_features)是比较好的默认值<br>// max_depth = None 和 min_samples_split = 2 结合可以生成完全树</p><ul><li>极限随机树 <code>ExtraTreesClassifier()</code></li><li>完全随机树构成森林 <code>RandomTreesEmbedding()</code></li></ul><p><strong>2. 梯度提升回归树(GBRT)</strong><br>GBRT 保证迭代的每一个阶段中选择损失最小的决策树，达到全局的最小损失<br>$F<em>m(x) = F</em>{m-1}(x) + \arg\min<em>{h} \sum</em>{i=1}^{n} L(y<em>i,F</em>{m-1}(x_i) - h(x))$<br>GBRT 具有强大的预测能力和鲁棒性，但是扩展性不够好</p><p><code>GradientBoostingClassifier(loss=’deviance’, learning_rate=0.1, n_estimators=100, subsample=1.0, criterion=’friedman_mse’, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_depth=3, min_impurity_decrease=0.0, min_impurity_split=None, init=None, random_state=None, max_features=None, verbose=0, max_leaf_nodes=None, warm_start=False, presort=’auto’, validation_fraction=0.1, n_iter_no_change=None, tol=0.0001)</code><br>// loss 设置损失函数，默认为 deviance（$-log_2$ 似然损失函数）<br>// learning_rate 设置学习步长<br>// subsample 设置每次子训练集的采样，1 为全采样，一般可设置为 0.5</p><p><strong>3. AdaBoost</strong><br>通过反复修改数据权重来训练一些弱学习器，由这些弱学习器的预测结果通过加权投票(或加权求和)的方式组合, 得到最终的预测结果。<br>$F<em>m(x) = F</em>{m-1}(x) + \gamma<em>m \sum</em>{i=1}^{n} \nabla<em>F L(y_i, F</em>{m-1}(x<em>i))$<br>$\gamma_m$代表学习步长，通过计算损失最小的梯度下降$\gamma_m = \arg\min</em>{\gamma} \sum<em>{i=1}^{n} L(y_i, F</em>{m-1}(x<em>i) - \gamma \frac{\partial L(y_i, F</em>{m-1}(x<em>i))}{\partial F</em>{m-1}(x_i)})$得出</p><p>初始化时，将所有弱学习器的权重都设置为 $w_i = 1/N$ ,接下来的连续迭代中，样本的权重逐个地被修改。上一轮迭代中被预测为错误结果的样本的权重将会被增加，而那些被预测为正确结果的样本的权重将会被降低。通过不断得到最快梯度下降的权重来减小损失函数。</p><p><code>sklearn.ensemble.AdaBoostClassifier(base_estimator=None, n_estimators=50, learning_rate=1.0, algorithm=’SAMME.R’, random_state=None)</code><br>// base_estimator 设置弱学习器，默认 DecisionTreeClassifier(max_depth=1)<br>// n_estimator 设置最大集成数量<br>// learning_rate 设置学习速率</p><p><strong>4. 投票分类器</strong></p><hr><hr><ul><li>最小角回归（LARS）：逐步寻找与响应最有关联的预测。当有很多预测有相同的关联时，它并不会继续利用相同的预测，而是在这些预测中找出应该等角的方向。高效但对噪声敏感。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;—loading …—&lt;/strong&gt;&lt;br&gt;scikit-learn 基于 Python 语言,建立在 NumPy ，SciPy 和 matplotlib 上,是简单高效的数据挖掘和数据分析工具&lt;br&gt;文章记录 scikit-learn API 的使用方法，包括监督学习、无监督学习，模型的选择和评估，数据集的加载和转换&lt;br&gt;学习笔记(1) 为监督学习的内容，解决回归和分类问题。包括线性回归，逻辑回归，梯度下降，最近邻，贝叶斯，决策树，支持向量机，集成方法，半监督学习等&lt;br&gt;API 只给出函数结构，参数具体使用参考&lt;a href=&quot;https://scikit-learn.org/stable/user_guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scikit-learn 官方文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="repo" scheme="https://hyqskevin.github.io/categories/repo/"/>
    
    
      <category term="python" scheme="https://hyqskevin.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Flask Web 学习笔记2 -- URL与视图函数映射</title>
    <link href="https://hyqskevin.github.io/2019/04/11/flask-learning2/"/>
    <id>https://hyqskevin.github.io/2019/04/11/flask-learning2/</id>
    <published>2019-04-11T08:28:44.000Z</published>
    <updated>2020-11-19T06:55:57.968Z</updated>
    
    <content type="html"><![CDATA[<p>-学习笔记-<br>通过 URL 传递参数，接收参数，利用试图函数实现参数到 URL 转换，自定义 URL 转换</p><a id="more"></a><p>URL 是 Uniform Resource Locator 的简写，统一资源定位符。<br>一个 URL 由以下几部分组成：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">scheme://host:port/path/?query-string=xxx#anchor</span><br></pre></td></tr></table></figure><ul><li>scheme：代表的是访问的协议，一般为 http 或者 https 以及 ftp 等。</li><li>host：主机名，域名，比如www.baidu.com。</li><li>port：端口号。当你访问一个网站的时候，浏览器默认使用 80 端口。</li><li>path：查找路径。比如：www.jianshu.com/trending/now，后面的trending/now就是path。</li><li>query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。</li><li>anchor：锚点，后台一般不用管，前端用来做页面定位的。</li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>传递参数的语法是：<code>/&lt;参数名&gt;/</code>。然后在视图函数中，也要定义同名的参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="meta">@app.route('/list/')</span></span><br><span class="line"><span class="meta">@app.route('/p/&lt;float:article_id&gt;')</span></span><br><span class="line"><span class="meta">@app.route('/u/&lt;uuid:user_id&gt;/')</span></span><br><span class="line"><span class="meta">@app.route('/&lt;any(blog,article):url_path&gt;/&lt;id&gt;/')</span></span><br></pre></td></tr></table></figure><p>参数的数据类型</p><ol><li>如果没有指定具体的数据类型，那么默认就是使用<code>string</code>数据类型。</li><li><code>int</code>数据类型只能传递<code>int</code>类型。</li><li><code>float</code>数据类型只能传递<code>float</code>类型。</li><li><code>path</code>数据类型和<code>string</code>有点类似，都是可以接收任意的字符串，但是<code>path</code>可以接收路径，也就是说可以包含斜杠。</li><li><code>uuid</code>数据类型只能接收符合<code>uuid</code>的字符串。<code>uuid</code>是一个全宇宙都唯一的字符串，一般可以用来作为表的主键。</li><li><code>any</code>数据类型可以在一个<code>url</code>中指定多个路径。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/&lt;any(blog,article):url_path&gt;/&lt;id&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(url_path,id)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> url_path == <span class="string">'blog'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'博客详情：%s'</span> % id</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'博客详情：%s'</span> % id</span><br></pre></td></tr></table></figure><h3 id="接收用户传递的参数"><a href="#接收用户传递的参数" class="headerlink" title="接收用户传递的参数"></a>接收用户传递的参数</h3><ol><li>第一种：使用<code>path</code>的形式（将参数嵌入到路径中），就是上面讲的。</li><li>第二种：使用查询字符串的方式，就是通过<code>?key=value</code>的形式传递的。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/d/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">()</span>:</span></span><br><span class="line">    wd = request.args.get(<span class="string">'wd'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'参数是：%s'</span> % wd</span><br></pre></td></tr></table></figure><h3 id="URL-转换器"><a href="#URL-转换器" class="headerlink" title="URL 转换器"></a>URL 转换器</h3><p><code>url_for</code>将<strong>视图函数</strong>名字后面的参数传递给<code>url</code>。<br>如果传递的参数之前在<code>url</code>中已经定义了，那么这个参数就会被当成<code>path</code>的形式给<code>url</code>。如果这个参数之前没有在<code>url</code>中定义，那么将变成查询字符串的形式放到<code>url</code>中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,request</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/list/&lt;page&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_list</span><span class="params">(page)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'my list'</span></span><br><span class="line"></span><br><span class="line">print(url_for(<span class="string">'my_list'</span>,page=<span class="number">1</span>,count=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># page作为path，count作为查询字符串</span></span><br><span class="line"><span class="comment"># 构建出来的url：/my_list/1/?count=2</span></span><br></pre></td></tr></table></figure><ul><li>url_for 优势</li></ul><ol><li>将来如果修改了<code>URL</code>，但没有修改该 URL 对应的函数名，就不用到处去替换 URL 了</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/post/list/&lt;page&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_list</span><span class="params">(page)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'my list'</span></span><br><span class="line">url = url_for(<span class="string">'my_list'</span>，page=<span class="number">1</span>,count=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 原来的url：/my_list/1/?count=2</span></span><br><span class="line"><span class="comment"># 新构建出来的url：/post/my_list/1/?count=2</span></span><br></pre></td></tr></table></figure><ol><li>url_for 会自动的处理那些特殊的字符，不需要手动去处理。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/login/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'login'</span></span><br><span class="line"></span><br><span class="line">url = url_for(<span class="string">'login'</span>,next=<span class="string">'/'</span>)</span><br><span class="line"><span class="comment"># 会自动的将`/`编码，不需要手动去处理。</span></span><br><span class="line"><span class="comment"># url=/login/?next=%2F</span></span><br></pre></td></tr></table></figure><h3 id="自定义-URL-转换器"><a href="#自定义-URL-转换器" class="headerlink" title="自定义 URL 转换器"></a>自定义 URL 转换器</h3><p>URL 参数的数据类型通过<code>routing.py</code>中的<code>Unicode/Float/Any/Path/Number Converter</code>等类指定，使用了默认转换器</p><p>可以自定义类型 URL 转换器和运算符 URL 转换器</p><ul><li>自定义方法</li></ul><ol><li>实现一个类，继承自<code>BaseConverter</code>。</li><li>在自定义的类中，重写<code>regex</code>，也就是这个变量的正则表达式。</li><li>将自定义的类，映射到<code>app.url_map.converters</code>上。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for</span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> BaseConverter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义手机号码的变量URL转换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneConveter</span><span class="params">(BaseConverter)</span>:</span></span><br><span class="line">  regex = <span class="string">r'1[85734]\d'</span></span><br><span class="line">app.url_map.converters[<span class="string">'tel'</span>] = TelephoneConverter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的数据类型</span></span><br><span class="line"><span class="meta">@app.route('/telephone/&lt;tel:my_tel&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_tel</span><span class="params">(my_tel)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'您的手机号码是：%s'</span> % my_tel</span><br><span class="line"></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义+号运算符解析</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpratorConverter</span><span class="params">(BaseConverter)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 这个方法的返回值，将会传递到view函数中作为参数</span></span><br><span class="line">    <span class="keyword">return</span> value.split(<span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 在调用url_for函数的时候生成符合要求的URL形式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"+"</span>.join(value)</span><br><span class="line">    <span class="comment"># return "hello"</span></span><br><span class="line">app.url_map.converters[<span class="string">'oprator+'</span>] = OpratorConverter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义+</span></span><br><span class="line"><span class="meta">@app.route('/posts/&lt;oprator+:boards&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">posts</span><span class="params">(boards)</span>:</span></span><br><span class="line">    print(boards)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"您提交的板块是：%s"</span> % boards</span><br></pre></td></tr></table></figure><h3 id="URL-重定向"><a href="#URL-重定向" class="headerlink" title="URL 重定向"></a>URL 重定向</h3><p>重定向在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面。比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面。</p><ol><li>永久性重定向：<code>http</code>的状态码是<code>301</code>，多用于旧网址被废弃了要转到一个新的网址确保用户的访问。</li><li>暂时性重定向：<code>http</code>的状态码是<code>302</code>，表示页面的暂时性跳转。比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面，这种情况下，应该用暂时性重定向。</li></ol><p><code>flask</code>中有一个函数叫做<code>redirect</code>，可以重定向到指定的页面。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request,redirect,url_for</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/login/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'这是登录页面'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/profile/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">'name'</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'个人中心页面'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># redirect 重定向</span></span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'login'</span>))</span><br></pre></td></tr></table></figure><h3 id="视图函数的响应"><a href="#视图函数的响应" class="headerlink" title="视图函数的响应"></a>视图函数的响应</h3><ol><li>可以返回字符串：flask 会创建 werkzeug、wrappers、Response 对象，状态码 200，MIME 类型<code>test/html</code>，然后返回 Response 对象</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Response</span><br><span class="line">...</span><br><span class="line"><span class="meta">@app.route('/list/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">()</span>:</span></span><br><span class="line">    Response(<span class="string">'Hello World!'</span>)</span><br><span class="line"><span class="comment"># Response('Hello World!',status=200,mimetype='text/html')</span></span><br></pre></td></tr></table></figure><p>还可以通过 make_response 进行创建</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">form flask <span class="keyword">import</span> make_response</span><br><span class="line"><span class="meta">@app.route('/list/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> make_response(<span class="string">'list page.'</span>)</span><br></pre></td></tr></table></figure><ol><li>可以返回元组：元组的形式是(Response,Status,header)<br>不一定三个都要写，写两个也是可以的，status 返回 200，header 为列表或字典。返回的元组，其实在底层也是包装成了一个<code>Response</code>对象。<br><code>return &#39;list&#39;,200,{&#39;NAME&#39;:&#39;kevin&#39;}</code></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.errorheader(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_found</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'not found'</span>,<span class="number">404</span></span><br></pre></td></tr></table></figure><ol><li>直接返回合法的响应对象</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp = Response(<span class="string">'list'</span>)</span><br><span class="line">resp.set_cookie(<span class="string">'country'</span>,<span class="string">'china'</span>)</span><br><span class="line"><span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><ol><li>以上条件不满足，则进行自定义响应</li></ol><p>继承自<code>Response</code>类。<br>实现方法<code>force_type(cls,response,environ=None)</code>。<br>指定<code>app.response_class</code>为你自定义的<code>Response</code>对象。<br>如果视图函数返回的数据，不是字符串，也不是元组，也不是 Response 对象，那么就会将返回值传给<code>force_type</code>，然后再将<code>force_type</code>的返回值返回给前端。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myResponse</span><span class="params">(Response)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">force_type</span><span class="params">(cls, response, environ=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'return error.'</span>)</span><br><span class="line"></span><br><span class="line">app.response_class = myResponse</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用jsonify将返回的格式转换成json格式</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myResponse</span><span class="params">(Response)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">force_type</span><span class="params">(cls, response, environ=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(response,dict):</span><br><span class="line">        <span class="comment"># jsonify除了将字典转换成json对象，还将改对象包装成了一个Response对象</span></span><br><span class="line">        response = jsonify(response)</span><br><span class="line">    <span class="comment"># 调用父类</span></span><br><span class="line">    <span class="keyword">return</span> super(myResponse, cls).force_type(response, environ)</span><br><span class="line"></span><br><span class="line">app.response_class = myResponse</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-学习笔记-&lt;br&gt;通过 URL 传递参数，接收参数，利用试图函数实现参数到 URL 转换，自定义 URL 转换&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="flask" scheme="https://hyqskevin.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>c++中的智能指针</title>
    <link href="https://hyqskevin.github.io/2019/04/05/ptr/"/>
    <id>https://hyqskevin.github.io/2019/04/05/ptr/</id>
    <published>2019-04-05T11:33:58.000Z</published>
    <updated>2020-11-19T06:55:34.623Z</updated>
    
    <content type="html"><![CDATA[<p>由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，用智能指针便可以有效缓解这类问题。</p><p>对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。</p><a id="more"></a><p>访问智能指针包含的裸指针则可以用 get() 函数</p><p>智能指针包含了 reset() 方法，如果不传递参数（或者传递 NULL），则智能指针会释放当前管理的内存。如果传递一个对象，则智能指针会释放当前对象，来管理新传入的对象。</p><ul><li>编写测试类来辅助分析</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Simple(<span class="keyword">int</span> param = <span class="number">0</span>) &#123;</span><br><span class="line">    number = param;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  ~Simple() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrintSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PrintSomething: "</span> &lt;&lt; info_extend.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> info_extend;</span><br><span class="line">  <span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h2><p>包含头文件 <code>#include&lt;memory&gt;</code> 便可以使用<br><code>std::auto_ptr</code> 能够方便的管理单个堆内存对象</p><p>用法一：<br><code>std::auto_ptr&lt;MyClass&gt;m_example(new MyClass());</code></p><p>用法二：<br><code>std::auto_ptr&lt;MyClass&gt;m_example;</code><br><code>m_example.reset(new MyClass());</code></p><p>用法三（指针的赋值操作）：<br><code>std::auto_ptr&lt;MyClass&gt;m_example1(new MyClass());</code><br><code>std::auto_ptr&lt;MyClass&gt;m_example2(new MyClass());</code><br><code>m_example2=m_example1;</code></p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));   <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;             <span class="comment">// 判断智能指针是否为空</span></span><br><span class="line">    my_memory-&gt;PrintSomething();  <span class="comment">// 使用 operator-&gt; 调用智能指针对象中的函数</span></span><br><span class="line">    my_memory.get()-&gt;info_extend = <span class="string">"Addition"</span>; <span class="comment">// 使用 get() 返回裸指针，然后给内部对象赋值</span></span><br><span class="line">    my_memory-&gt;PrintSomething();               <span class="comment">// 再次打印，表明上述赋值成功</span></span><br><span class="line">    (*my_memory).info_extend += <span class="string">" other"</span>;      <span class="comment">// 使用 operator 返回智能指针内部对象，然后用“.”调用智能指针对象中的函数</span></span><br><span class="line">    my_memory-&gt;PrintSomething();               <span class="comment">// 再次打印，表明上述赋值成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;                          <span class="comment">// my_memory 栈对象即将结束生命期，析构堆对象 Simple(1)</span></span><br></pre></td></tr></table></figure><ul><li>执行结果为：<br>Simple: 1<br>PrintSomething:<br>PrintSomething: Addition<br>PrintSomething: Addition other<br>~Simple: 1</li></ul><h3 id="不能使用-操作符"><a href="#不能使用-操作符" class="headerlink" title="不能使用 = 操作符"></a>不能使用 = 操作符</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory2;   <span class="comment">// 创建一个新的 my_memory2 对象</span></span><br><span class="line">    my_memory2 = my_memory;             <span class="comment">// 复制旧的 my_memory 给 my_memory2</span></span><br><span class="line">    my_memory2-&gt;PrintSomething();       <span class="comment">// 输出信息，复制成功</span></span><br><span class="line">    my_memory-&gt;PrintSomething();        <span class="comment">// 崩溃</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>my_memory2 = my_memory</code>这行代码，my_memory2 完全夺取了 my_memory 的内存管理所有权，导致 my_memory 悬空，最后使用时导致崩溃。</p><h3 id="release-函数问题"><a href="#release-函数问题" class="headerlink" title="release() 函数问题"></a>release() 函数问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    my_memory.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                          <span class="comment">//最终执行结果为 Simple：1，没有被析构，导致内存泄露</span></span><br></pre></td></tr></table></figure><p>调用 release() 函数释放内存，不会释放对象，仅仅归还所有权，要自己 delete 或使用 reset()函数销毁对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码修正</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    Simple* temp_memory = my_memory.release();</span><br><span class="line">    <span class="keyword">delete</span> temp_memory;</span><br><span class="line">    <span class="comment">// 或者直接 my_memory.reset();  释放 my_memory 内部管理的内存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项<br>使用 std::auto_ptr 时，<strong>绝对不能使用“operator=”操作符</strong>，这会夺取内存管理所有权<br>std::auto_ptr 的 release() 函数不会释放对象，仅仅归还所有权。<br>std::auto_ptr 最好不要当成参数传递（读者可以自行写代码确定为什么不能）。<br>std::auto_ptr 的“operator=”问题，有其管理的对象不能放入 std::vector 等容器中。<br>C++11 中，std::auto_ptr 已经被弃用</li></ul><hr><p>自 C++11 起，C++标准提供两大类型的智能指针：shared_ptr 和 unique_ptr</p><hr><h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>shared_ptr 实现共享式拥有（shared ownership）概念。<strong>多个智能指针可以指向相同对象</strong>，该对象和其相关资源会在“最后一个引用（reference）被销毁”时候释放。为了在结构复杂的情境中执行上述工作，标准库提供了 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</p><p>shared_ptr 本身提供默认内存释放器（default deleter），调用的是 delete，也可以自定义释放器</p><p>默认内存释放器并<strong>不能释放数组内存空间</strong>，要我们自己提供内存释放器</p><ul><li><p>成员函数<br>use_count 返回引用计数的个数<br>unique 返回是否是独占所有权( use_count 为 1)<br>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少<br>get 返回内部对象(指针)</p></li><li><p>示例</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp0(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp0);               <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp1);               <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp2);               <span class="comment">// 11</span></span><br><span class="line">sp1.swap(sp0);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp0);               <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp1);               <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp2);               <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp3(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">22</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp4 = sp3;     <span class="comment">// 或 auto sp4 = sp3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp3);               <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp4);               <span class="comment">// 22</span></span><br><span class="line">sp3.reset();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp3.use_count());    <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp4.use_count());    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp3);                <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li>注意事项<br>shared_ptr 会因循环引用造成无法释放资源<br>与 weak_ptr 一起工作时, weak_ptr 在使用前需要检查合法性<br>shared_ptr 不支持数组, 如果使用数组, 需要自定义删除器</li></ul><h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</p><p>weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象. 注意, weak_ptr 在使用前需要检查合法性。</p><p>weak_ptr 支持拷贝或赋值, 但不会影响对应的 shared_ptr 内部对象的计数。</p><ul><li><p>成员函数<br>expired 用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false<br>lock 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同。<br>use_count 返回与 shared_ptr 共享的对象的引用计数.<br>reset 将 weak_ptr 置空.</p></li><li><p>使用 weak_ptr 解决 shared_ptr 因循环不能释放资源的问题<br>使用 shared_ptr 时, shared_ptr 为强引用, 如果存在循环引用, 将导致内存泄露. 而 weak_ptr 为弱引用, 可以避免此问题</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CA()&#123;&#125;</span><br><span class="line">    ~CA()&#123;PRINT_FUN();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;CB&gt; m_spb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CB()&#123;&#125;;</span><br><span class="line">    ~CB()&#123;PRINT_FUN();&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CA&gt; m_spa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CA&gt; spa(<span class="keyword">new</span> CA);  <span class="comment">// 通过调用weak_ptr，释放CA内存时不影响CB</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CB&gt; spb(<span class="keyword">new</span> CB);</span><br></pre></td></tr></table></figure><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（resourece leak）——例如“以 new 创建对象后因为发生异常而忘记调用 delete”——特别有用。</p><p>unique_ptr 不支持拷贝和赋值，但是可以调用 release 或 reset 将指针的所有权从一个(非 const) unique_ptr 转移到另一个<br><code>std::unique_ptr&lt;A&gt; up1(new A(5));</code><br><code>std::unique_ptr&lt;A&gt; up2(up1);</code> // 错误, unique_ptr 不支持拷贝<br><code>std::unique_ptr&lt;A&gt; up2 = up1;</code> // 错误, unique_ptr 不支持赋值<br><code>std::unique_ptr&lt;int&gt; up2(up1.release());</code> // 正确</p><p>unique_ptr 不支持拷贝, 但是可以从函数中返回, 甚至返回局部对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt; Clone(<span class="keyword">const</span> Ty&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">　<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt; temp = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt;(<span class="keyword">new</span> Ty(obj));</span><br><span class="line">　<span class="keyword">return</span> temp;</span><br><span class="line">  <span class="comment">// 或直接 return std::unique_ptr&lt;Ty&gt;(new Ty(obj))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique_ptr 支持管理数组</p><ul><li><p>成员函数<br>get 获得内部对象的指针<br>release 放弃内部对象的所有权，将内部指针置为空, 返回所内部对象的指针, 此指针需要手动释放<br>reset 销毁内部对象并接受新的对象的所有权(如果使用缺省参数的话，也就是没有任何对象的所有权, 此时仅将内部对象释放, 并置为空)<br>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br>std::move(name) 所有权转移(通过移动语义), 所有权转移后，变成“空指针”</p></li><li><p>防内存泄漏代码改进</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// 内存泄露</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// ptr成空悬指针</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line">  ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 unique_ptr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="boost-scoped-ptr"><a href="#boost-scoped-ptr" class="headerlink" title="boost::scoped_ptr"></a>boost::scoped_ptr</h2><h2 id="boost-shared-ptr"><a href="#boost-shared-ptr" class="headerlink" title="boost::shared_ptr"></a>boost::shared_ptr</h2><h2 id="boost-scoped-array"><a href="#boost-scoped-array" class="headerlink" title="boost::scoped_array"></a>boost::scoped_array</h2><h2 id="boost-shared-array"><a href="#boost-shared-array" class="headerlink" title="boost::shared_array"></a>boost::shared_array</h2><h2 id="boost-weak-ptr"><a href="#boost-weak-ptr" class="headerlink" title="boost::weak_ptr"></a>boost::weak_ptr</h2><h2 id="boost-intrusive-ptr"><a href="#boost-intrusive-ptr" class="headerlink" title="boost:: intrusive_ptr"></a>boost:: intrusive_ptr</h2><p>参考资料：<br><a href="https://blog.csdn.net/xt_xiaotian/article/details/5714477" target="_blank" rel="noopener">https://blog.csdn.net/xt_xiaotian/article/details/5714477</a><br><a href="https://www.cnblogs.com/xiehongfeng100/p/4645555.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiehongfeng100/p/4645555.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930361.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930361.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930372.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930372.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930388.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930388.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，用智能指针便可以有效缓解这类问题。&lt;/p&gt;
&lt;p&gt;对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&amp;gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="c++" scheme="https://hyqskevin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Flask Web 学习笔记1 -- 环境</title>
    <link href="https://hyqskevin.github.io/2019/03/31/flask-learning1/"/>
    <id>https://hyqskevin.github.io/2019/03/31/flask-learning1/</id>
    <published>2019-03-31T08:25:28.000Z</published>
    <updated>2020-11-19T06:55:57.056Z</updated>
    
    <content type="html"><![CDATA[<p>-学习笔记-<br>flask 前期准备，在目录下建立 flask 虚拟环境，开启调试模式和书写配置文档</p><a id="more"></a><p>flask = werkzeug(web 服务)+sqlalchemy(数据库)+jinja2(框架模板)</p><h2 id="flask-运行环境"><a href="#flask-运行环境" class="headerlink" title="flask 运行环境"></a>flask 运行环境</h2><p><code>pip install pipenv</code><br>使用 <code>pipenv</code> 隔离虚拟环境，防止不同项目环境冲突</p><p>命令行切换到目标目录下<br><code>pipenv shell</code> 进入虚拟环境<br><code>pipenv install flask</code> 安装 flask<br><code>pipenv graph</code> 打印所有依赖<br><code>exit</code> 退出虚拟环境</p><p><a href="github.com/pypa/pipenv">pipenv doc</a></p><p>python 必须重启服务器才生效</p><ul><li>默认模板</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从flask这个包中导入Flask这个类</span></span><br><span class="line"><span class="comment"># Flask这个类是项目的核心，以后很多操作都是基于这个类的对象</span></span><br><span class="line"><span class="comment"># 注册url、注册蓝图等都是基于这个类的对象</span></span><br><span class="line">__author__ = <span class="string">'kevin'</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Flask对象，传递__name__参数进去</span></span><br><span class="line"><span class="comment"># __name__参数的作用：</span></span><br><span class="line"><span class="comment"># 1. 可以规定模版和静态文件的查找路径</span></span><br><span class="line"><span class="comment"># 2. 以后一些Flask插件，比如Flask-migrate、Flask-SQLAlchemy如果报错了，那么Flask可以通过这个参数找到具体的错误位置</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.route：是一个装饰器</span></span><br><span class="line"><span class="comment"># @app.route('/')就是将url中的/映射到hello_world这个视图函数上面</span></span><br><span class="line"><span class="comment"># 以后你访问我这个网站的/目录的时候，会执行hello_world这个函数，然后将这个函数的返回值返回给浏览器。</span></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello,World.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果这个文件是作为一个主文件运行，那么就执行app.run()方法，遍历运行</span></span><br><span class="line"><span class="comment"># 只在开发时使用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'127.0.0.1'</span>,port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><h3 id="debug-模式"><a href="#debug-模式" class="headerlink" title="debug 模式"></a>debug 模式</h3><p>开启了 DEBUG 模式，那么在代码中如果抛出了异常，在浏览器的页面中可以看到具体的错误信息，以及具体的错误代码位置。方便开发者调试。</p><p>如果开启了 DEBUG 模式，那么以后在<code>Python</code>代码中修改了任何代码，只要按<code>ctrl+s</code>，<code>flask</code>就会自动的重新记载整个网站。不需要手动点击重新运行。</p><ol><li>在<code>app.run()</code>中传递一个参数<code>debug=True</code>就可以开启<code>DEBUG</code>模式</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><ol><li>给<code>app.deubg=True</code>也可以开启<code>debug</code>模式。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><ol><li>通过配置参数的形式设置 DEBUG 模式：<code>app.config.update(DEBUG=True)</code>。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置配置参数的形式</span></span><br><span class="line"><span class="comment"># DEBUG必须要大写，不能小写</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.update(DEBUG=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><ol><li>通过配置文件的形式设置 DEBUG 模式：<code>app.config.from_object(config)</code></li></ol><p>导入<code>import config</code><br>使用<code>app.config.from_object(config)</code><br>新建<code>config.py</code>文件，写入<code>DEBUG=true</code></p><h3 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h3><ol><li>导入<code>import config</code>，使用<code>app.config.from_object(config)</code>,新建<code>config.py</code>文件，写入<code>DEBUG=true</code></li><li><code>app.config.from_pyfile(&#39;config.py,silence=True)</code>,新建<code>config.py</code>文件，写入<code>DEBUG=true</code><br>可以传递<code>silent=True</code>，那么这个静态文件没有找到的时候，不会抛出异常</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-学习笔记-&lt;br&gt;flask 前期准备，在目录下建立 flask 虚拟环境，开启调试模式和书写配置文档&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="flask" scheme="https://hyqskevin.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>c++ 面向对象的一些特性</title>
    <link href="https://hyqskevin.github.io/2019/03/25/cpp-oop/"/>
    <id>https://hyqskevin.github.io/2019/03/25/cpp-oop/</id>
    <published>2019-03-25T11:35:15.000Z</published>
    <updated>2020-11-19T06:56:05.765Z</updated>
    
    <content type="html"><![CDATA[<p>-基础笔记-(loading…)<br>C++面向对象编程知识点复习梳理，包括类、继承、重载、多态、数据抽象、数据封装、接口</p><a id="more"></a><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h3><p>public<br>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值</p><p>private<br>私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员<br>默认情况下，类的所有成员都是私有的<br>一般会在私有区域定义数据，在公有区域定义相关的函数</p><p>protected<br>保护成员在派生类（即子类）中是可访问的</p><h3 id="构造函数-拷贝构造函数和析构函数"><a href="#构造函数-拷贝构造函数和析构函数" class="headerlink" title="构造函数,拷贝构造函数和析构函数"></a>构造函数,拷贝构造函数和析构函数</h3><p>创建、初始化和删除所创建的对象时调用<br>构造函数的名称与类的名称是完全相同的，不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值<br>拷贝构造函数是一种特殊的构造函数，在创建对象时，是使用同一类中之前创建的对象来<strong>初始化新创建的对象</strong>。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数<br>析构函数的名称与类的名称是完全相同的，不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Classname();  <span class="comment">//构造函数</span></span><br><span class="line">  Classname(<span class="keyword">const</span> Classname &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">  ~Classname();  <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Classname::Classname()&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  *ptr = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//指针分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Classname::Classname(<span class="keyword">const</span> Classname &amp;obj)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用拷贝构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  *ptr = *obj.ptr;  <span class="comment">//指针分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CLassname::~Classname()&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"释放内存"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类如果有多个字段 X、Y、Z 等需要进行初始化，可以使用如下语法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Classname::objname( <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): X(a), Y(b), Z(c)</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>浅拷贝：如果没有拷贝构造函数，编译器自动产生一个“默认拷贝构造函数”，使用“老对象”的数据成员的值对“新对象”的数据成员进行赋值<br>当对象存在动态成员，那么浅拷贝就会出问题，在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，出现错误</p><p>深拷贝：对象中动态成员重新动态分配空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Classname()&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  Classname(<span class="keyword">const</span> Classname&amp; r)&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);  <span class="comment">//重新分配动态空间</span></span><br><span class="line">    *p = *(r.p);  <span class="comment">//指针分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line">  ~Classname()&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>定义在类外部，用来访问类的 private 和 protected 成员<br>可以不使用范围解析运算符 <code>::</code> 定义该函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Classname</span>;</span>  <span class="comment">//友元类</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">objname</span><span class="params">()</span></span>;  <span class="comment">//友元函数</span></span><br></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码，即把该函数的代码副本放置在每个调用该函数的地方<br>类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符</p><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p>每一个对象都能通过 <code>this</code> 指针来访问自己的地址<br>友元函数没有 <code>this</code> 指针，因为友元不是类的成员</p><h3 id="类指针"><a href="#类指针" class="headerlink" title="类指针"></a>类指针</h3><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 <code>-&gt;</code>，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     func()&#123;&#125;</span><br><span class="line">     ...</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Box *ptrBox;</span><br><span class="line">ptrBox-&gt;func();</span><br></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>变量和函数都可以被声明为静态的</p><ol><li><p>声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员在类的所有对象中是共享的<br>不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化</p></li><li><p>把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。<br>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> objectCount;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> objectCount;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类 Box 的静态成员</span></span><br><span class="line"><span class="keyword">int</span> Box::objectCount = <span class="number">0</span>;</span><br><span class="line">output = Box::getCount()</span><br></pre></td></tr></table></figure><h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前</p><ol><li><p>auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符</p></li><li><p>register(C++ 11 弃用) 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）</p></li><li><p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</p></li><li><p>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p></li></ol><p>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。</p><ol><li><p>mutable 说明符仅适用于类的对象，它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p></li><li><p>thread_local 说明符声明的变量仅可在它在其上创建的线程上访问，变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p></li></ol><p>thread_local 说明符可以与 static 或 extern 合并。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p><p>当创建一个类时，不需要重新编写新的<strong>数据成员和成员函数</strong>，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p><p>派生类可以访问基类中所有的<strong>非私有成员</strong>。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p><p><code>class derived-class: (public/protected/private) base-class</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性，C++ 类可以从多个类继承成员</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="虚继承：解决多继承中出现的问题"><a href="#虚继承：解决多继承中出现的问题" class="headerlink" title="虚继承：解决多继承中出现的问题"></a>虚继承：解决多继承中出现的问题</h3><p>从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。</p><p>虚继承在创建对象的时候会创建一个虚表，从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。</p><p>这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类:</span> <span class="keyword">virtual</span> 方式<span class="number">1</span> 基类<span class="number">1</span>，<span class="keyword">virtual</span> 方式<span class="number">2</span> 基类<span class="number">2</span>，...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">...<span class="comment">//派生类成员声明</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><h3 id="派生类无法从基类继承"><a href="#派生类无法从基类继承" class="headerlink" title="派生类无法从基类继承"></a>派生类无法从基类继承</h3><p>基类的构造函数、析构函数和拷贝构造函数<br>基类的重载运算符<br>基类的友元函数</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p><p>编译器通过把使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>重定义或重载大部分 C++ 内置的运算符，使用自定义类型的运算符。</p><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p><p><code>Box operator+(const Box&amp; b); // 重载+运算符</code></p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一个类中，声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"整数为: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>  f)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"浮点数为: "</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串为: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>4.2“覆盖”是指派生类函数覆盖基类函数，特征是：<br>（1）不同的范围（分别位于派生类与基类）；<br>（2）函数名字相同；<br>（3）参数相同；<br>（4）基类函数必须有 virtual 关键字。</p><p>4.3“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，特征是：</p><p>（1）如果派生类的函数与基类的函数同名，但是参数不同，此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。<br>（2）如果派生类的函数与基类的函数同名，但是参数相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p><h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><hr><p>参考资料：<br><a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">http://c.biancheng.net/cplus/</a><br>w3school</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-基础笔记-(loading…)&lt;br&gt;C++面向对象编程知识点复习梳理，包括类、继承、重载、多态、数据抽象、数据封装、接口&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="c++" scheme="https://hyqskevin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的相关操作</title>
    <link href="https://hyqskevin.github.io/2019/03/24/bintree/"/>
    <id>https://hyqskevin.github.io/2019/03/24/bintree/</id>
    <published>2019-03-24T02:33:15.000Z</published>
    <updated>2020-11-19T06:56:09.923Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的笔记 loading…</p><a id="more"></a><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h2 id="四种遍历方法"><a href="#四种遍历方法" class="headerlink" title="四种遍历方法"></a>四种遍历方法</h2><h2 id="二叉树静态实现"><a href="#二叉树静态实现" class="headerlink" title="二叉树静态实现"></a>二叉树静态实现</h2><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="一般意义上的树"><a href="#一般意义上的树" class="headerlink" title="一般意义上的树"></a>一般意义上的树</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的笔记 loading…&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>基于二叉树的衍生算法</title>
    <link href="https://hyqskevin.github.io/2019/03/24/bintree2/"/>
    <id>https://hyqskevin.github.io/2019/03/24/bintree2/</id>
    <published>2019-03-24T02:33:15.000Z</published>
    <updated>2020-11-19T06:56:10.609Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树衍生算法 loading…</p><a id="more"></a><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树衍生算法 loading…&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>二分查找策略</title>
    <link href="https://hyqskevin.github.io/2019/03/21/two-divide/"/>
    <id>https://hyqskevin.github.io/2019/03/21/two-divide/</id>
    <published>2019-03-21T13:33:15.000Z</published>
    <updated>2020-11-19T06:55:24.473Z</updated>
    
    <content type="html"><![CDATA[<p>需要一个严格单调的序列，就能将 O(n)的复杂度降到 O(logn)的优秀算法<br>非常适合有序数列的查找<br>二分的思想也可以用来逼近准确值和降幂求值</p><a id="more"></a><h2 id="二分查找思路"><a href="#二分查找思路" class="headerlink" title="二分查找思路"></a>二分查找思路</h2><p>设 left，right，mid，查找数 x<br>查找的数 &gt; mid，left = mid + 1<br>查找的数 &lt; mid，right = mid - 1<br>直到查找的数 = mid，程序结束</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">  &#123;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[mid] == x) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[mid] &gt; x)</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//查找失败则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;  <span class="comment">//序列元素个数</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">array</span>[n] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> result = binSearch(<span class="built_in">array</span>,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mid = (left + right) / 2 可能会导致 int 类型溢出，可以改成 mid = left + (right - left) / 2</li></ul><h2 id="当序列中有相同的元素"><a href="#当序列中有相同的元素" class="headerlink" title="当序列中有相同的元素"></a>当序列中有相同的元素</h2><p>求解序列中第一个等于 x 的元素和最后一个等于 x 的元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">  &#123;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[mid] &gt;= x)</span><br><span class="line">      right = mid;</span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left;  <span class="comment">// left==right 循环停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">  &#123;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[mid] &gt; x)</span><br><span class="line">      right = mid;</span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left;  <span class="comment">// left==right 循环停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逼近无理数近似值"><a href="#逼近无理数近似值" class="headerlink" title="逼近无理数近似值"></a>逼近无理数近似值</h2><p>计算 f(x)中 x 的值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ...;  <span class="comment">// f(x)的公式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> L, <span class="keyword">double</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> left = L, right = R, mid;</span><br><span class="line">  <span class="keyword">while</span>(right - left &gt; eps)</span><br><span class="line">  &#123;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(func(mid)&gt;<span class="number">0</span>) right = mid;</span><br><span class="line">    <span class="keyword">else</span> left = mid</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速求幂"><a href="#快速求幂" class="headerlink" title="快速求幂"></a>快速求幂</h2><p>二分幂的思想可以用来降低时间复杂度<br>若 b 为奇数，a^b = a <em> a^b-1<br>若 b 为偶数，a^b = a^b/2 </em> a^b/2<br>直到 a^0 =1，依次退回计算</p><h3 id="快速幂递归写法"><a href="#快速幂递归写法" class="headerlink" title="快速幂递归写法"></a>快速幂递归写法</h3><p>求解 a^b%m 的递归写法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">binFunc</span><span class="params">(LL a, LL b, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// a^0 == 1</span></span><br><span class="line">  <span class="keyword">if</span>(b % <span class="number">2</span> ==<span class="number">1</span>) <span class="keyword">return</span> a* binFunc(a, b<span class="number">-1</span>, m) % m;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LL mul = binFunc(a, b/<span class="number">2</span>, m);</span><br><span class="line">    <span class="keyword">return</span> mul * mul % m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>b % 2 ==1</code>可以写成<code>b&amp;1</code>,将 b 和 1 进行按位与操作，判断 b 末尾是否为 1</li></ul><h3 id="快速幂非递归写法"><a href="#快速幂非递归写法" class="headerlink" title="快速幂非递归写法"></a>快速幂非递归写法</h3><p>将 b 写成若干 2 次幂之和，将 a^b 表示成若干项乘积</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">binFunc</span><span class="params">(LL a, LL b, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LL ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans * a % m;  <span class="comment">//判断2进制末尾是否为1，是的话*a</span></span><br><span class="line">    a = a * a % m;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要一个严格单调的序列，就能将 O(n)的复杂度降到 O(logn)的优秀算法&lt;br&gt;非常适合有序数列的查找&lt;br&gt;二分的思想也可以用来逼近准确值和降幂求值&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>分治和递归基础算法</title>
    <link href="https://hyqskevin.github.io/2019/03/21/divide/"/>
    <id>https://hyqskevin.github.io/2019/03/21/divide/</id>
    <published>2019-03-21T02:02:47.000Z</published>
    <updated>2020-11-19T06:55:58.925Z</updated>
    
    <content type="html"><![CDATA[<p>写分治和贪心时，习惯性地会去思索程序的全局，而一旦展开去想，基本上就大脑溢出了<br>目前还是无法把握<strong>递归式</strong>和<strong>递归</strong>边界，这算法终将是一生之敌。</p><a id="more"></a><h2 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h2><p>用 Fibonacci 数列简单熟悉一下算法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span> | n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//递归边界</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>);  <span class="comment">//递归式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,Fibonacci(n));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>按照字典顺序从小到大顺序输出 1-n 全排列</p><p>思路：数组 P 存放当前排列，hashTable 置为 true 存放已在 P 中的数字<br>递归式：P 按位处理，数字 x 不在 P 中，将 x 填入 P，P 处理下一位<br>递归边界：处理完 n 位，输出排列，hashTable[x]=false 还原</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> P[maxn],hashTable[maxn] = &#123;<span class="literal">false</span>&#125;,n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理第index位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index == n+<span class="number">1</span>)  <span class="comment">//到达递归边界</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>,P[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)  <span class="comment">//递归式逻辑</span></span><br><span class="line">      &#123;</span><br><span class="line">        P[index] = x;</span><br><span class="line">        hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">        generateP(index+<span class="number">1</span>);</span><br><span class="line">        hashTable[x] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);  <span class="comment">//输入有几个数</span></span><br><span class="line">  generateP(<span class="number">1</span>)；  <span class="comment">//从1开始递归</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n 皇后问题"></a>n 皇后问题</h2><p>皇后两两不在同行同列同对角线</p><p>思路：到达递归边界时，遍历任意两个皇后查看是否满足条件<br>递归边界：列 index 到达 n，满足八皇后条件，count+1<br>递归式：行 x 不在 hashTable 中，此列放置皇后，index 移动到下一列</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(index == n+<span class="number">1</span>)  <span class="comment">//到达递归边界，判断是否合法</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(P[i]-P[j]) == <span class="built_in">abs</span>(i-j))</span><br><span class="line">          flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag) count++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)  <span class="comment">//递归式</span></span><br><span class="line">      &#123;</span><br><span class="line">        P[index] = x;</span><br><span class="line">        hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">        generateP(index+<span class="number">1</span>);</span><br><span class="line">        hashTable[x] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举所有情况会比较耗时间，可以在放置皇后的同时遍历之前的，判断是否有冲突</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(inedx == n+<span class="number">1</span>)  <span class="comment">//到达递归边界</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>; pre&lt;index; pre++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">abs</span>(P[index]-P[pre]) == <span class="built_in">abs</span>(index-pre))</span><br><span class="line">          &#123;</span><br><span class="line">            flag == <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">          P[index] = x;</span><br><span class="line">          hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">          generateP(index+<span class="number">1</span>);</span><br><span class="line">          hashTable[x] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写分治和贪心时，习惯性地会去思索程序的全局，而一旦展开去想，基本上就大脑溢出了&lt;br&gt;目前还是无法把握&lt;strong&gt;递归式&lt;/strong&gt;和&lt;strong&gt;递归&lt;/strong&gt;边界，这算法终将是一生之敌。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>cpp_stl</title>
    <link href="https://hyqskevin.github.io/2019/03/20/cpp-stl/"/>
    <id>https://hyqskevin.github.io/2019/03/20/cpp-stl/</id>
    <published>2019-03-20T11:33:58.000Z</published>
    <updated>2020-11-19T06:56:04.699Z</updated>
    
    <content type="html"><![CDATA[<p>C++ STL 接触(loading…)<br>在学习 C++，数据结构基础上，STL 是基础和进阶的分水岭，要多尝试用 STL 实现常用的算法和数据结构</p><a id="more"></a><h2 id="Template（模板）"><a href="#Template（模板）" class="headerlink" title="Template（模板）"></a>Template（模板）</h2><p>模板（Template）指 C++程序设计设计语言中采用类型作为参数的程序设计，支持通用程序设计。C++ 的标准库提供许多有用的函数大多结合了模板的观念，如 STL 以及 IO Stream。</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>可以实现不同类型的函数代码的复用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt; swap(t &amp;t1, t &amp;t2)&#123;</span><br><span class="line">  t tmpT;</span><br><span class="line">  tmpT = t1;</span><br><span class="line">  t1 = t2;</span><br><span class="line">  t2 = tmpT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板实例化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">float</span> num3 = <span class="number">1.0</span>, num4 = <span class="number">2.0</span>;</span><br><span class="line">  swap&lt;<span class="keyword">int</span>&gt;(num1, num2);</span><br><span class="line">  swap&lt;<span class="keyword">float</span>&gt;(num3, num4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>可以实现不同类型的类的复用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">t</span>&gt; <span class="title">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Stack()&#123;</span><br><span class="line">      maxSize = <span class="number">100</span>;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      p = <span class="keyword">new</span> t[maxSize];</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Stack()&#123;</span><br><span class="line">      <span class="keyword">delete</span> p[];</span><br><span class="line">      p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(t num)</span></span>&#123;</span><br><span class="line">      size++;</span><br><span class="line">      p[size<span class="number">-1</span>] = num;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">t <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">      t num = p[size<span class="number">-1</span>];</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    t *p;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板实例化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Stack&lt;<span class="keyword">int</span>&gt; intStack;</span><br><span class="line">  Stack&lt;<span class="keyword">float</span>&gt; floatStack;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  intStack.push(<span class="number">1</span>);</span><br><span class="line">  intStack.push(<span class="number">2</span>);</span><br><span class="line">  intStack.push(<span class="number">3</span>);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!intStack.isEmpty())&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,intStack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>模板可以有常规的类型参数，也可以有默认模板参数<br><code>template&lt;class t, int maxSize = 100&gt; class stack{}</code></p><p>一个类没有模板参数，但是成员函数有模板参数，是可行的</p><p>有些特殊的参数可以使用模板专门化<br><code>template&lt;&gt; void swap(std::vector&lt;int&gt;&amp; t1, std::vector&lt;int&gt;&amp; t2){}</code></p><h2 id="string-类"><a href="#string-类" class="headerlink" title="string 类"></a>string 类</h2><p>使用指针 ++ 和 — 操作符来遍历字符串，无论 ASCII 码字符串还是 Unicode 字符串，使用指针均能够正确无误地返回要寻求的字符位置。使用数组处理字符串中的字符也非常方便。</p><p>STL 中只有一个字符串类，即 basic_string。类 basic_string 实现管理以 \0 结尾的字符数组，字符类型由模板参数决定。basic_string 有两个预定义类型：包含 char 的 string 类型和包含 wchar 的 wstring 类型。</p><p>string 作为类出现，其集成的操作函数足以完成多数情况下的需要。可以使用 “=” 进行赋值，使用 “==” 进行等值比较，使用 “+” 做串联。</p><p>string 类包含了 6 个构造函数。string 类支持 cin 方式和 getline() 方式两种输入方式。</p><h3 id="basic-string"><a href="#basic-string" class="headerlink" title="basic_string"></a>basic_string</h3><p>basic_string 是一个类模板，包括 string，wstring，u16stirng 和 u32string<br><code>typedef basic_string &lt;char&gt; string;</code><br><code>typedef basic_string &lt;wchar&gt; wstring;</code> //wstring 类是为了便于使用宽字符集，例如 Unicode 或某些欧洲字符集</p><h3 id="string-函数"><a href="#string-函数" class="headerlink" title="string 函数"></a>string 函数</h3><p>string 类提供的各种操作函数大致分为八类：构造器和析构器、大小和容量、元素存取、字 符串比较、字符串修改、字符串接合、I/O 操作以及搜索和查找。</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数名称</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">构造函数</td><td style="text-align:left">产生或复制字符串</td></tr><tr><td style="text-align:left">析构函数</td><td style="text-align:left">销毁字符串</td></tr><tr><td style="text-align:left">=，assign</td><td style="text-align:left">赋以新值</td></tr><tr><td style="text-align:left">Swap</td><td style="text-align:left">交换两个字符串的内容</td></tr><tr><td style="text-align:left"><strong>+ =，append( )，push_back()</strong></td><td style="text-align:left">添加字符</td></tr><tr><td style="text-align:left">insert ()</td><td style="text-align:left">插入字符</td></tr><tr><td style="text-align:left">erase()</td><td style="text-align:left">删除字符</td></tr><tr><td style="text-align:left">clear ()</td><td style="text-align:left">移除全部字符</td></tr><tr><td style="text-align:left">resize ()</td><td style="text-align:left">改变字符数量</td></tr><tr><td style="text-align:left">replace()</td><td style="text-align:left">替换字符</td></tr><tr><td style="text-align:left"><strong>+</strong></td><td style="text-align:left">串联字符串</td></tr><tr><td style="text-align:left">==，！ =，&lt;，&lt;=，&gt;，&gt;=，<strong>compare()</strong></td><td style="text-align:left">比较字符串内容</td></tr><tr><td style="text-align:left"><strong>size()，length()</strong></td><td style="text-align:left">返回字符数量</td></tr><tr><td style="text-align:left">max_size ()</td><td style="text-align:left">返回字符的最大可能个数</td></tr><tr><td style="text-align:left">empty ()</td><td style="text-align:left">判断字符串是否为空</td></tr><tr><td style="text-align:left">capacity ()</td><td style="text-align:left">返回重新分配之前的字符容量</td></tr><tr><td style="text-align:left">reserve()</td><td style="text-align:left">保留内存以存储一定数量的字符</td></tr><tr><td style="text-align:left"><strong>[ ],at()</strong></td><td style="text-align:left">获取字符串元素</td></tr><tr><td style="text-align:left">&gt;&gt;，getline()</td><td style="text-align:left">从 stream 中读取某值</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">将值写入 stream</td></tr><tr><td style="text-align:left">copy()</td><td style="text-align:left">将内容复制为一个 C - string</td></tr><tr><td style="text-align:left"><strong>c_str()</strong></td><td style="text-align:left">将内容以 C - string 形式返回</td></tr><tr><td style="text-align:left">data()</td><td style="text-align:left">将内容以字符数组形式返回</td></tr><tr><td style="text-align:left">substr()</td><td style="text-align:left">返回子字符串</td></tr><tr><td style="text-align:left"><strong>find()</strong></td><td style="text-align:left">搜寻某子字符串或字符</td></tr><tr><td style="text-align:left"><strong>rfind()</strong></td><td style="text-align:left">逆向搜寻字符串或字符</td></tr><tr><td style="text-align:left"><strong>find_first_of()**</strong>find_last_of()**</td><td style="text-align:left">搜寻第一个/最后一个匹配的字符串</td></tr><tr><td style="text-align:left">begin( )，end()</td><td style="text-align:left">提供正向迭代器支持</td></tr><tr><td style="text-align:left">rbegin()，rend()</td><td style="text-align:left">提供逆向迭代器支持</td></tr><tr><td style="text-align:left">get_allocator()</td><td style="text-align:left">返回配置器</td></tr></tbody></table></div><h3 id="string-构造和析构函数"><a href="#string-构造和析构函数" class="headerlink" title="string 构造和析构函数"></a>string 构造和析构函数</h3><ul><li>类构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> strs <span class="comment">//生成空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str)</span> <span class="comment">//生成字符串str的复制品</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, stridx)</span> <span class="comment">//将字符串str中始于stridx的部分作为构造函数的初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, strbegin, <span class="built_in">strlen</span>)</span> <span class="comment">//将字符串str中始于strbegin、长度为strlen的部分作为字符串初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr)</span> <span class="comment">//以C_string类型cstr作为字符串s的初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr,char_len)</span>    <span class="comment">//以C_string类型cstr的前char_len个字符串作为字符串s的初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(num, c)</span> <span class="comment">//生成一个字符串，包含num个c字符</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(strs, beg, end)</span>    <span class="comment">//以区间[beg, end]内的字符作为字符串s的初值</span></span></span><br></pre></td></tr></table></figure><ul><li>析构函数<br><code>~string() //销毁所有内存，释放内存</code></li></ul><h2 id="5-种序列容器"><a href="#5-种序列容器" class="headerlink" title="5 种序列容器"></a>5 种序列容器</h2><p>序列容器以线性序列的方式存储元素。它没有对元素进行排序，元素的顺序和存储它们的顺序相同。</p><ol><li><code>array&lt;T,N&gt;</code> (数组容器) ：是一个长度固定的序列，有 N 个 T 类型的对象，不能增加或删除元素。</li><li><code>vector&lt;T&gt;</code> (向量容器) ：是一个长度可变的序列，用来存放 T 类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。</li><li><code>deque&lt;T&gt;</code> (双向队列容器) ：是一个长度可变的、可以自动增长的序列，在序列的两端都不能高效地增加或删除元素。</li><li><code>list&lt;T&gt;</code> (链表容器) 是一个长度可变的、由 T 类型对象组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。访问容器中任意元素的速度要比前三种容器慢，这是因为 <code>list&lt;T&gt;</code> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li><li><code>forward list&lt;T&gt;</code> (正向链表容器) ：是一个长度可变的、由 T 类型对象组成的序列，它以单链表的形式组织元素，是一类比链表容器快、更节省内存的容器，但是它内部的元素只能从第一个元素开始访问。</li></ol><h3 id="常用函数成员"><a href="#常用函数成员" class="headerlink" title="常用函数成员"></a>常用函数成员</h3><p>函数成员 array<t,n> vector<t> deque<t><br>begin() - 返回幵始迭代器 是 是 是<br>end() - 返回结束迭代器 是 是 是<br>rbegin() - 返回反向’开始迭代器 是 是 是<br>rend() - 返回反向结束迭代器 是 是 是<br>cbegin() - 返 M const 开始迭代器 是 是 是<br>cend() - 返回 const 结束迭代器 是 是 是<br>crbegin() - 返回 const 反向开始迭代器 是 是 是<br>crend() - 返回 const 反向结束迭代器 是 是 是<br>assign() - 用新元素替换原有内容 - 是 是<br>operator=() - 复制同类型容器的元素，或者用初始化列表替换 现有内容 是 是 是<br>size() - 返回实际元素个数 是 是 是<br>max_size() - 返回元素个数的设大值 是 是 是<br>capacity() - 返回当前容量 - 是 -<br>empty() - 返回 true,如果容器中没有元素的话 是 是 是<br>resize() - 改变实际元素的个数 - 是 是<br>shrink _to_fit() - 将内存减少到等于当前元素实际所使用的大小 - 是 是<br>front() - 返回第一个元素的引用 是 是 是<br>back() - 返回铖后一个元素的引用 是 是 是<br>operator<a href></a> - 使用索弓丨访问元素 是 是 是<br>at() - 使用经过边界检査的索引访问元素 是 是 是<br>push_back() - 在序列的尾部添加一个元素 - 是 是<br>insert() - 在指定的位置插入一个或多个元素 - 是 是<br>emplace() - 在指定的位置直接生成一个元素 - 是 是<br>emplace_back() - 在序列尾部生成一个元素 - 是 是<br>pop_back() - 移出序列尾部的元素 - 是 是<br>erase() - 移出一个元素或一段元素 - 是 是<br>clear() - 移出所苻的元素，容器大小变为 0 - 是 是<br>swap() - 交换两个容器的所有元素 是 是 是<br>data() - 返回包含元素的内部数组的指针 是 是 -</t></t></t,n></p><p>函数成员 list<t> forward list<t><br>begin() - 返回开始迭代器 是 是<br>end() - 返回结束迭代器 是 是<br>rbegin() - 返回反向开始迭代器 是 -<br>rend() - 返回反向结束迭代器 是 -<br>cbegin() - 返回 const 开始结束迭代器 是 是<br>before_begin() - 返回一个指向第一个元素前一个位置的迭代器 - 是<br>cbefore_begin() - 返回一个指向第一个元素前一个位置的 const 迭代器 - 是<br>cend() - 返回 const 结束迭代器 是 是<br>crbegin() - 返回 const 反向开始迭代器 是 -<br>crend() - 返回 const 反向结束迭代器 是 -<br>assign() - 用新元素替换原有内容 是 是<br>operator=() - 复制同类型容器的元素，或者用初始化列表替换现有内容 是 是<br>size() - 返回实际元素个数 是 -<br>max_size() - 返回元素个数的最大值 是 是<br>resize() - 改变实际元素的个数 是 是<br>empty() - 返回 true，如果容器中没有元素的话 是 是<br>from() - 返回第一个元素的引用 是 是<br>back() - 返回最后一个元素的引用 是 -<br>push_back() - 在序列的潘部添加一个元素 是 -<br>push_front() - 在序列的起始位置添加一个元素 是 是<br>emplace() - 在指矩位置直接生成一个元素 是 -<br>emplace_after() - 在指定位置的后面直接生成一个元素 - 是<br>emplace_back() - 在序列尾部生成一个元素 是 -<br>cmplacc_front() - 在序列的起始位生成一个元索 是 是<br>insert() - 在指定的位置插入一个或多个元素 是 -<br>insert_after() - 在指定位置的后面插入一个或多个元素 - 是<br>pop_back() - 移除序列尾部的元素 是 -<br>pop_front() - 移除序列头部的元素 是 是<br>reverse()-反向元素的顺序 是 是<br>erase() - 移除指定位置的一个元素或一段元素 是 -<br>erase_after() - 移除指定位 1；后面的一个元素或一段元素 - 是<br>remove() - 移除所苻和参数匹配的元素 是 是<br>remove_if() - 移除满足一元函数条件的所有元素 是 是<br>unique() - 移除所有连续重复的元素 是 是<br>clear() - 移除所有的元素，容器大小变为 0 是 是<br>swap() - 交换两个容器的所有元素 是 是<br>sort() - 对元素进行排序 是 是<br>merge() - 合并两个有序容器 是 是<br>splice() - 移动指定位置前面的所有元素到另一个同类型的 list 中 是 -<br>splice_after() - 移动指定位置后面的所有元素到另一个同类型的 list 中 - 是</t></t></p><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p>array：<code>std::array&lt;typename, 100&gt; data {};</code></p><ul><li>通过调用数组对象的成员函数 fill()，可以将所有元素设成给定值 <code>data.fill(0.0);</code></li><li>获取元素 <code>data[num]</code><ul><li>为了获取时能够检查越界索引值，可以使用成员函数 at()，当传给 at() 的索引是一个越界值时，这时会抛出 std::out_of_rang 异常 <code>data.at(num)</code></li></ul></li></ul><p>vector：<code>std::vector&lt;typename&gt; values(num) {1,2,3,...};</code></p><ul><li>通过调用 reserve() 来增加容器的容量 <code>values.reserve(20)</code></li><li>通过调用成员函数 resize() 可以改变容器大小 <code>values.resize(size, num)</code></li><li>使用 push_back()、insert()、emplace() 或 emplace_back() 函数来添加一个元素<br><code>values.push_back()</code> //使用时会调用构造函数和拷贝构造函数<br><code>values.emplace_back()</code> // 不需要触发构造函数和拷贝构造函数<br><code> </code></li><li>front() 和 back() 分別返回序列中第一个和最后一个元素的引用 <code>values.front()</code></li><li>data() 返回指向数组的指针 <code>values.data()</code></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li>迭代器<br><code>auto first = std::begin(data);</code><br><code>auto last = std::end (data);</code></li></ul><h2 id="3-种容器适配器"><a href="#3-种容器适配器" class="headerlink" title="3 种容器适配器"></a>3 种容器适配器</h2><p>容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。</p><ol><li><code>stack&lt;T&gt;</code>：是一个封装了 <code>deque&lt;T&gt;</code> 容器的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。<code>stack&lt;T&gt;</code>· 模板定义在头文件 stack 中。</li><li><code>queue&lt;T&gt;</code>：是一个封装了 <code>deque&lt;T&gt;</code> 容器的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器。<code>queue&lt;T&gt;</code> 模板定义在头文件 queue 中。</li><li><code>priority_queue&lt;T&gt;</code>：是一个封装了 <code>vector&lt;T&gt;</code> 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。<code>priority_queue&lt;T&gt;</code> 模板定义在头文件 queue 中。</li></ol><h2 id="4-种-map-容器"><a href="#4-种-map-容器" class="headerlink" title="4 种 map 容器"></a>4 种 map 容器</h2><p><code>map&lt;K，T&gt;</code>容器，保存的是 <code>pair&lt;const K，T&gt;</code> 类型的元素。<code>pair&lt;const K,T&gt;</code> 封装了一对键对象，键的类型是 K，对象的类型是 T。每个键都是唯一的，所以不允许有重复的键；但可以保存重复的对象，只要它们的键不同。map 容器中的元素都是有序的，元素在容器内的顺序是通过比较键确定的。默认使用 less<k> 对象比较。<br>multimap<k，t> 容器和 map<k，t> 容器类似，也会对元素排序。它的键必须是可比较的，元素的顺序是通过比较键确定的。和 map<k，t> 不同的是，multimap<k，t> 允许使用重复的键。因此，一个 multimap 容器可以保存多个具有相同键值的 <const k,t> 元素。<br>unordered_map<k，t> 中 pair&lt; const K，T&gt;元素的顺序并不是直接由键值确定的，而是由键值的哈希值决定的。哈希值是由一个叫作哈希的过程生成的整数，本章后面会解释这一点。unordered_map<k，t>不允许有重复的键。<br>unordered_multimap<k,t> 也可以通过键值生成的哈希值来确定对象的位置，但它允许有重复的键。</k,t></k，t></k，t></const></k，t></k，t></k，t></k，t></k></p><h2 id="set-容器"><a href="#set-容器" class="headerlink" title="set 容器"></a>set 容器</h2><p>set 容器是关联容器，其中的对象是对象它们自己的键</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h2 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h2><h2 id="数值、时间和复数"><a href="#数值、时间和复数" class="headerlink" title="数值、时间和复数"></a>数值、时间和复数</h2><h2 id="C-常用算法和-algorithm-库"><a href="#C-常用算法和-algorithm-库" class="headerlink" title="C++常用算法和 algorithm 库"></a>C++常用算法和 algorithm 库</h2><hr><p>参考资料<br><a href="http://c.biancheng.net/stl/" target="_blank" rel="noopener">C 语言中文网</a><br>C++ Primer Plus 第 6 版中文版<br>学校教材</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ STL 接触(loading…)&lt;br&gt;在学习 C++，数据结构基础上，STL 是基础和进阶的分水岭，要多尝试用 STL 实现常用的算法和数据结构&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="c++" scheme="https://hyqskevin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>散列表基础算法</title>
    <link href="https://hyqskevin.github.io/2019/03/19/hashtable/"/>
    <id>https://hyqskevin.github.io/2019/03/19/hashtable/</id>
    <published>2019-03-19T02:10:47.000Z</published>
    <updated>2020-11-19T06:55:54.892Z</updated>
    
    <content type="html"><![CDATA[<p>-散列基础-<br>散列（hash）是常用的算法思想之一，它使用空间换时间的思想在我第一次碰到时就感觉巧妙如魔法一般。特别是在进行一些大量数字和字符串比较方面，hash 能瞬间将 O(n^2)的复杂度降到 O(n),单次查询的复杂度降到 O(1)，靠的就是数组下标与查询的元素之间建立的唯一转换关系。</p><a id="more"></a><h2 id="常用-hash"><a href="#常用-hash" class="headerlink" title="常用 hash"></a>常用 hash</h2><p>线性变换函数：H(key) = a*key+b<br>除留余数：h(key) = key%mod</p><p>除留余数法会出现<strong>冲突</strong>的情况，需要解决多个 hash 值相同的情况</p><ol><li>线性探测法：从当前位置检查相邻地址是否被占用，如果都被占用，循环检查下一个位置</li><li>平方探测法：从当前位置检查+1，-1，+4，-4，+9，-9……如果检查中+k^2 超过表长（Tablesize），[H(key)+k^2]%Tablesize</li><li>链地址法：把 hash 相同的 key 连接成单链表</li></ol><h2 id="整数-hash"><a href="#整数-hash" class="headerlink" title="整数 hash"></a>整数 hash</h2><h3 id="查询数组-M-中的数在数组-N-中是否出现过"><a href="#查询数组-M-中的数在数组-N-中是否出现过" class="headerlink" title="查询数组 M 中的数在数组 N 中是否出现过"></a>查询数组 M 中的数在数组 N 中是否出现过</h3><p>常规思路：遍历所有 N，要遍历 M 次，时间复杂度 O(MN)<br>hash 思路：bool hashTable[maxn]={false}，先读入 N，N 中出现的数 x，hashTable[x]=true,再查询 M，时间复杂度 O(M+N)</p><ul><li>示例</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n[<span class="number">10</span>] = &#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> m[<span class="number">3</span>] = &#123;<span class="number">8</span>,<span class="number">22</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">      hashTable&#123;n[i]&#125; = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(hashTable&#123;m[j]]&#125; == <span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,yes\n"</span>,m[j]);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d,no\n"</span>,m[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询-M-中的数在-N-中出现的次数"><a href="#查询-M-中的数在-N-中出现的次数" class="headerlink" title="查询 M 中的数在 N 中出现的次数"></a>查询 M 中的数在 N 中出现的次数</h3><p>将 hashTable 替换为 int 类型进行计数</p><ul><li>示例</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> hashTable[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n[<span class="number">10</span>] = &#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> m[<span class="number">3</span>] = &#123;<span class="number">8</span>,<span class="number">12</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">      hashTable&#123;n[i]&#125;++;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hashTable&#123;m[j]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串-hash"><a href="#字符串-hash" class="headerlink" title="字符串 hash"></a>字符串 hash</h2><p>需要将字符串和整数唯一对应，可以直接对应或使用 hash 函数对应：A-Z 0~25，a-z 26~51</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字符串S转换为整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> hashID = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(S[i]&gt;=<span class="string">'A'</span> &amp;&amp; S[i]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">      hashID = hashID*<span class="number">52</span> + S[i] - <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S[i]&gt;=<span class="string">'a'</span> &amp;&amp; S[i]&lt;=<span class="string">'z'</span>)</span><br><span class="line">      hashID = hashID*<span class="number">52</span> + S[i]-<span class="string">'a'</span>+ <span class="number">26</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id = hashFunc(P[i],<span class="number">52</span>);</span><br><span class="line">hashTable[id] = P[i];</span><br></pre></td></tr></table></figure><h3 id="查询-N-个字符串中-M-个字符串出现的次数，每个字符串长度固定为-5"><a href="#查询-N-个字符串中-M-个字符串出现的次数，每个字符串长度固定为-5" class="headerlink" title="查询 N 个字符串中 M 个字符串出现的次数，每个字符串长度固定为 5"></a>查询 N 个字符串中 M 个字符串出现的次数，每个字符串长度固定为 5</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> S[maxn][<span class="number">5</span>],temp[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> hashTable[<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个字符串拥有唯一id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    id = id*<span class="number">26</span> + (S[i]-<span class="string">'A'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sacnf(<span class="string">"%s"</span>, S[i]);</span><br><span class="line">    <span class="keyword">int</span> id  = hashFunc(s[i], <span class="number">3</span>);</span><br><span class="line">    hashTable[id]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sacnf(<span class="string">"%s"</span>,temp);</span><br><span class="line">    <span class="keyword">int</span> id = hashFunc(temp, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,hashTable[id]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-散列基础-&lt;br&gt;散列（hash）是常用的算法思想之一，它使用空间换时间的思想在我第一次碰到时就感觉巧妙如魔法一般。特别是在进行一些大量数字和字符串比较方面，hash 能瞬间将 O(n^2)的复杂度降到 O(n),单次查询的复杂度降到 O(1)，靠的就是数组下标与查询的元素之间建立的唯一转换关系。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
</feed>
