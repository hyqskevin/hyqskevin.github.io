<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MonoShow</title>
  
  <subtitle>Monologue from Kevin_W</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hyqskevin.github.io/"/>
  <updated>2019-08-23T08:51:09.880Z</updated>
  <id>https://hyqskevin.github.io/</id>
  
  <author>
    <name>Kevin W</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何写日志</title>
    <link href="https://hyqskevin.github.io/2019/08/04/write_log/"/>
    <id>https://hyqskevin.github.io/2019/08/04/write_log/</id>
    <published>2019-08-04T08:56:30.000Z</published>
    <updated>2019-08-23T08:51:09.880Z</updated>
    
    <content type="html"><![CDATA[<p>在开发时学习书写日志的方法，方便做测试。<br>例举使用python和java上的日志记录<br>—loading…—<br><a id="more"></a></p><h2 id="常用日志框架"><a href="#常用日志框架" class="headerlink" title="常用日志框架"></a>常用日志框架</h2><p>log4j、Logging、commons-logging、slf4j、logback</p><p>Logging：Java 自带的日志工具类<br>Log4j：Apache 的一个开源日志框架，log4j 在 2015/08/05 这一天被 Apache 宣布停止维护了，用户需要切换到 Log4j2上面去<br>commons-logging：日志的门面接口，它也是 apache 最早提供的日志门面接口，用户可以根据喜好选择不同的日志实现框架，而不必改动日志定义<br>Slf4j：Simple Logging Facade for Java，即简单日志门面接口<br>Logback：Slf4j 的原生实现框架，同样也是出自 Log4j 一个人之手，但拥有比 log4j 更多的优点、特性和更做强的性能，现在基本都用来代替 log4j 成为主流</p><ol><li>commons-loggin、slf4j 只是一种日志抽象门面，不是具体的日志框架。</li><li>log4j、logback 是具体的日志实现框架。</li><li>推荐使用 <code>slf4j + logback</code> 还有<code>slf4j + log4j</code> <code>commons-logging + log4j</code> 这两种日志组合框架。</li></ol><ul><li>Python的 logging 模块提供了通用的日志系统。logging 模块与 log4j 的机制相同，只是具体的实现细节不同。</li></ul><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><div class="table-container"><table><thead><tr><th>日志级别(Java)</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>OFF</td><td style="text-align:left">关闭：最高级别，不输出日志。</td></tr><tr><td>FATAL</td><td style="text-align:left">致命：输出非常严重的可能会导致应用程序终止的错误。</td></tr><tr><td>ERROR</td><td style="text-align:left">错误：输出错误，但应用还能继续运行。</td></tr><tr><td>WARN</td><td style="text-align:left">警告：输出可能潜在的危险状况。</td></tr><tr><td>INFO</td><td style="text-align:left">信息：输出应用运行过程的详细信息。</td></tr><tr><td>DEBUG</td><td style="text-align:left">调试：输出更细致的对调试应用有用的信息。</td></tr><tr><td>TRACE</td><td style="text-align:left">跟踪：输出更细致的程序运行轨迹。</td></tr><tr><td>ALL</td><td style="text-align:left">所有：输出所有级别信息。</td></tr></tbody></table></div><p>Java：ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF<br>Python：NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</p><h2 id="Log4J的运用"><a href="#Log4J的运用" class="headerlink" title="Log4J的运用"></a>Log4J的运用</h2><p>Log4j有三个主要的组件：Loggers(记录器)，Appenders(输出源)和Layouts(布局)，这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出</p><h2 id="logging的运用"><a href="#logging的运用" class="headerlink" title="logging的运用"></a>logging的运用</h2><p>logging模块提供 logger、handler、filter、formatter</p><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><p>记录获取到的数据，通过模块的getLogger(name)函数获得</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger = logging.getLogger(<span class="string">'test'</span>)    <span class="comment"># 获取名为 test 的 logger  </span></span><br><span class="line">logger.addHandler(handler)           <span class="comment"># 为 logger 添加 handler  </span></span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>setLevel(lvl)</td><td>设置日志级别</td></tr><tr><td>isEnabledFor(lvl)</td><td>检查某级别的日志是否启用</td></tr><tr><td>getEffectiveLevel()</td><td>获取实际的日志级别</td></tr><tr><td>debug/warning/info/error(msg, <em>args, *</em>kwargs)</td><td>输出对应级别的日志</td></tr><tr><td>log(lvl, msg, <em>args, *</em>kwargs)</td><td>输出指定级别的日志</td></tr><tr><td>addFilter(filt)/removeFilter(filt)</td><td>添加或删除指定的过滤器</td></tr><tr><td>addHandler(hdlr)/removeHandler(hdlr)</td><td>添加或删除指定的处理器</td></tr></tbody></table></div><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>用于指定日志向哪里输出（文件、终端等等）</p><p>常用的Handler有以下几种：</p><ul><li>StreamHandler， 用于向标准输入输出流等输出日志。</li><li>FileHandler，用于向文件输出日志。</li><li>NullHandler，什么也不输出。</li><li>RotatingFileHandler，向文件输出日志，如果文件到达指定大小，创建新文件并继续输出日志。</li></ul><p>相关handler类型参考<a href="https://docs.python.org/zh-cn/3/library/logging.handlers.html#module-logging.handlers" target="_blank" rel="noopener">python官方文档</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler = logging.handlers.RotatingFileHandler(LOG_FILE,axBytes=<span class="number">1024</span>*<span class="number">1024</span>, backupCount = <span class="number">5</span>) <span class="comment"># 实例化 handler</span></span><br></pre></td></tr></table></figure><h3 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h3><p>指定日志记录输出的具体格式，采用的是 %(key)s 的形式<br>formatter构造方法需要两个参数：消息的格式字符串和日期字符串</p><div class="table-container"><table><thead><tr><th>日志格式</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td>%(name)s</td><td style="text-align:left">生成日志的Logger名称</td></tr><tr><td>%(levelno)s</td><td style="text-align:left">数字形式的日志级别，包括DEBUG, INFO, WARNING, ERROR和CRITICAL</td></tr><tr><td>%(levelname)s</td><td style="text-align:left">文本形式的日志级别，包括’DEBUG’、 ‘INFO’、 ‘WARNING’、 ‘ERROR’ 和’CRITICAL’</td></tr><tr><td>%(pathname)s</td><td style="text-align:left">输出该日志的语句所在源文件的完整路径（如果可用）</td></tr><tr><td>%(filename)s</td><td style="text-align:left">文件名</td></tr><tr><td>%(module)s</td><td style="text-align:left">输出该日志的语句所在的模块名</td></tr><tr><td>%(funcName)s</td><td style="text-align:left">调用日志输出函数的函数名</td></tr><tr><td>%(lineno)d</td><td style="text-align:left">调用日志输出函数的语句所在的代码行（如果可用）</td></tr><tr><td>%(created)f</td><td style="text-align:left">日志被创建的时间，UNIX标准时间格式，表示从1970-1-1 00:00:00 UTC计算起的秒数</td></tr><tr><td>%(relativeCreated)d</td><td style="text-align:left">日志被创建时间与日志模块被加载时间的时间差，单位为毫秒</td></tr><tr><td>%(asctime)s</td><td style="text-align:left">日志创建时间。默认格式是 “2003-07-08 16:49:45,896”，逗号后为毫秒数</td></tr><tr><td>%(msecs)d</td><td style="text-align:left">毫秒级别的日志创建时间</td></tr><tr><td>%(thread)d</td><td style="text-align:left">线程ID（如果可用）</td></tr><tr><td>%(threadName)s</td><td style="text-align:left">线程名称（如果可用）</td></tr><tr><td>%(process)d</td><td style="text-align:left">进程ID（如果可用）</td></tr><tr><td>%(message)s</td><td style="text-align:left">日志信息</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 日志样例</span><br><span class="line">2019-08-04 23:21:59,682 - log_test.py:16 - test - first info message</span><br><span class="line">2019-08-04 23:21:59,682 - log_test.py:17 - test - first debug message</span><br><span class="line"></span><br><span class="line"># 日志格式</span><br><span class="line">%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出</p><h4 id="config模块配置日志"><a href="#config模块配置日志" class="headerlink" title="config模块配置日志"></a>config模块配置日志</h4><p>logging.basicConfig()<br>logging</p><h3 id="python-日志示例"><a href="#python-日志示例" class="headerlink" title="python 日志示例"></a>python 日志示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line"><span class="keyword">import</span> logging.handlers  </span><br><span class="line"></span><br><span class="line">LOG_FILE = <span class="string">'test.log'</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">'test'</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化handler</span></span><br><span class="line">consoleHandler = logging.StreamHandler()</span><br><span class="line">Filehandler = logging.handlers.RotatingFileHandler(LOG_FILE,axBytes = <span class="number">1024</span>*<span class="number">1024</span>, backupCount = <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化formatter</span></span><br><span class="line">fmt = <span class="string">'%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s'</span>  </span><br><span class="line">formatter = logging.Formatter(fmt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 handler 添加 formatter</span></span><br><span class="line">consoleHandler.setFormatter(formatter)</span><br><span class="line">Filehandler。setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加到logger中</span></span><br><span class="line">logger.addHandler(consolehandler)</span><br><span class="line">logger.addHandler(Filehandler)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印日志</span></span><br><span class="line">logger.info(<span class="string">'info message'</span>)  </span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.warning(<span class="string">'warn message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical meaasge'</span>)</span><br><span class="line">logger.debug(<span class="string">'%s 自定义信息'</span> % <span class="string">'define message'</span>)</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://blog.csdn.net/wud_jiyanhui/article/details/6213443" target="_blank" rel="noopener">https://blog.csdn.net/wud_jiyanhui/article/details/6213443</a><br><a href="https://blog.csdn.net/u011054333/article/details/69215660" target="_blank" rel="noopener">https://blog.csdn.net/u011054333/article/details/69215660</a><br><a href="https://help.aliyun.com/document_detail/28990.html?spm=a2c4g.11186623.6.746.7cfa66d8dwy2XO" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/28990.html?spm=a2c4g.11186623.6.746.7cfa66d8dwy2XO</a><br><a href="https://help.aliyun.com/document_detail/28989.html?spm=a2c4g.11186623.6.745.3ef949faCiQ7PW" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/28989.html?spm=a2c4g.11186623.6.745.3ef949faCiQ7PW</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发时学习书写日志的方法，方便做测试。&lt;br&gt;例举使用python和java上的日志记录&lt;br&gt;—loading…—&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="python" scheme="https://hyqskevin.github.io/tags/python/"/>
    
      <category term="log" scheme="https://hyqskevin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>boosting</title>
    <link href="https://hyqskevin.github.io/2019/08/01/boosting/"/>
    <id>https://hyqskevin.github.io/2019/08/01/boosting/</id>
    <published>2019-08-01T01:56:30.000Z</published>
    <updated>2019-08-02T09:02:01.570Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xgboost.ai/" target="_blank" rel="noopener">XgBoost</a> 和 <a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="noopener">LightGBM</a> 官方文档阅读和算法学习<br><code>*</code>号为未解释完全，具体使用方法请参考官方文档<br><a id="more"></a></p><h2 id="XgBoost"><a href="#XgBoost" class="headerlink" title="XgBoost"></a>XgBoost</h2><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p><code>booster</code> [default= gbtree ] 基础模型类型，可选参数包括: gbtree、gblinear、dart，其中gbtree、dart为树模型、gblinear为线性函数模型</p><p><code>eta</code> 学习率</p><p><code>tree_method</code> XGBoost中树的构造算法，可选项包括: auto, exact, approx, hist, gpu_exact, gpu_hist</p><p><code>eval_metric</code> 依据目标函数选择评估指标<br>  rmse: 根均方误差<br>  mae: 平均绝对值误差<br>  logloss: 负的似然函数<br>  error: 二分类问题的分类错误率<br>  merror: 多分类问题的分类错误率<br>  mlogloss: 多分类问题的负似然函数<br>  auc: IOC曲线下面积<br>  aucpr: PR曲线下面积</p><p><code>updater</code> 线性模型的拟合算法<br>  shotgun: 基于shotgun算法的坐标下降法<br>  coord_descent: 普通的坐标下降法<br>  feature_selector: 特征选择和排序算法</p><p><code>objective</code> 训练的模型类型和目标函数<br>  reg:linear: 线性回归<br>  reg:logistic: 逻辑回归<br>  binary:logistic: 二分类问题, 输出概率值<br>  binary:logitraw: 二分类问题, 输出得分值，需要通过sigmoid函数转化成概率值<br>  binary:hinge: 二分类问题，使用铰链损失函数,输出0或1，而不是概率值<br>  count:poisson: 用于计数问题的泊松分布，输出泊松分布的均值。<br>  survival:cox: Cox regression for right censored survival time data<br>  multi:softmax: 多分类目标函数, 使用此目标函数，需要设置样本类别数据： num_class<br>  multi:softprob: 同softmax, 但是输出的结果为 ndata * nclass 维的向量，表示样本属于每个类别的概率</p><p><code>cyclic</code>: 循环变量特征<br><code>shuffle</code>: 类型与循环变量特征，但是在每次更新时都会随机打乱特征的顺序<br><code>random</code>: 随机(带替换)的坐标选择器<br><code>greedy</code>: 选择最大梯度的坐标<br><code>thrifty</code>: 近似greedy的坐标选择器<br><code>top_k</code>: greedy算法和thrifty算法选择的最优特征数量，0表示不限制。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><strong>1. 数据结构类，提供数据的构建和处理</strong><br><code>xgboost.DMatrix(data, label=None, missing=None, weight=None, silent=False, feature_names=None, feature_types=None)</code></p><p><code>data</code>数据源或文件路径<br><code>label</code>训练数据的标签<br><code>missing</code>缺省值表示字符，如果没填, 默认值为：np.nan<br><code>weight</code>每个样本的权重<br><code>silent</code>构造数据结构时是否显示日志<br><code>feature_names</code>各个特征的名称<br><code>feature_types</code>各个特征的数据类型<br><code>nthread</code> 加载数据开启的线程数</p><p><strong>2. 模型类，提供了一些基础的函数，如模型加载、保存、评估和预测等方法</strong><br><code>xgboost.Booster(params=None, cache=(), model_file=None)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">load_model(fname)</span><br><span class="line">从文件或内存中加载模型，参数含义如下：</span><br><span class="line"></span><br><span class="line">fname (string <span class="keyword">or</span> a memory buffer) – 模型文件名称或内存缓存对象</span><br><span class="line"><span class="number">2.</span> save_model(fname)</span><br><span class="line">将模型保存到文件中，参数的含义如下：</span><br><span class="line"></span><br><span class="line">fname (string) – 输出文件的名称</span><br><span class="line"><span class="number">3.</span> eval(data, name, iteration)</span><br><span class="line">用给定的数据评估模型好坏，参数的含义如下:</span><br><span class="line"></span><br><span class="line">data (DMatrix) – 用于评估模型的数据</span><br><span class="line"></span><br><span class="line">name (str, 可选) – 用于评估模型的数据集名称</span><br><span class="line"></span><br><span class="line">iteration (int, 可选) –迭代次数</span><br></pre></td></tr></table></figure><p><strong>3. 对模型进行训练</strong><br><code>xgboost.train(params, dtrain, num_boost_round=10, evals=(), obj=None, feval=None, maximize=False, early_stopping_rounds=None, evals_result=None, verbose_eval=True, learning_rates=None, xgb_model=None, callbacks=None)</code></p><p><code>params</code>配置参数<br><code>dtrain</code>训练数据<br><code>num_boost_round</code>生成树的数量<br><code>evals</code>评估数据<br><code>obj</code>自定义的目标函数<br><code>feval</code>自定义的评价函数<br><code>maximize</code>是否最大化评价指标<br><code>early_stopping_rounds</code>错误率early_stopping_rounds轮未下降，则停止训练<br><code>evals_result</code>模型评估结果<br><code>learning_rates</code>学习率<br><code>xgb_model</code>在训练前加载之前训练的模型<br><code>callback</code>设置回调函数，比如重新设置学习率</p><p><strong>4. 对数据分类</strong><br><code>xgboost.XGBClassifier(max_depth=3, learning_rate=0.1, n_estimators=100, silent=True, objective=&#39;binary:logistic&#39;, nthread=-1, gamma=0, min_child_weight=1, max_delta_step=0, subsample=1, colsample_bytree=1, colsample_bylevel=1, reg_alpha=0, reg_lambda=1, scale_pos_weight=1, base_score=0.5, seed=0, missing=None)</code></p><p><code>max_depth</code> 最大树深度<br><code>learning_rate</code> 学习率<br><code>n_estimators</code> 树的迭代次数<br><code>gamma</code> 节点分裂需要下降的最小损失<br><code>min_child_weight</code> 节点中样本的最小权重和<br><code>max_delta_step</code> 每轮允许叶子输出值的最大增量<br><code>subsample</code> 每轮训练使用的样本数量等于样本总数乘以采样率<br><code>colsample_bytree</code> 每轮训练使用的特征占比<br><code>colsample_bylevel</code> 每层训练使用的特征占比<br><code>reg_alpha</code> L1正则<br><code>reg_lambda</code> L2正则<br><code>scale_pos_weight</code> 用于控制正例和负例均衡的权重<br><code>base_score</code> 初始时各个样本的得分</p><p><strong>5. 数据拟合和预测</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xgboost.fit(X, y, sample_weight=<span class="keyword">None</span>, eval_set=<span class="keyword">None</span>, eval_metric=<span class="keyword">None</span>, early_stopping_rounds=<span class="keyword">None</span>, verbose=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># sample_weight：每个训练样本的权重</span></span><br><span class="line"><span class="comment"># eval_set：设置验证集</span></span><br><span class="line"><span class="comment"># eval_metric：验证的度量指标</span></span><br><span class="line"><span class="comment"># early_stopping_rounds` 指定连续多少轮未改善后停止</span></span><br><span class="line"></span><br><span class="line">xgboost.predict(data, output_margin=<span class="keyword">False</span>, ntree_limit=<span class="number">0</span>, pred_leaf=<span class="keyword">False</span>, pred_contribs=<span class="keyword">False</span>, approx_contribs=Flase, pred_interactions=<span class="keyword">False</span>, validate_features=Flase)`</span><br><span class="line"></span><br><span class="line"><span class="comment"># output_margin 是否输出原始未经转化的值</span></span><br><span class="line"><span class="comment"># ntree_limit 用于预测的树的数量，默认为0，代表使用所有树进行预测</span></span><br><span class="line"><span class="comment"># pred_leaf 指明每条数据分别落到每棵树的哪个叶子节点上</span></span><br><span class="line"><span class="comment"># pred_contribs 指明每个样本的每个特征对预测结果的贡献值</span></span><br><span class="line"><span class="comment"># approx_contribs 是否启用特征贡献大小的预估功能</span></span><br><span class="line"><span class="comment"># pred_interactions 指明两两特征间相互影响的SHAP值</span></span><br><span class="line"><span class="comment"># validate_features首先验证待预测的数据特征名称是否与模型中的特征名称相同，默认情况下，系统认为他们是相同的，不进行验证</span></span><br></pre></td></tr></table></figure><ul><li><code>class xgboost.XGBRegressor()</code>用于回归任务</li></ul><h3 id="XgBoost示例"><a href="#XgBoost示例" class="headerlink" title="XgBoost示例"></a>XgBoost示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"></span><br><span class="line">train_data = pd.read_csv(<span class="string">'train.csv'</span>)   <span class="comment"># 读取数据</span></span><br><span class="line">y = train_data.pop(<span class="string">'30'</span>).values   <span class="comment"># 用pop方式将训练数据中的标签值y取出来，作为训练目标，这里的‘30’是标签的列名</span></span><br><span class="line">col = train_data.columns</span><br><span class="line">x = train_data[col].values  <span class="comment"># 剩下的列作为训练数据</span></span><br><span class="line">train_x, valid_x, train_y, valid_y = train_test_split(x, y, test_size=<span class="number">0.333</span>, random_state=<span class="number">0</span>)   <span class="comment"># 分训练集和验证集</span></span><br><span class="line"><span class="comment"># 这里不需要Dmatrix</span></span><br><span class="line"></span><br><span class="line">parameters = &#123;</span><br><span class="line">              <span class="string">'max_depth'</span>: [<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>],</span><br><span class="line">              <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.15</span>],</span><br><span class="line">              <span class="string">'n_estimators'</span>: [<span class="number">500</span>, <span class="number">1000</span>, <span class="number">2000</span>, <span class="number">3000</span>, <span class="number">5000</span>],</span><br><span class="line">              <span class="string">'min_child_weight'</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">              <span class="string">'max_delta_step'</span>: [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              <span class="string">'subsample'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.85</span>, <span class="number">0.95</span>],</span><br><span class="line">              <span class="string">'colsample_bytree'</span>: [<span class="number">0.5</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>],</span><br><span class="line">              <span class="string">'reg_alpha'</span>: [<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],</span><br><span class="line">              <span class="string">'reg_lambda'</span>: [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>],</span><br><span class="line">              <span class="string">'scale_pos_weight'</span>: [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">xlf = xgb.XGBClassifier(max_depth=<span class="number">10</span>,</span><br><span class="line">            learning_rate=<span class="number">0.01</span>,</span><br><span class="line">            n_estimators=<span class="number">2000</span>,</span><br><span class="line">            silent=<span class="keyword">True</span>,</span><br><span class="line">            objective=<span class="string">'binary:logistic'</span>,</span><br><span class="line">            nthread=<span class="number">-1</span>,</span><br><span class="line">            gamma=<span class="number">0</span>,</span><br><span class="line">            min_child_weight=<span class="number">1</span>,</span><br><span class="line">            max_delta_step=<span class="number">0</span>,</span><br><span class="line">            subsample=<span class="number">0.85</span>,</span><br><span class="line">            colsample_bytree=<span class="number">0.7</span>,</span><br><span class="line">            colsample_bylevel=<span class="number">1</span>,</span><br><span class="line">            reg_alpha=<span class="number">0</span>,</span><br><span class="line">            reg_lambda=<span class="number">1</span>,</span><br><span class="line">            scale_pos_weight=<span class="number">1</span>,</span><br><span class="line">            seed=<span class="number">1440</span>,</span><br><span class="line">            missing=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有了gridsearch我们便不需要fit函数</span></span><br><span class="line">gsearch = GridSearchCV(xlf, param_grid=parameters, scoring=<span class="string">'accuracy'</span>, cv=<span class="number">3</span>)</span><br><span class="line">gsearch.fit(train_x, train_y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Best score: %0.3f"</span> % gsearch.best_score_)</span><br><span class="line">print(<span class="string">"Best parameters set:"</span>)</span><br><span class="line">best_parameters = gsearch.best_estimator_.get_params()</span><br><span class="line"><span class="keyword">for</span> param_name <span class="keyword">in</span> sorted(parameters.keys()):</span><br><span class="line">    print(<span class="string">"\t%s: %r"</span> % (param_name, best_parameters[param_name]))</span><br></pre></td></tr></table></figure><h2 id="LightGBM"><a href="#LightGBM" class="headerlink" title="LightGBM"></a>LightGBM</h2><h3 id="paramenter-常用参数"><a href="#paramenter-常用参数" class="headerlink" title="paramenter 常用参数"></a>paramenter 常用参数</h3><p><strong>objective</strong>:<br>‘regression’,’regression_l2’,’mean_squared_error’,’mse’,’l2_root’,’root_mean_squred_error’,’rmse’： 表示回归任务，但是使用L2 损失函数。默认为’regression’<br>‘binary’： 表示二分类任务，使用对数损失函数作为目标函数。<br>‘multiclass’： 表示多分类任务，使用softmax 函数作为目标函数。必须设置num_class 参数<br>‘multiclassova’,’multiclass_ova’,’ova’,’ovr’： 表示多分类任务，使用one-vs-all 的二分类目标函数。必须设置num_class 参数<br>‘regression_l1’,’mae’,’mean_absolute_error’： 表示回归任务，但是使用L1 损失函数。<br>‘huber’： 表示回归任务，但是使用huber 损失函数。<br>‘fair’： 表示回归任务，但是使用fair 损失函数。<br>‘poisson’： 表示Poisson 回归任务。<br>‘quantile’： 表示quantile回归任务。<br>‘quantile_l2’：表示quantile回归任务，但是使用了L2 损失函数。<br>‘mape’,’mean_absolute_precentage_error’： 表示回归任务，但是使用MAPE 损失函数<br>‘gamma’： 表示gamma 回归任务。<br>‘tweedie’： 表示tweedie 回归任务。<br>‘xentropy’,’cross_entropy’： 目标函数为交叉熵（同时具有可选择的线性权重）。要求标签是[0,1] 之间的数值。<br>‘xentlambda’,’cross_entropy_lambda’： 替代了参数化的cross_entropy 。要求标签是[0,1] 之间的数值。<br>‘lambdarank’：表示排序任务。</p><p><strong>boosting_type</strong>: // 基学习器模型算法<br>‘gbdt’： 表示传统的梯度提升决策树。默认值为’gbdt’<br>‘rf’： 表示随机森林。<br>‘dart’： 表示带dropout 的gbdt<br>‘goss’：表示Gradient-based One-Side Sampling 的gbdt</p><p><strong>metric</strong>：//指定度量的指标<br>‘l1’ 或者 mean_absolute_error或者 mae或者 regression_l1： 表示绝对值损失<br>‘l2’ 或者mean_squared_error或者 mse或者 regression_l2或者 regression：表示平方损失<br>‘l2_root’ 或者root_mean_squared_error或者 rmse：表示开方损失<br>‘quantile’ 表示Quantile 回归中的损失<br>‘mape’ 或者 ‘mean_absolute_percentage_error’ 表示MAPE 损失<br>‘huber’ 表示huber 损失<br>‘fair’ 表示fair 损失<br>‘poisson’ 表示poisson 回归的负对数似然<br>‘gamma’ 表示gamma 回归的负对数似然<br>‘gamma_deviance’ 表示gamma 回归的残差的方差<br>‘tweedie’ 表示Tweedie 回归的负对数似然<br>‘ndcg’ 表示NDCG<br>‘map’ 或者’mean_average_precision’ 表示平均的精度<br>‘auc’ 表示AUC<br>‘binary_logloss’或者’binary’ 表示二类分类中的对数损失函数<br>‘binary_error’ 表示二类分类中的分类错误率<br>‘multi_logloss’或者 ‘multiclass’或者 ‘softmax’或者 ‘multiclassova’或者 ‘multiclass_ova’,或者’ova’或者 ‘ovr’ 表示多类分类中的对数损失函数<br>‘multi_error’ 表示多分类中的分类错误率<br>‘xentropy’或者’cross_entropy’ 表示交叉熵<br>‘xentlambda’ 或者’cross_entropy_lambda’ 表示intensity 加权的交叉熵<br>‘kldiv’或者’kullback_leibler’ 表示KL 散度</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>1. 数据结构类，提供数据的构建和处理</strong><br><code>lightgbm.Dataset(data, label=None, max_bin=None, reference=None, weight=None, group=None, init_score=None, silent=False, feature_name=&#39;auto&#39;, categorical_feature=&#39;auto&#39;, params=None, free_raw_data=True)</code></p><p><code>label</code> 指定数据的标签列<br><code>max_bin</code> 特征值最大分类数量<br><code>reference</code> 增加评估参照，评估模型时使用，reference=train<br><code>weight</code> 设置权重<br><code>group</code>  设置数据组的大小<br><code>init_score</code> 加入之前的分数<br><code>silent</code> 是否在训练过程中屏蔽输出<br><code>feature_name</code> 特征名字<br><code>categorical_feature</code>设置分类特征<br><code>free_raw_data</code> 创建完后释放数据</p><p><strong>2. 模型类，提供了一些基础的函数，如模型加载、保存、评估和预测等方法</strong><br><code>lightgbm.Booster(params=None, train_set=None, model_file=None, model_str=None, silent=False)</code><br><code>params</code> 一个字典或者None，给出了Booster 的参数。默认为None<br><code>train_set</code> 一个Dataset对象或者None，给出了训练集。 默认为None<br><code>model_file</code> 一个字符串或者None，给出了model file 的路径。 默认为None<br><code>silent</code> 一个布尔值，指示是否在构建过程中打印消息。默认为False</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lightgbm.add_valid(data,name) <span class="comment"># 添加一个验证集。</span></span><br><span class="line">lightgbm.current_iteration() <span class="comment"># 返回当前的迭代的index（即迭代的编号）</span></span><br><span class="line">lightgbm.dump_model(num_iteration=<span class="number">-1</span>) <span class="comment"># dump 当前的Booster 对象为json 格式。</span></span><br><span class="line">lightgbm.eval(data,name,feval=<span class="keyword">None</span>) <span class="comment"># 对指定的数据集evaluate</span></span><br><span class="line">lightgbm.eval_train(feval=<span class="keyword">None</span>) <span class="comment"># 对训练集进行evaluate</span></span><br><span class="line">lightgbm.eval_valid(feval=<span class="keyword">None</span>) <span class="comment"># 对验证集进行evaluate</span></span><br><span class="line">lightgbm.feature_importance(importance_type=<span class="string">'split'</span>, iteration=<span class="number">-1</span>) <span class="comment"># 获取特征的importance</span></span><br><span class="line">lightgbm.feature_name() <span class="comment"># 获取每个特征的名字。</span></span><br><span class="line">lightgbm.free_dataset() <span class="comment"># 释放Booster 对象的数据集</span></span><br><span class="line">lightgbm.free_network() <span class="comment"># 释放Booster 对象的Network</span></span><br><span class="line">lightgbm.get_leaf_output(tree_id, leaf_id) <span class="comment"># 获取指定叶子的输出</span></span><br><span class="line">lightgbm.num_feature() <span class="comment"># 获取特征的数量（即由多少列特征）</span></span><br><span class="line">lightgbm.reset_parameter(params) <span class="comment">#重设Booster 的参数。</span></span><br><span class="line">lightgbm.rollback_one_iter() <span class="comment"># 将Booster 回滚一个迭代步</span></span><br><span class="line">lightgbm.save_model(filename,num_iteration=<span class="number">-1</span>) <span class="comment"># 保存Booster 对象到文件中。</span></span><br><span class="line">lightgbm.set_attr(**kwargs) <span class="comment"># 设置Booster 的属性。</span></span><br><span class="line">lightgbm.set_network(machines,local_listen_port=<span class="number">12400</span>,listen_time_out=<span class="number">120</span>,num_machines=<span class="number">1</span>) <span class="comment"># 配置网络</span></span><br><span class="line">lightgbm.set_train_data_name(name) <span class="comment"># 设置训练集的名字</span></span><br><span class="line">lightgbm.update(train_set=<span class="keyword">None</span>, fobj=<span class="keyword">None</span>) <span class="comment"># 更新一个迭代步</span></span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><strong>1. <code>lightgbm.train()</code>执行训练</strong></p><p><code>lightgbm.train(params, train_set, num_boost_round=100, valid_sets=None, valid_names=None, fobj=None, feval=None, init_model=None, feature_name=&#39;auto&#39;, categorical_feature=&#39;auto&#39;, early_stopping_rounds=None, evals_result=None, verbose_eval=True, learning_rates=None, keep_training_booster=False, callbacks=None)</code></p><p><code>params</code> 相关参数配置，另外导入字典<br><code>train_set</code> 训练数据<br><code>num_boost_round</code> boost迭代次数<br><code>valid_sets</code>，<code>valid_names</code> 设置训练时用于评估的数据集 <em><br><code>fobj</code> 自定义目标函数 preds, train_data -&gt; grad,hess </em><br><code>feval</code> 自定义评估函数 preds, train_data -&gt; eval_name, eval_result, is_higher_better <em><br><code>init_model</code> 导入之前训练数据<br><code>feature_name</code> 指定特征名字，数据源为pandas DataFrame会使用里面的column_names<br><code>categorical_feature</code> 指定分类特征<br><code>early_stopping_rounds</code> 指定连续多少轮未改善后停止<br><code>evals_result</code> 指定字典存储valid_sets中验证的结果 </em><br><code>verbose_eval</code> 设置打印评估的间隔，可设置每个提升阶段打印或间隔<code>verbose_eval</code>个阶段打印<br><code>learning_rates</code> 设置学习率<br><code>keep_training_booster</code> 设置训练得到的booster是否继续训练<br><code>callbacks</code> 设置每次迭代后需要执行的函数</p><p>最后返回booster实例</p><p><strong>2. <code>lightgbm.cv()</code> 执行交叉检验</strong></p><p><code>lightgbm.cv(params, train_set, num_boost_round=10, folds=None, nfold=5, stratified=True, shuffle=True, metrics=None, fobj=None, feval=None, init_model=None, feature_name=&#39;auto&#39;,categorical_feature=&#39;auto&#39;, early_stopping_rounds=None, fpreproc=None, verbose_eval=None, show_stdv=True, seed=0, callbacks=None)</code></p><p><code>folds</code>：一个生成器、一个迭代器、或者None <em><br><code>nfold</code>：指定交叉检验的数量。默认为5<br><code>stratified</code>：指示是否进行分层拆分<br><code>shuffle</code>：指示是否在拆分之前先混洗数据<br><code>metrics</code>：指定评估度量标准，在params中设置<br><code>fpreproc</code>：设置预处理函数，在训练开始之前进行 </em><br><code>show_stdv</code>：在训练过程中展示标准差信息<br><code>seed</code>：一个整数，给出了生成fold 的随机数种子 *</p><p>最后以字典的形式返回检验结果的均值和标准差</p><h3 id="scikit-learn-API"><a href="#scikit-learn-API" class="headerlink" title="scikit-learn API"></a>scikit-learn API</h3><p><strong>1. LGBMMOdel</strong><br>实现lightgbm在scikir-learn中的接口，详见分类和回归任务</p><p><strong>2. LGBMClassifier: LGBMModel的子类，用于分类任务</strong></p><p><code>lightgbm.LGBMClassifier(boosting_type=&#39;gbdt&#39;, num_leaves=31, max_depth=-1, learning_rate=0.1, n_estimators=10, max_bin=255, ubsample_for_bin=200000, objective=None, min_split_gain=0.0, in_child_weight=0.001, min_child_samples=20, subsample=1.0, subsample_freq=1, colsample_bytree=1.0, reg_alpha=0.0, reg_lambda=0.0, random_state=None, n_jobs=-1, silent=True, **kwargs)</code></p><p><code>boosting_type</code>： 指定学习器的算法’gbdt, rf, dart, goss’<br><code>num_leaves</code>：一棵树上的叶子数<br><code>max_depth</code>：树模型的最大深度<br><code>learning_rate</code>：学习率<br><code>n_estimators</code>：提升树的数量<br><code>max_bin</code>： 每个特征的最大分支数量<br><code>class_weight</code>：给出了每个类别的权重占比<br><code>subsample_for_bin</code>：构建直方图的样本的数量 <em><br><code>objective</code>：问题类型以及对应的目标函数，对于LGBMRegressor 为’regression’；对于LGBMClassifier 为’binary’ 或者’multiclass’；对于LGBMRanker 为’lambdarank’<br><code>min_split_gain</code>：执行切分的最小增益<br><code>min_child_weight</code>：一个叶子节点上的最小权重之和，默认为1e-3<br><code>min_child_samples</code>： 一个叶子节点上包含的最少样本数量<br><code>subsample</code>： 表示训练样本的采样比例，取值范围为[0.0,1.0]。如果小于1.0，则lightgbm 会在每次迭代中随机选择部分样本来训练（非重复采样）<br><code>subsample_freq</code>：表示训练样本的采样频率<br><code>colsample_bytree</code>：表示特征的采样比例，取值范围为[0.0,1.0]。如果小于1.0，则lightgbm 会在每次迭代中随机选择部分特征<br><code>reg_alpha</code>：L1正则化系数<br><code>reg_lambda</code>：L2正则化系数<br><code>random_state</code>：随机数种子 </em><br><code>n_jobs</code>：并行线程数量<br><code>silent</code>：是否在训练过程中屏蔽输出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line">gbm = lgb.LGBMClassifier()</span><br><span class="line">gbm.n_features_：<span class="comment"># 给出了特征的数量</span></span><br><span class="line">gbm.classes_：<span class="comment"># 样本的标签</span></span><br><span class="line">gbm.n_classes_：<span class="comment"># 类别的数量</span></span><br><span class="line">gbm.best_score_：<span class="comment"># 训练完毕模型的最好的score</span></span><br><span class="line">gbm.best_iteration_：<span class="comment"># 训练完毕模型的最好的迭代数</span></span><br><span class="line">gbm.objective_：<span class="comment"># 训练模型的目标函数</span></span><br><span class="line">gbm.booster_：<span class="comment"># 底层的Booster 对象</span></span><br><span class="line">gbm.evals_result_：<span class="comment"># 模型评估结果</span></span><br><span class="line">gbm.feature_importances_： <span class="comment"># 特征的重要性</span></span><br></pre></td></tr></table></figure><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gbm.fit(X, y, sample_weight=<span class="keyword">None</span>, init_score=<span class="keyword">None</span>, eval_set=<span class="keyword">None</span>, eval_names=<span class="keyword">None</span>, eval_sample_weight=<span class="keyword">None</span>, eval_init_score=<span class="keyword">None</span>, eval_metric=<span class="string">'logloss'</span>, early_stopping_rounds=<span class="keyword">None</span>, verbose=<span class="keyword">True</span>, feature_name=<span class="string">'auto'</span>, categorical_feature=<span class="string">'auto'</span>, callbacks=<span class="keyword">None</span>)`</span><br><span class="line"><span class="comment"># sample_weight：每个训练样本的权重</span></span><br><span class="line"><span class="comment"># init_score：每个训练样本的初始分数</span></span><br><span class="line"><span class="comment"># group：每个训练样本的分组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eval_set：设置验证集</span></span><br><span class="line"><span class="comment"># eval_names：设置验证集的名字</span></span><br><span class="line"><span class="comment"># eval_sample_weight：验证集中每个样本的权重</span></span><br><span class="line"><span class="comment"># eval_init_score：每个验证集中，每个样本的init score</span></span><br><span class="line"><span class="comment"># eval_group：每个验证集中，每个样本的分组</span></span><br><span class="line"><span class="comment"># eval_metric：验证的方法</span></span><br><span class="line"></span><br><span class="line">gbm.predict(data, num_iteration=<span class="number">-1</span>, raw_score=<span class="keyword">False</span>, pred_leaf=<span class="keyword">False</span>, pred_contrib=<span class="keyword">False</span>, data_has_header=<span class="keyword">False</span>, is_reshape=<span class="keyword">True</span>, pred_parameter=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># num_iteration`：设置在预测时，使用多少个子树</span></span><br><span class="line"><span class="comment"># raw_score`：是否输出raw score</span></span><br><span class="line"><span class="comment"># pred_leaf： 输出每个样本在每个子树的哪个叶子上</span></span><br><span class="line"><span class="comment"># pred_contrib：输出每个特征对每个样本预测结果的贡献程度</span></span><br><span class="line"><span class="comment"># data_has_header：指示数据集是否含有标题</span></span><br><span class="line"><span class="comment"># is_reshape：是否reshape</span></span><br><span class="line"><span class="comment"># pred_parameter：给出其它的参数</span></span><br><span class="line"></span><br><span class="line">gbm.predict_proba(X, raw_score=<span class="keyword">False</span>, num_iteration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>LGBMRegressor 是LGBMModel 的子类，它用于回归任务</li><li>LGBMRanker 是LGBMModel 的子类，它用于排序任务，详见排序学习算法</li></ul><h3 id="绘图-API"><a href="#绘图-API" class="headerlink" title="绘图 API"></a>绘图 API</h3><h3 id="booster-API"><a href="#booster-API" class="headerlink" title="booster API"></a>booster API</h3><h3 id="LightGBM示例"><a href="#LightGBM示例" class="headerlink" title="LightGBM示例"></a>LightGBM示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> GridSearchCV  <span class="comment"># Perforing grid search</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">train_data = pd.read_csv(<span class="string">'train.csv'</span>)   <span class="comment"># 读取数据</span></span><br><span class="line">y = train_data.pop(<span class="string">'30'</span>).values   <span class="comment"># 用pop方式将训练数据中的标签值y取出来，作为训练目标，这里的‘30’是标签的列名</span></span><br><span class="line">col = train_data.columns</span><br><span class="line">x = train_data[col].values  <span class="comment"># 剩下的列作为训练数据</span></span><br><span class="line">train_x, valid_x, train_y, valid_y = train_test_split(x, y, test_size=<span class="number">0.333</span>, random_state=<span class="number">0</span>)   <span class="comment"># 分训练集和验证集</span></span><br><span class="line">train = lgb.Dataset(train_x, train_y)</span><br><span class="line">valid = lgb.Dataset(valid_x, valid_y, reference=train)</span><br><span class="line"></span><br><span class="line">parameters = &#123;</span><br><span class="line">              <span class="string">'max_depth'</span>: [<span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>],</span><br><span class="line">              <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.15</span>],</span><br><span class="line">              <span class="string">'feature_fraction'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>, <span class="number">0.95</span>],</span><br><span class="line">              <span class="string">'bagging_fraction'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>, <span class="number">0.95</span>],</span><br><span class="line">              <span class="string">'bagging_freq'</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>],</span><br><span class="line">              <span class="string">'reg_alpha'</span>: [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>],</span><br><span class="line">              <span class="string">'reg_lambda'</span>: [<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">40</span>],</span><br><span class="line">              <span class="string">'cat_smooth'</span>: [<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">35</span>]</span><br><span class="line">&#125;</span><br><span class="line">gbm = lgb.LGBMClassifier(boosting_type=<span class="string">'gbdt'</span>,</span><br><span class="line">                         objective = <span class="string">'binary'</span>,</span><br><span class="line">                         metric = <span class="string">'auc'</span>,</span><br><span class="line">                         verbose = <span class="number">0</span>,</span><br><span class="line">                         learning_rate = <span class="number">0.01</span>,</span><br><span class="line">                         num_leaves = <span class="number">35</span>,</span><br><span class="line">                         feature_fraction=<span class="number">0.8</span>,</span><br><span class="line">                         bagging_fraction= <span class="number">0.9</span>,</span><br><span class="line">                         bagging_freq= <span class="number">8</span>,</span><br><span class="line">                         reg_alpha= <span class="number">0.6</span>,</span><br><span class="line">                         reg_lambda= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">gsearch = GridSearchCV(gbm, param_grid=parameters, scoring=<span class="string">'accuracy'</span>, cv=<span class="number">3</span>)</span><br><span class="line">gsearch.fit(train_x, train_y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Best score: %0.3f"</span> % gsearch.best_score_)</span><br><span class="line">print(<span class="string">"Best parameters set:"</span>)</span><br><span class="line">best_parameters = gsearch.best_estimator_.get_params()</span><br><span class="line"><span class="keyword">for</span> param_name <span class="keyword">in</span> sorted(parameters.keys()):</span><br><span class="line">    print(<span class="string">"\t%s: %r"</span> % (param_name, best_parameters[param_name]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://xgboost.ai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XgBoost&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/Microsoft/LightGBM&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LightGBM&lt;/a&gt; 官方文档阅读和算法学习&lt;br&gt;&lt;code&gt;*&lt;/code&gt;号为未解释完全，具体使用方法请参考官方文档&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="boosting" scheme="https://hyqskevin.github.io/tags/boosting/"/>
    
  </entry>
  
  <entry>
    <title>scikit-learn 文档学习笔记(1)</title>
    <link href="https://hyqskevin.github.io/2019/07/30/scikit-learn-note/"/>
    <id>https://hyqskevin.github.io/2019/07/30/scikit-learn-note/</id>
    <published>2019-07-30T01:31:47.000Z</published>
    <updated>2019-08-02T01:45:50.325Z</updated>
    
    <content type="html"><![CDATA[<p><strong>—loading …—</strong><br>scikit-learn 基于 Python 语言,建立在 NumPy ，SciPy 和 matplotlib 上,是简单高效的数据挖掘和数据分析工具<br>文章记录 scikit-learn API的使用方法，包括监督学习、无监督学习，模型的选择和评估，数据集的加载和转换<br>学习笔记(1) 为监督学习的内容，解决回归和分类问题。包括线性回归，逻辑回归，梯度下降，最近邻，贝叶斯，决策树，支持向量机，集成方法，半监督学习等<br>API只给出函数结构，参数具体使用参考<a href="https://scikit-learn.org/stable/user_guide.html" target="_blank" rel="noopener">scikit-learn官方文档</a><br><a id="more"></a></p><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h3><p>目标值 y 是输入变量 x 的线性组合 $y(w,x) = w_0 +w_1x_1 + … + w_px_p$ 其中w为系数(coef) $w_0$ 为截距(intercept)。</p><p><strong>1. 普通最小二乘法 LinearRegression</strong><br>拟合一个带有系数 $w = (w_1, …, w_p)$ 的线性模型，使得数据集实际观测数据和预测数据（估计值）之间的残差平方和最小。<br>$\underset{w}{min\,} {|| X w - y||_2}^2$</p><p><code>sklearn.linear_model.LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=None)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">reg = LinearRegression().fit(X,y) <span class="comment"># 模型拟合</span></span><br><span class="line">reg.cof_  <span class="comment"># 得到系数矩阵</span></span><br><span class="line">reg.intercept_ <span class="comment"># 得到截距矩阵</span></span><br><span class="line">reg.score(X,y) <span class="comment"># 误差</span></span><br><span class="line">reg.predict(X) <span class="comment"># 预测</span></span><br></pre></td></tr></table></figure><p><strong>2. 岭回归 Ridge</strong><br>回归通过对系数的大小<strong>施加惩罚</strong>来解决普通最小二乘法的一些问题。 岭系数最小化的是带罚项的残差平方和。<br>$\underset{w}{min\,} {||X w - y||_2^2 + \alpha ||w||_2^2}$，其中$\alpha \geq 0$ 是控制系数收缩量的复杂性参数(超参数)</p><p><code>sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True, normalize=False, copy_X=True, max_iter=None, tol=0.001, solver=’auto’, random_state=None)</code></p><p>// alpha 可以设超参数大小<br>// tol 设置迭代最小边界<br>// solver : {‘auto’, ‘svd’, ‘cholesky’, ‘lsqr’, ‘sparse_cg’, ‘sag’, ‘saga’} 设置求解器，拟合数据时使用的算法</p><ul><li><code>sklearn.linear_model.RidgeCV( )</code> 内置对$\alpha$的交叉验证实现岭回归</li></ul><p><strong>3. 套索回归 Lasso</strong><br>用于拟合<strong>稀疏系数</strong>的线性模型，使用了 coordinate descent （坐标下降算法）来拟合系数，罚项 为L1 范数。<br>$\underset{w}{min\,} { \frac{1}{2n_{samples}} ||X w - y||_2 ^ 2 + \alpha ||w||_1}$</p><p><code>sklearn.linear_model.Lasso(alpha=1.0, fit_intercept=True, normalize=False, precompute=False, copy_X=True, max_iter=1000, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’)</code></p><ul><li><code>sklearn.linear_model.LassoCV()</code> // 对超参数$\alpha$采用交叉验证</li><li><code>sklearn.linear_model.LassoLars()</code> // 采用的是最小角回归法，而不是坐标下降法进行优化</li><li><code>sklearn.linear_model.LassoLarsCV()</code> //同时采用不同的验证和优化方法</li><li><p><code>sklearn.linear_model.LassoLarsIC()</code> //对超参数$\alpha$采用 Akaike 信息准则(AIC)和贝叶斯信息准则(BIC),需要假设模型是正确的，对大样本（渐近结果）进行导出</p></li><li><p>LassoLarsCV 在寻找 $\alpha$ 参数值上更具有优势，而且如果样本数量比特征数量少得多时，通常 LassoLarsCV 比 LassoCV 要快</p></li></ul><p><strong>4. 弹性网络 ElasticNet</strong><br>Lasso和Ridge结合，对普通的线性回归做了正则化，但是它的损失函数既不全是L1的正则化，也不全是L2的正则化，而是用一个权重参数ρ来平衡L1和L2正则化的比重<br>适合只有少量参数是非零稀疏的模型<br>$\underset{w}{min\,} { \frac{1}{2n_{samples}} ||X w - y||_2 ^ 2 + \alpha \rho ||w||_1 +\frac{\alpha(1-\rho)}{2} ||w||_2 ^ 2}$</p><p><code>sklearn.linear_model.ElasticNet(alpha=1.0, l1_ratio=0.5, fit_intercept=True, normalize=False, precompute=False, max_iter=1000, copy_X=True, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’)</code></p><ul><li><code>ElasticNetCV()</code> 可以通过交叉验证来设置参数 $\alpha$ 和 $\rho$</li></ul><p><strong>5. Multitask 多任务</strong><br>可以实现多元回归稀疏模型的预测，即多个线性模型共同拟合<br>有<code>MultiTaskLasso()</code>,<code>MultiTaskLassoCV()</code>,<code>MultiTaskElasticNet()</code>,<code>MultiTaskElasticNetCV()</code></p><p><strong>6. 正交匹配追踪法（OMP）</strong><br><code>OrthogonalMatchingPursuit( )</code><br><code>OrthogonalMatchingPursuitCV( )</code></p><p><strong>7. 贝叶斯回归</strong></p><p><strong>8. 稳健回归</strong></p><p><strong>9. 多项式回归</strong></p><h3 id="logistic-线性分类模型"><a href="#logistic-线性分类模型" class="headerlink" title="logistic 线性分类模型"></a>logistic 线性分类模型</h3><p>解决分类问题的线性模型，将单次实验的结果输出为概率进行分类<br>$C \sum_{i=1}^n \log(\exp(- y_i (X_i^T w + c)) + 1) $<br>可以选择L1，L2或Elastic-Net正则化进行约束</p><p><code>sklearn.linear_model.LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=’warn’, max_iter=100, multi_class=’warn’, verbose=0, warm_start=False, n_jobs=None, l1_ratio=None)</code><br>// penalty 参数可以设置正则化参数<br>// C 用$1/{\lambda}$表示的正则化强度参数<br>// solver : str, {‘newton-cg’, ‘lbfgs’, ‘liblinear’, ‘sag’, ‘saga’} 选择优化算法，详细使用说明见官方文档<br>// class_weight 可以设置各类型的权重<br>// l1_ration 设置Elastic-Net中ρ控制正则化L1与正则化L2的强度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">reg = LogisticRegression().fit(X,y) <span class="comment"># 模型拟合</span></span><br><span class="line">reg.cof_  <span class="comment"># 得到系数矩阵</span></span><br><span class="line">reg.intercept_ <span class="comment"># 得到截距矩阵</span></span><br><span class="line">reg.score(X,y) <span class="comment"># 误差</span></span><br><span class="line">reg.predict(X) <span class="comment"># 得到预测的分类矩阵</span></span><br><span class="line">reg.predict_proba(X) <span class="comment"># 得到预测的概率</span></span><br></pre></td></tr></table></figure><ul><li><code>LogisticRegressionCV( )</code> 实现了内置交叉验证，可以找出最优的C和l1_ratio参数</li></ul><h3 id="SGD-随机梯度下降"><a href="#SGD-随机梯度下降" class="headerlink" title="SGD 随机梯度下降"></a>SGD 随机梯度下降</h3><p>可以拟合线性的回归和分类模型，在样本量很大时尤为有用，选择和函数时要避免过拟合。<br><code>SGDClassifier()</code> 和 <code>SGDRegressor()</code> 分别用于拟合分类问题和回归问题的线性模型，可使用不同的（凸）损失函数，支持不同的惩罚项。</p><h3 id="最近邻"><a href="#最近邻" class="headerlink" title="最近邻"></a>最近邻</h3><p>能够应用于决策边界非常不规则的分类情景</p><p>NearestNeighbors<br>BallTree<br>KDTree</p><p>最近邻分类属于<strong>基于实例的学习</strong>或<strong>非泛化学习</strong>：它不会去构造一个泛化的内部模型，而是简单地存储训练数据的实例。</p><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>决策树便于理解和解释，能够处理数值型数据和分类数据；但是容易产生一个过于复杂的模型，泛化性能会很差，结果不稳定，可以通过决策树的集成来得到缓解。如果某些类在问题中占主导地位会使得创建的决策树有偏差，建议在拟合前先对数据集进行平衡。</p><p>分类标准为最小化交叉熵（ID3），熵增益（C4.5）或基尼系数（Cart）</p><p><code>sklearn.tree.DecisionTreeClassifier(criterion=’gini’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, class_weight=None, presort=False)</code><br>// criterion 选择分类标准，可以使用”gini”或者”entropy”<br>// splitter 设置特征划分标准<br>// max_feature 划分的最大特征数<br>// max_depth 选择树的最大深度<br>// min_sample_split 设置最小样本分类<br>// min_sample_leaf 设置最小样本叶子数<br>// max_leaf_nodes 最大叶子节点数<br>// class_weight 设置类别权重<br>// presort 设置数据预排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">clf = DecisionTreeClassifier().fit(X,y)</span><br><span class="line">clf.n_class_ <span class="comment"># 分类数量</span></span><br><span class="line">clf.n_features_ <span class="comment"># 特征数量</span></span><br><span class="line">clf.n_outputs_ <span class="comment"># 输出数量</span></span><br><span class="line">clf.tree_ <span class="comment"># 得到分类树</span></span><br><span class="line">clf.get_depth() <span class="comment"># 得到分类深度</span></span><br><span class="line">clf.get_n_leaves() <span class="comment"># 得到叶子节点数</span></span><br><span class="line">clf.predict(X) <span class="comment"># 返回预测矩阵</span></span><br><span class="line">clf.predict_proba(X) <span class="comment"># 返回预测的概率</span></span><br><span class="line">clf.score(X,y) <span class="comment"># 返回训练分数</span></span><br></pre></td></tr></table></figure><ul><li><p>决策树回归模型 <code>sklearn.tree.DecisionTreeRegressor()</code> （不常用）</p></li><li><p>可以使用 export_graphviz 导出器以 Graphviz 格式导出决策树,结果保存为pdf；Jupyter notebook也可以自动内联式渲染这些绘制节点</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line">dot_data = tree.export_graphviz(clf, out_file=<span class="keyword">None</span>,\</span><br><span class="line">                    feature_names=iris.feature_names,\  </span><br><span class="line">                    class_names=iris.target_names,  \</span><br><span class="line">                    filled=<span class="keyword">True</span>, rounded=<span class="keyword">True</span>,  \</span><br><span class="line">                    special_characters=<span class="keyword">True</span>)  </span><br><span class="line">graph = graphviz.Source(dot_data)</span><br><span class="line">graph.render(<span class="string">"classification_result"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show in Jupyter</span></span><br><span class="line">graph</span><br></pre></td></tr></table></figure><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>可用于分类，回归和异常检测，在高维空间中非常高效，<br>SVC, NuSVC 和 LinearSV</p><p>内核岭回归<br>核函数</p><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p>GaussianNB<br>MultinomialNB<br>ComplementNB<br>BernoulliNB</p><h3 id="集成方法"><a href="#集成方法" class="headerlink" title="集成方法"></a>集成方法</h3><p><strong>1. Bagging</strong><br>在原始训练集的随机子集上构建一类黑盒估计器的多个实例，然后把这些估计器的预测结果结合起来形成最终的预测结果，在构建模型的过程中引入随机性，来减少基估计器的方差。</p><p><code>sklearn.ensemble.BaggingClassifier(base_estimator=None, n_estimators=10, max_samples=1.0, max_features=1.0, bootstrap=True, bootstrap_features=False, oob_score=False, warm_start=False, n_jobs=None, random_state=None, verbose=0)</code><br>// base_estimator 设置分类估计器，默认为决策树，可设置其它分类模型<br>// n_estimators 设置估计器的数量<br>// bootstrap 设置样例抽取是否放回<br>// bootstrap_features 设置特征抽取是否有放回<br>// oob_score 设置是否用额外的样本来评估泛化精度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line">clf = BaggingClassifier().fit(X,y)</span><br><span class="line">clf.predict(X)</span><br><span class="line">predict_proba(X)</span><br><span class="line">score(X, y)</span><br></pre></td></tr></table></figure><p><strong>2. 随机森林</strong><br>随机森林中的每棵树构建时的样本都是由训练集经过有放回抽样得到。在构建树的过程中进行结点分割时，选择的分割点不再是所有特征中最佳分割点，而是特征的一个随机子集中的最佳分割点，偏差通常会有略微的增大；但由于取了平均，总体上模型的泛化能力会更好。</p><p><code>sklearn.ensemble.RandomForestClassifier(n_estimators=’warn’, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False, class_weight=None)</code><br>// n_estimators 调整森林里树的数量<br>// max_features 分割节点时考虑的特征的随机子集的大小。使用 max_features = sqrt(n_features)是比较好的默认值<br>// max_depth = None 和 min_samples_split = 2 结合可以生成完全树</p><ul><li>极限随机树 <code>ExtraTreesClassifier()</code></li><li>完全随机树构成森林 <code>RandomTreesEmbedding()</code></li></ul><p><strong>2. 梯度提升回归树(GBRT)</strong><br>GBRT保证迭代的每一个阶段中选择损失最小的决策树，达到全局的最小损失<br>$F<em>m(x) = F</em>{m-1}(x) + \arg\min<em>{h} \sum</em>{i=1}^{n} L(y<em>i,F</em>{m-1}(x_i) - h(x))$<br>GBRT具有强大的预测能力和鲁棒性，但是扩展性不够好</p><p><code>GradientBoostingClassifier(loss=’deviance’, learning_rate=0.1, n_estimators=100, subsample=1.0, criterion=’friedman_mse’, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_depth=3, min_impurity_decrease=0.0, min_impurity_split=None, init=None, random_state=None, max_features=None, verbose=0, max_leaf_nodes=None, warm_start=False, presort=’auto’, validation_fraction=0.1, n_iter_no_change=None, tol=0.0001)</code><br>// loss 设置损失函数，默认为deviance（$-log_2$ 似然损失函数）<br>// learning_rate 设置学习步长<br>// subsample 设置每次子训练集的采样，1为全采样，一般可设置为0.5</p><p><strong>3. AdaBoost</strong><br>通过反复修改数据权重来训练一些弱学习器，由这些弱学习器的预测结果通过加权投票(或加权求和)的方式组合, 得到最终的预测结果。<br>$F<em>m(x) = F</em>{m-1}(x) + \gamma<em>m \sum</em>{i=1}^{n} \nabla<em>F L(y_i, F</em>{m-1}(x<em>i))$<br>$\gamma_m$代表学习步长，通过计算损失最小的梯度下降$\gamma_m = \arg\min</em>{\gamma} \sum<em>{i=1}^{n} L(y_i, F</em>{m-1}(x<em>i) - \gamma \frac{\partial L(y_i, F</em>{m-1}(x<em>i))}{\partial F</em>{m-1}(x_i)})$得出</p><p>初始化时，将所有弱学习器的权重都设置为 $w_i = 1/N$ ,接下来的连续迭代中，样本的权重逐个地被修改。上一轮迭代中被预测为错误结果的样本的权重将会被增加，而那些被预测为正确结果的样本的权重将会被降低。通过不断得到最快梯度下降的权重来减小损失函数。</p><p><code>sklearn.ensemble.AdaBoostClassifier(base_estimator=None, n_estimators=50, learning_rate=1.0, algorithm=’SAMME.R’, random_state=None)</code><br>// base_estimator 设置弱学习器，默认DecisionTreeClassifier(max_depth=1)<br>// n_estimator 设置最大集成数量<br>// learning_rate 设置学习速率</p><p><strong>4. 投票分类器</strong></p><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><ul><li>最小角回归（LARS）：逐步寻找与响应最有关联的预测。当有很多预测有相同的关联时，它并不会继续利用相同的预测，而是在这些预测中找出应该等角的方向。高效但对噪声敏感。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;—loading …—&lt;/strong&gt;&lt;br&gt;scikit-learn 基于 Python 语言,建立在 NumPy ，SciPy 和 matplotlib 上,是简单高效的数据挖掘和数据分析工具&lt;br&gt;文章记录 scikit-learn API的使用方法，包括监督学习、无监督学习，模型的选择和评估，数据集的加载和转换&lt;br&gt;学习笔记(1) 为监督学习的内容，解决回归和分类问题。包括线性回归，逻辑回归，梯度下降，最近邻，贝叶斯，决策树，支持向量机，集成方法，半监督学习等&lt;br&gt;API只给出函数结构，参数具体使用参考&lt;a href=&quot;https://scikit-learn.org/stable/user_guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scikit-learn官方文档&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="python" scheme="https://hyqskevin.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Flask Web 学习笔记2 -- URL与视图函数映射</title>
    <link href="https://hyqskevin.github.io/2019/04/11/flask-learning2/"/>
    <id>https://hyqskevin.github.io/2019/04/11/flask-learning2/</id>
    <published>2019-04-11T08:28:44.000Z</published>
    <updated>2019-04-12T02:08:31.609Z</updated>
    
    <content type="html"><![CDATA[<p>-学习笔记-<br>通过URL传递参数，接收参数，利用试图函数实现参数到URL转换，自定义URL转换<br><a id="more"></a></p><p>URL是Uniform Resource Locator的简写，统一资源定位符。<br>一个URL由以下几部分组成：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">scheme://host:port/path/?query-string=xxx#anchor</span><br></pre></td></tr></table></figure><ul><li>scheme：代表的是访问的协议，一般为http或者https以及ftp等。</li><li>host：主机名，域名，比如www.baidu.com。</li><li>port：端口号。当你访问一个网站的时候，浏览器默认使用80端口。</li><li>path：查找路径。比如：www.jianshu.com/trending/now，后面的trending/now就是path。</li><li>query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。</li><li>anchor：锚点，后台一般不用管，前端用来做页面定位的。</li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>传递参数的语法是：<code>/&lt;参数名&gt;/</code>。然后在视图函数中，也要定义同名的参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="meta">@app.route('/list/')</span></span><br><span class="line"><span class="meta">@app.route('/p/&lt;float:article_id&gt;')</span></span><br><span class="line"><span class="meta">@app.route('/u/&lt;uuid:user_id&gt;/')</span></span><br><span class="line"><span class="meta">@app.route('/&lt;any(blog,article):url_path&gt;/&lt;id&gt;/')</span></span><br></pre></td></tr></table></figure><p>参数的数据类型</p><ol><li>如果没有指定具体的数据类型，那么默认就是使用<code>string</code>数据类型。</li><li><code>int</code>数据类型只能传递<code>int</code>类型。</li><li><code>float</code>数据类型只能传递<code>float</code>类型。</li><li><code>path</code>数据类型和<code>string</code>有点类似，都是可以接收任意的字符串，但是<code>path</code>可以接收路径，也就是说可以包含斜杠。</li><li><code>uuid</code>数据类型只能接收符合<code>uuid</code>的字符串。<code>uuid</code>是一个全宇宙都唯一的字符串，一般可以用来作为表的主键。</li><li><code>any</code>数据类型可以在一个<code>url</code>中指定多个路径。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/&lt;any(blog,article):url_path&gt;/&lt;id&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(url_path,id)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> url_path == <span class="string">'blog'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'博客详情：%s'</span> % id</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'博客详情：%s'</span> % id</span><br></pre></td></tr></table></figure><h3 id="接收用户传递的参数"><a href="#接收用户传递的参数" class="headerlink" title="接收用户传递的参数"></a>接收用户传递的参数</h3><ol><li>第一种：使用<code>path</code>的形式（将参数嵌入到路径中），就是上面讲的。</li><li>第二种：使用查询字符串的方式，就是通过<code>?key=value</code>的形式传递的。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/d/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">()</span>:</span></span><br><span class="line">    wd = request.args.get(<span class="string">'wd'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'参数是：%s'</span> % wd</span><br></pre></td></tr></table></figure><h3 id="URL转换器"><a href="#URL转换器" class="headerlink" title="URL转换器"></a>URL转换器</h3><p><code>url_for</code>将<strong>视图函数</strong>名字后面的参数传递给<code>url</code>。<br>如果传递的参数之前在<code>url</code>中已经定义了，那么这个参数就会被当成<code>path</code>的形式给<code>url</code>。如果这个参数之前没有在<code>url</code>中定义，那么将变成查询字符串的形式放到<code>url</code>中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,request</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/list/&lt;page&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_list</span><span class="params">(page)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'my list'</span></span><br><span class="line"></span><br><span class="line">print(url_for(<span class="string">'my_list'</span>,page=<span class="number">1</span>,count=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># page作为path，count作为查询字符串</span></span><br><span class="line"><span class="comment"># 构建出来的url：/my_list/1/?count=2</span></span><br></pre></td></tr></table></figure><ul><li>url_for优势</li></ul><ol><li>将来如果修改了<code>URL</code>，但没有修改该URL对应的函数名，就不用到处去替换URL了</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/post/list/&lt;page&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_list</span><span class="params">(page)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'my list'</span></span><br><span class="line">url = url_for(<span class="string">'my_list'</span>，page=<span class="number">1</span>,count=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 原来的url：/my_list/1/?count=2</span></span><br><span class="line"><span class="comment"># 新构建出来的url：/post/my_list/1/?count=2</span></span><br></pre></td></tr></table></figure><ol><li>url_for会自动的处理那些特殊的字符，不需要手动去处理。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/login/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'login'</span></span><br><span class="line"></span><br><span class="line">url = url_for(<span class="string">'login'</span>,next=<span class="string">'/'</span>)</span><br><span class="line"><span class="comment"># 会自动的将`/`编码，不需要手动去处理。</span></span><br><span class="line"><span class="comment"># url=/login/?next=%2F</span></span><br></pre></td></tr></table></figure><h3 id="自定义URL转换器"><a href="#自定义URL转换器" class="headerlink" title="自定义URL转换器"></a>自定义URL转换器</h3><p>URL参数的数据类型通过<code>routing.py</code>中的<code>Unicode/Float/Any/Path/Number Converter</code>等类指定，使用了默认转换器</p><p>可以自定义类型URL转换器和运算符URL转换器</p><ul><li>自定义方法</li></ul><ol><li>实现一个类，继承自<code>BaseConverter</code>。</li><li>在自定义的类中，重写<code>regex</code>，也就是这个变量的正则表达式。</li><li>将自定义的类，映射到<code>app.url_map.converters</code>上。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for</span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> BaseConverter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义手机号码的变量URL转换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneConveter</span><span class="params">(BaseConverter)</span>:</span></span><br><span class="line">  regex = <span class="string">r'1[85734]\d'</span></span><br><span class="line">app.url_map.converters[<span class="string">'tel'</span>] = TelephoneConverter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的数据类型</span></span><br><span class="line"><span class="meta">@app.route('/telephone/&lt;tel:my_tel&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_tel</span><span class="params">(my_tel)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'您的手机号码是：%s'</span> % my_tel</span><br><span class="line"></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义+号运算符解析</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpratorConverter</span><span class="params">(BaseConverter)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 这个方法的返回值，将会传递到view函数中作为参数</span></span><br><span class="line">    <span class="keyword">return</span> value.split(<span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 在调用url_for函数的时候生成符合要求的URL形式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"+"</span>.join(value)</span><br><span class="line">    <span class="comment"># return "hello"</span></span><br><span class="line">app.url_map.converters[<span class="string">'oprator+'</span>] = OpratorConverter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义+</span></span><br><span class="line"><span class="meta">@app.route('/posts/&lt;oprator+:boards&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">posts</span><span class="params">(boards)</span>:</span></span><br><span class="line">    print(boards)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"您提交的板块是：%s"</span> % boards</span><br></pre></td></tr></table></figure><h3 id="URL重定向"><a href="#URL重定向" class="headerlink" title="URL重定向"></a>URL重定向</h3><p>重定向在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面。比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面。</p><ol><li>永久性重定向：<code>http</code>的状态码是<code>301</code>，多用于旧网址被废弃了要转到一个新的网址确保用户的访问。</li><li>暂时性重定向：<code>http</code>的状态码是<code>302</code>，表示页面的暂时性跳转。比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面，这种情况下，应该用暂时性重定向。</li></ol><p><code>flask</code>中有一个函数叫做<code>redirect</code>，可以重定向到指定的页面。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request,redirect,url_for</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/login/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'这是登录页面'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/profile/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">'name'</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'个人中心页面'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># redirect 重定向</span></span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'login'</span>))</span><br></pre></td></tr></table></figure><h3 id="视图函数的响应"><a href="#视图函数的响应" class="headerlink" title="视图函数的响应"></a>视图函数的响应</h3><ol><li>可以返回字符串：flask会创建werkzeug、wrappers、Response对象，状态码200，MIME类型<code>test/html</code>，然后返回Response对象</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Response</span><br><span class="line">...</span><br><span class="line"><span class="meta">@app.route('/list/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">()</span>:</span></span><br><span class="line">    Response(<span class="string">'Hello World!'</span>)</span><br><span class="line"><span class="comment"># Response('Hello World!',status=200,mimetype='text/html')</span></span><br></pre></td></tr></table></figure><p>还可以通过make_response进行创建</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">form flask <span class="keyword">import</span> make_response</span><br><span class="line"><span class="meta">@app.route('/list/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> make_response(<span class="string">'list page.'</span>)</span><br></pre></td></tr></table></figure><ol><li>可以返回元组：元组的形式是(Response,Status,header)<br>不一定三个都要写，写两个也是可以的，status返回200，header为列表或字典。返回的元组，其实在底层也是包装成了一个<code>Response</code>对象。<br><code>return &#39;list&#39;,200,{&#39;NAME&#39;:&#39;kevin&#39;}</code></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.errorheader(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_found</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'not found'</span>,<span class="number">404</span></span><br></pre></td></tr></table></figure><ol><li>直接返回合法的响应对象</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp = Response(<span class="string">'list'</span>)</span><br><span class="line">resp.set_cookie(<span class="string">'country'</span>,<span class="string">'china'</span>)</span><br><span class="line"><span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><ol><li>以上条件不满足，则进行自定义响应</li></ol><p>继承自<code>Response</code>类。<br>实现方法<code>force_type(cls,response,environ=None)</code>。<br>指定<code>app.response_class</code>为你自定义的<code>Response</code>对象。<br>如果视图函数返回的数据，不是字符串，也不是元组，也不是Response对象，那么就会将返回值传给<code>force_type</code>，然后再将<code>force_type</code>的返回值返回给前端。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myResponse</span><span class="params">(Response)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">force_type</span><span class="params">(cls, response, environ=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'return error.'</span>)</span><br><span class="line"></span><br><span class="line">app.response_class = myResponse</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用jsonify将返回的格式转换成json格式</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myResponse</span><span class="params">(Response)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">force_type</span><span class="params">(cls, response, environ=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(response,dict):</span><br><span class="line">        <span class="comment"># jsonify除了将字典转换成json对象，还将改对象包装成了一个Response对象</span></span><br><span class="line">        response = jsonify(response)</span><br><span class="line">    <span class="comment"># 调用父类</span></span><br><span class="line">    <span class="keyword">return</span> super(myResponse, cls).force_type(response, environ)</span><br><span class="line"></span><br><span class="line">app.response_class = myResponse</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-学习笔记-&lt;br&gt;通过URL传递参数，接收参数，利用试图函数实现参数到URL转换，自定义URL转换&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="flask" scheme="https://hyqskevin.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>c++中的智能指针</title>
    <link href="https://hyqskevin.github.io/2019/04/05/ptr/"/>
    <id>https://hyqskevin.github.io/2019/04/05/ptr/</id>
    <published>2019-04-05T11:33:58.000Z</published>
    <updated>2019-04-06T12:09:29.068Z</updated>
    
    <content type="html"><![CDATA[<p>由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，用智能指针便可以有效缓解这类问题。</p><p>对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。</p><a id="more"></a><p>访问智能指针包含的裸指针则可以用 get() 函数</p><p>智能指针包含了 reset() 方法，如果不传递参数（或者传递 NULL），则智能指针会释放当前管理的内存。如果传递一个对象，则智能指针会释放当前对象，来管理新传入的对象。</p><ul><li>编写测试类来辅助分析</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Simple(<span class="keyword">int</span> param = <span class="number">0</span>) &#123;</span><br><span class="line">    number = param;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ~Simple() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrintSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PrintSomething: "</span> &lt;&lt; info_extend.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> info_extend;</span><br><span class="line">  <span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h2><p>包含头文件 <code>#include&lt;memory&gt;</code> 便可以使用<br><code>std::auto_ptr</code> 能够方便的管理单个堆内存对象</p><p>用法一：<br><code>std::auto_ptr&lt;MyClass&gt;m_example(new MyClass());</code></p><p>用法二：<br><code>std::auto_ptr&lt;MyClass&gt;m_example;</code><br><code>m_example.reset(new MyClass());</code></p><p>用法三（指针的赋值操作）：<br><code>std::auto_ptr&lt;MyClass&gt;m_example1(new MyClass());</code><br><code>std::auto_ptr&lt;MyClass&gt;m_example2(new MyClass());</code><br><code>m_example2=m_example1;</code></p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));   <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;             <span class="comment">// 判断智能指针是否为空</span></span><br><span class="line">    my_memory-&gt;PrintSomething();  <span class="comment">// 使用 operator-&gt; 调用智能指针对象中的函数</span></span><br><span class="line">    my_memory.get()-&gt;info_extend = <span class="string">"Addition"</span>; <span class="comment">// 使用 get() 返回裸指针，然后给内部对象赋值</span></span><br><span class="line">    my_memory-&gt;PrintSomething();               <span class="comment">// 再次打印，表明上述赋值成功</span></span><br><span class="line">    (*my_memory).info_extend += <span class="string">" other"</span>;      <span class="comment">// 使用 operator 返回智能指针内部对象，然后用“.”调用智能指针对象中的函数</span></span><br><span class="line">    my_memory-&gt;PrintSomething();               <span class="comment">// 再次打印，表明上述赋值成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;                          <span class="comment">// my_memory 栈对象即将结束生命期，析构堆对象 Simple(1)</span></span><br></pre></td></tr></table></figure><ul><li>执行结果为：<br>Simple: 1<br>PrintSomething:<br>PrintSomething: Addition<br>PrintSomething: Addition other<br>~Simple: 1</li></ul><h3 id="不能使用-操作符"><a href="#不能使用-操作符" class="headerlink" title="不能使用 = 操作符"></a>不能使用 = 操作符</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory2;   <span class="comment">// 创建一个新的 my_memory2 对象</span></span><br><span class="line">    my_memory2 = my_memory;             <span class="comment">// 复制旧的 my_memory 给 my_memory2</span></span><br><span class="line">    my_memory2-&gt;PrintSomething();       <span class="comment">// 输出信息，复制成功</span></span><br><span class="line">    my_memory-&gt;PrintSomething();        <span class="comment">// 崩溃</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>my_memory2 = my_memory</code>这行代码，my_memory2 完全夺取了 my_memory 的内存管理所有权，导致 my_memory 悬空，最后使用时导致崩溃。</p><h3 id="release-函数问题"><a href="#release-函数问题" class="headerlink" title="release() 函数问题"></a>release() 函数问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    my_memory.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                          <span class="comment">//最终执行结果为 Simple：1，没有被析构，导致内存泄露</span></span><br></pre></td></tr></table></figure><p>调用 release() 函数释放内存，不会释放对象，仅仅归还所有权，要自己delete或使用reset()函数销毁对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码修正</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    Simple* temp_memory = my_memory.release();</span><br><span class="line">    <span class="keyword">delete</span> temp_memory;</span><br><span class="line">    <span class="comment">// 或者直接 my_memory.reset();  释放 my_memory 内部管理的内存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项<br>使用 std::auto_ptr 时，<strong>绝对不能使用“operator=”操作符</strong>，这会夺取内存管理所有权<br>std::auto_ptr 的 release() 函数不会释放对象，仅仅归还所有权。<br>std::auto_ptr 最好不要当成参数传递（读者可以自行写代码确定为什么不能）。<br>std::auto_ptr 的“operator=”问题，有其管理的对象不能放入 std::vector 等容器中。<br>C++11中，std::auto_ptr已经被弃用</li></ul><hr><p>自C++11起，C++标准提供两大类型的智能指针：shared_ptr和unique_ptr</p><hr><h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>shared_ptr实现共享式拥有（shared ownership）概念。<strong>多个智能指针可以指向相同对象</strong>，该对象和其相关资源会在“最后一个引用（reference）被销毁”时候释放。为了在结构复杂的情境中执行上述工作，标准库提供了weak_ptr、bad_weak_ptr和enable_shared_from_this等辅助类。</p><p>shared_ptr本身提供默认内存释放器（default deleter），调用的是delete，也可以自定义释放器</p><p>默认内存释放器并<strong>不能释放数组内存空间</strong>，要我们自己提供内存释放器</p><ul><li><p>成员函数<br>use_count 返回引用计数的个数<br>unique 返回是否是独占所有权( use_count 为 1)<br>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少<br>get 返回内部对象(指针)</p></li><li><p>示例</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp0(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp0);               <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp1);               <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp2);               <span class="comment">// 11</span></span><br><span class="line">sp1.swap(sp0);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp0);               <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp1);               <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp2);               <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp3(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">22</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp4 = sp3;     <span class="comment">// 或 auto sp4 = sp3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp3);               <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp4);               <span class="comment">// 22</span></span><br><span class="line">sp3.reset();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp3.use_count());    <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp4.use_count());    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp3);                <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li>注意事项<br>shared_ptr 会因循环引用造成无法释放资源<br>与 weak_ptr 一起工作时, weak_ptr 在使用前需要检查合法性<br>shared_ptr 不支持数组, 如果使用数组, 需要自定义删除器</li></ul><h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</p><p>weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象. 注意, weak_ptr 在使用前需要检查合法性。</p><p>weak_ptr 支持拷贝或赋值, 但不会影响对应的 shared_ptr 内部对象的计数。</p><ul><li><p>成员函数<br>expired 用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false<br>lock 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同。<br>use_count 返回与 shared_ptr 共享的对象的引用计数.<br>reset 将 weak_ptr 置空.</p></li><li><p>使用weak_ptr解决shared_ptr因循环不能释放资源的问题<br>使用 shared_ptr 时, shared_ptr 为强引用, 如果存在循环引用, 将导致内存泄露. 而 weak_ptr 为弱引用, 可以避免此问题</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CA()&#123;&#125;</span><br><span class="line">    ~CA()&#123;PRINT_FUN();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;CB&gt; m_spb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CB()&#123;&#125;;</span><br><span class="line">    ~CB()&#123;PRINT_FUN();&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CA&gt; m_spa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CA&gt; spa(<span class="keyword">new</span> CA);  <span class="comment">// 通过调用weak_ptr，释放CA内存时不影响CB</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CB&gt; spb(<span class="keyword">new</span> CB);</span><br></pre></td></tr></table></figure><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>unique_ptr实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（resourece leak）——例如“以new创建对象后因为发生异常而忘记调用delete”——特别有用。</p><p>unique_ptr 不支持拷贝和赋值，但是可以调用 release 或 reset 将指针的所有权从一个(非 const) unique_ptr 转移到另一个<br><code>std::unique_ptr&lt;A&gt; up1(new A(5));</code><br><code>std::unique_ptr&lt;A&gt; up2(up1);</code> // 错误, unique_ptr 不支持拷贝<br><code>std::unique_ptr&lt;A&gt; up2 = up1;</code> // 错误, unique_ptr 不支持赋值<br><code>std::unique_ptr&lt;int&gt; up2(up1.release());</code> // 正确</p><p>unique_ptr 不支持拷贝, 但是可以从函数中返回, 甚至返回局部对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt; Clone(<span class="keyword">const</span> Ty&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">　<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt; temp = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt;(<span class="keyword">new</span> Ty(obj));</span><br><span class="line">　<span class="keyword">return</span> temp;</span><br><span class="line">  <span class="comment">// 或直接 return std::unique_ptr&lt;Ty&gt;(new Ty(obj))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique_ptr 支持管理数组</p><ul><li><p>成员函数<br>get 获得内部对象的指针<br>release 放弃内部对象的所有权，将内部指针置为空, 返回所内部对象的指针, 此指针需要手动释放<br>reset 销毁内部对象并接受新的对象的所有权(如果使用缺省参数的话，也就是没有任何对象的所有权, 此时仅将内部对象释放, 并置为空)<br>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br>std::move(name) 所有权转移(通过移动语义), 所有权转移后，变成“空指针”</p></li><li><p>防内存泄漏代码改进</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// 内存泄露</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// ptr成空悬指针</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line">  ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 unique_ptr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="boost-scoped-ptr"><a href="#boost-scoped-ptr" class="headerlink" title="boost::scoped_ptr"></a>boost::scoped_ptr</h2><h2 id="boost-shared-ptr"><a href="#boost-shared-ptr" class="headerlink" title="boost::shared_ptr"></a>boost::shared_ptr</h2><h2 id="boost-scoped-array"><a href="#boost-scoped-array" class="headerlink" title="boost::scoped_array"></a>boost::scoped_array</h2><h2 id="boost-shared-array"><a href="#boost-shared-array" class="headerlink" title="boost::shared_array"></a>boost::shared_array</h2><h2 id="boost-weak-ptr"><a href="#boost-weak-ptr" class="headerlink" title="boost::weak_ptr"></a>boost::weak_ptr</h2><h2 id="boost-intrusive-ptr"><a href="#boost-intrusive-ptr" class="headerlink" title="boost:: intrusive_ptr"></a>boost:: intrusive_ptr</h2><p>参考资料：<br><a href="https://blog.csdn.net/xt_xiaotian/article/details/5714477" target="_blank" rel="noopener">https://blog.csdn.net/xt_xiaotian/article/details/5714477</a><br><a href="https://www.cnblogs.com/xiehongfeng100/p/4645555.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiehongfeng100/p/4645555.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930361.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930361.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930372.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930372.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930388.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930388.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，用智能指针便可以有效缓解这类问题。&lt;/p&gt;
&lt;p&gt;对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&amp;gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="c++" scheme="https://hyqskevin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Flask Web 学习笔记1 -- 环境</title>
    <link href="https://hyqskevin.github.io/2019/03/31/flask-learning1/"/>
    <id>https://hyqskevin.github.io/2019/03/31/flask-learning1/</id>
    <published>2019-03-31T08:25:28.000Z</published>
    <updated>2019-04-11T13:16:00.414Z</updated>
    
    <content type="html"><![CDATA[<p>-学习笔记-<br>flask前期准备，在目录下建立flask虚拟环境，开启调试模式和书写配置文档<br><a id="more"></a></p><p>flask = werkzeug(web服务)+sqlalchemy(数据库)+jinja2(框架模板)</p><h2 id="flask运行环境"><a href="#flask运行环境" class="headerlink" title="flask运行环境"></a>flask运行环境</h2><p><code>pip install pipenv</code><br>使用 <code>pipenv</code> 隔离虚拟环境，防止不同项目环境冲突</p><p>命令行切换到目标目录下<br><code>pipenv shell</code> 进入虚拟环境<br><code>pipenv install flask</code> 安装flask<br><code>pipenv graph</code> 打印所有依赖<br><code>exit</code> 退出虚拟环境</p><p><a href="github.com/pypa/pipenv">pipenv doc</a></p><p>python 必须重启服务器才生效</p><ul><li>默认模板</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从flask这个包中导入Flask这个类</span></span><br><span class="line"><span class="comment"># Flask这个类是项目的核心，以后很多操作都是基于这个类的对象</span></span><br><span class="line"><span class="comment"># 注册url、注册蓝图等都是基于这个类的对象</span></span><br><span class="line">__author__ = <span class="string">'kevin'</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Flask对象，传递__name__参数进去</span></span><br><span class="line"><span class="comment"># __name__参数的作用：</span></span><br><span class="line"><span class="comment"># 1. 可以规定模版和静态文件的查找路径</span></span><br><span class="line"><span class="comment"># 2. 以后一些Flask插件，比如Flask-migrate、Flask-SQLAlchemy如果报错了，那么Flask可以通过这个参数找到具体的错误位置</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.route：是一个装饰器</span></span><br><span class="line"><span class="comment"># @app.route('/')就是将url中的/映射到hello_world这个视图函数上面</span></span><br><span class="line"><span class="comment"># 以后你访问我这个网站的/目录的时候，会执行hello_world这个函数，然后将这个函数的返回值返回给浏览器。</span></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello,World.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果这个文件是作为一个主文件运行，那么就执行app.run()方法，遍历运行</span></span><br><span class="line"><span class="comment"># 只在开发时使用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'127.0.0.1'</span>,port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><h3 id="debug模式"><a href="#debug模式" class="headerlink" title="debug模式"></a>debug模式</h3><p>开启了DEBUG模式，那么在代码中如果抛出了异常，在浏览器的页面中可以看到具体的错误信息，以及具体的错误代码位置。方便开发者调试。</p><p>如果开启了DEBUG模式，那么以后在<code>Python</code>代码中修改了任何代码，只要按<code>ctrl+s</code>，<code>flask</code>就会自动的重新记载整个网站。不需要手动点击重新运行。</p><ol><li>在<code>app.run()</code>中传递一个参数<code>debug=True</code>就可以开启<code>DEBUG</code>模式</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><ol><li>给<code>app.deubg=True</code>也可以开启<code>debug</code>模式。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><ol><li>通过配置参数的形式设置DEBUG模式：<code>app.config.update(DEBUG=True)</code>。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置配置参数的形式</span></span><br><span class="line"><span class="comment"># DEBUG必须要大写，不能小写</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.update(DEBUG=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><ol><li>通过配置文件的形式设置DEBUG模式：<code>app.config.from_object(config)</code></li></ol><p>导入<code>import config</code><br>使用<code>app.config.from_object(config)</code><br>新建<code>config.py</code>文件，写入<code>DEBUG=true</code></p><h3 id="config文件"><a href="#config文件" class="headerlink" title="config文件"></a>config文件</h3><ol><li>导入<code>import config</code>，使用<code>app.config.from_object(config)</code>,新建<code>config.py</code>文件，写入<code>DEBUG=true</code></li><li><code>app.config.from_pyfile(&#39;config.py,silence=True)</code>,新建<code>config.py</code>文件，写入<code>DEBUG=true</code><br>可以传递<code>silent=True</code>，那么这个静态文件没有找到的时候，不会抛出异常</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-学习笔记-&lt;br&gt;flask前期准备，在目录下建立flask虚拟环境，开启调试模式和书写配置文档&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="flask" scheme="https://hyqskevin.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>c++ 面向对象的一些特性</title>
    <link href="https://hyqskevin.github.io/2019/03/25/cpp-oop/"/>
    <id>https://hyqskevin.github.io/2019/03/25/cpp-oop/</id>
    <published>2019-03-25T11:35:15.000Z</published>
    <updated>2019-04-11T02:51:17.061Z</updated>
    
    <content type="html"><![CDATA[<p>-基础笔记-(loading…)<br>C++面向对象编程知识点复习梳理，包括类、继承、重载、多态、数据抽象、数据封装、接口<br><a id="more"></a></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h3><p>public<br>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值</p><p>private<br>私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员<br>默认情况下，类的所有成员都是私有的<br>一般会在私有区域定义数据，在公有区域定义相关的函数</p><p>protected<br>保护成员在派生类（即子类）中是可访问的</p><h3 id="构造函数-拷贝构造函数和析构函数"><a href="#构造函数-拷贝构造函数和析构函数" class="headerlink" title="构造函数,拷贝构造函数和析构函数"></a>构造函数,拷贝构造函数和析构函数</h3><p>创建、初始化和删除所创建的对象时调用<br>构造函数的名称与类的名称是完全相同的，不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值<br>拷贝构造函数是一种特殊的构造函数，在创建对象时，是使用同一类中之前创建的对象来<strong>初始化新创建的对象</strong>。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数<br>析构函数的名称与类的名称是完全相同的，不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Classname();  <span class="comment">//构造函数</span></span><br><span class="line">  Classname(<span class="keyword">const</span> Classname &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">  ~Classname();  <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Classname::Classname()&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  *ptr = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//指针分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Classname::Classname(<span class="keyword">const</span> Classname &amp;obj)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用拷贝构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  *ptr = *obj.ptr;  <span class="comment">//指针分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CLassname::~Classname()&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"释放内存"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类如果有多个字段 X、Y、Z 等需要进行初始化，可以使用如下语法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Classname::objname( <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): X(a), Y(b), Z(c)</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>浅拷贝：如果没有拷贝构造函数，编译器自动产生一个“默认拷贝构造函数”，使用“老对象”的数据成员的值对“新对象”的数据成员进行赋值<br>当对象存在动态成员，那么浅拷贝就会出问题，在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，出现错误</p><p>深拷贝：对象中动态成员重新动态分配空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Classname()&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  Classname(<span class="keyword">const</span> Classname&amp; r)&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);  <span class="comment">//重新分配动态空间</span></span><br><span class="line">    *p = *(r.p);  <span class="comment">//指针分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line">  ~Classname()&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>定义在类外部，用来访问类的 private 和 protected 成员<br>可以不使用范围解析运算符 <code>::</code> 定义该函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Classname</span>;</span>  <span class="comment">//友元类</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">objname</span><span class="params">()</span></span>;  <span class="comment">//友元函数</span></span><br></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码，即把该函数的代码副本放置在每个调用该函数的地方<br>类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>每一个对象都能通过 <code>this</code> 指针来访问自己的地址<br>友元函数没有 <code>this</code> 指针，因为友元不是类的成员</p><h3 id="类指针"><a href="#类指针" class="headerlink" title="类指针"></a>类指针</h3><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 <code>-&gt;</code>，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     func()&#123;&#125;</span><br><span class="line">     ...</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Box *ptrBox;</span><br><span class="line">ptrBox-&gt;func();</span><br></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>变量和函数都可以被声明为静态的</p><ol><li><p>声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员在类的所有对象中是共享的<br>不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化</p></li><li><p>把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。<br>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> objectCount;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> objectCount;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类 Box 的静态成员</span></span><br><span class="line"><span class="keyword">int</span> Box::objectCount = <span class="number">0</span>;</span><br><span class="line">output = Box::getCount()</span><br></pre></td></tr></table></figure><h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前</p><ol><li><p>auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符</p></li><li><p>register(C++ 11弃用) 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）</p></li><li><p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</p></li><li><p>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p></li></ol><p>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。</p><ol><li><p>mutable 说明符仅适用于类的对象，它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p></li><li><p>thread_local 说明符声明的变量仅可在它在其上创建的线程上访问，变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p></li></ol><p>thread_local 说明符可以与 static 或 extern 合并。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p><p>当创建一个类时，不需要重新编写新的<strong>数据成员和成员函数</strong>，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p><p>派生类可以访问基类中所有的<strong>非私有成员</strong>。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p><p><code>class derived-class: (public/protected/private) base-class</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性，C++ 类可以从多个类继承成员</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="虚继承：解决多继承中出现的问题"><a href="#虚继承：解决多继承中出现的问题" class="headerlink" title="虚继承：解决多继承中出现的问题"></a>虚继承：解决多继承中出现的问题</h3><p>从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。</p><p>虚继承在创建对象的时候会创建一个虚表，从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。</p><p>这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类:</span> <span class="keyword">virtual</span> 方式<span class="number">1</span> 基类<span class="number">1</span>，<span class="keyword">virtual</span> 方式<span class="number">2</span> 基类<span class="number">2</span>，...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">...<span class="comment">//派生类成员声明</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><h3 id="派生类无法从基类继承"><a href="#派生类无法从基类继承" class="headerlink" title="派生类无法从基类继承"></a>派生类无法从基类继承</h3><p>基类的构造函数、析构函数和拷贝构造函数<br>基类的重载运算符<br>基类的友元函数</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p><p>编译器通过把使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>重定义或重载大部分 C++ 内置的运算符，使用自定义类型的运算符。</p><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p><p><code>Box operator+(const Box&amp; b);  // 重载+运算符</code></p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一个类中，声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"整数为: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>  f)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"浮点数为: "</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串为: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>4.2“覆盖”是指派生类函数覆盖基类函数，特征是：<br>（1）不同的范围（分别位于派生类与基类）；<br>（2）函数名字相同；<br>（3）参数相同；<br>（4）基类函数必须有virtual 关键字。 </p><p>4.3“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，特征是：</p><p>（1）如果派生类的函数与基类的函数同名，但是参数不同，此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。<br>（2）如果派生类的函数与基类的函数同名，但是参数相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p><h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><hr><p>参考资料：<br><a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">http://c.biancheng.net/cplus/</a><br>w3school</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-基础笔记-(loading…)&lt;br&gt;C++面向对象编程知识点复习梳理，包括类、继承、重载、多态、数据抽象、数据封装、接口&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="c++" scheme="https://hyqskevin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的相关操作</title>
    <link href="https://hyqskevin.github.io/2019/03/24/bintree/"/>
    <id>https://hyqskevin.github.io/2019/03/24/bintree/</id>
    <published>2019-03-24T02:33:15.000Z</published>
    <updated>2019-08-26T01:46:48.364Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的笔记 loading…<br><a id="more"></a></p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h2 id="四种遍历方法"><a href="#四种遍历方法" class="headerlink" title="四种遍历方法"></a>四种遍历方法</h2><h2 id="二叉树静态实现"><a href="#二叉树静态实现" class="headerlink" title="二叉树静态实现"></a>二叉树静态实现</h2><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="一般意义上的树"><a href="#一般意义上的树" class="headerlink" title="一般意义上的树"></a>一般意义上的树</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的笔记 loading…&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>基于二叉树的衍生算法</title>
    <link href="https://hyqskevin.github.io/2019/03/24/bintree2/"/>
    <id>https://hyqskevin.github.io/2019/03/24/bintree2/</id>
    <published>2019-03-24T02:33:15.000Z</published>
    <updated>2019-08-26T01:47:07.548Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树衍生算法 loading…<br><a id="more"></a></p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树衍生算法 loading…&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>二分查找策略</title>
    <link href="https://hyqskevin.github.io/2019/03/21/two-divide/"/>
    <id>https://hyqskevin.github.io/2019/03/21/two-divide/</id>
    <published>2019-03-21T13:33:15.000Z</published>
    <updated>2019-08-26T01:50:58.250Z</updated>
    
    <content type="html"><![CDATA[<p>需要一个严格单调的序列，就能将O(n)的复杂度降到O(logn)的优秀算法<br>非常适合有序数列的查找<br>二分的思想也可以用来逼近准确值和降幂求值<br><a id="more"></a></p><h2 id="二分查找思路"><a href="#二分查找思路" class="headerlink" title="二分查找思路"></a>二分查找思路</h2><p>设left，right，mid，查找数x<br>查找的数 &gt; mid，left = mid + 1<br>查找的数 &lt; mid，right = mid - 1<br>直到查找的数 = mid，程序结束</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">  &#123;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[mid] == x) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[mid] &gt; x)</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//查找失败则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;  <span class="comment">//序列元素个数</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">array</span>[n] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> result = binSearch(<span class="built_in">array</span>,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mid = (left + right) / 2 可能会导致int类型溢出，可以改成 mid = left + (right - left) / 2</li></ul><h2 id="当序列中有相同的元素"><a href="#当序列中有相同的元素" class="headerlink" title="当序列中有相同的元素"></a>当序列中有相同的元素</h2><p>求解序列中第一个等于x的元素和最后一个等于x的元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">  &#123;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[mid] &gt;= x) </span><br><span class="line">      right = mid;</span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left;  <span class="comment">// left==right 循环停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">  &#123;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[mid] &gt; x) </span><br><span class="line">      right = mid;</span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left;  <span class="comment">// left==right 循环停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逼近无理数近似值"><a href="#逼近无理数近似值" class="headerlink" title="逼近无理数近似值"></a>逼近无理数近似值</h2><p>计算f(x)中x的值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ...;  <span class="comment">// f(x)的公式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> L, <span class="keyword">double</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> left = L, right = R, mid;</span><br><span class="line">  <span class="keyword">while</span>(right - left &gt; eps)</span><br><span class="line">  &#123;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(func(mid)&gt;<span class="number">0</span>) right = mid;</span><br><span class="line">    <span class="keyword">else</span> left = mid</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速求幂"><a href="#快速求幂" class="headerlink" title="快速求幂"></a>快速求幂</h2><p>二分幂的思想可以用来降低时间复杂度<br>若b为奇数，a^b = a <em> a^b-1<br>若b为偶数，a^b = a^b/2 </em> a^b/2<br>直到a^0 =1，依次退回计算</p><h3 id="快速幂递归写法"><a href="#快速幂递归写法" class="headerlink" title="快速幂递归写法"></a>快速幂递归写法</h3><p>求解 a^b%m的递归写法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">binFunc</span><span class="params">(LL a, LL b, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// a^0 == 1</span></span><br><span class="line">  <span class="keyword">if</span>(b % <span class="number">2</span> ==<span class="number">1</span>) <span class="keyword">return</span> a* binFunc(a, b<span class="number">-1</span>, m) % m;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LL mul = binFunc(a, b/<span class="number">2</span>, m);</span><br><span class="line">    <span class="keyword">return</span> mul * mul % m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>b % 2 ==1</code>可以写成<code>b&amp;1</code>,将b和1进行按位与操作，判断b末尾是否为1</li></ul><h3 id="快速幂非递归写法"><a href="#快速幂非递归写法" class="headerlink" title="快速幂非递归写法"></a>快速幂非递归写法</h3><p>将b写成若干2次幂之和，将a^b表示成若干项乘积</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">binFunc</span><span class="params">(LL a, LL b, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LL ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans * a % m;  <span class="comment">//判断2进制末尾是否为1，是的话*a</span></span><br><span class="line">    a = a * a % m;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要一个严格单调的序列，就能将O(n)的复杂度降到O(logn)的优秀算法&lt;br&gt;非常适合有序数列的查找&lt;br&gt;二分的思想也可以用来逼近准确值和降幂求值&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>分治和递归基础算法</title>
    <link href="https://hyqskevin.github.io/2019/03/21/divide/"/>
    <id>https://hyqskevin.github.io/2019/03/21/divide/</id>
    <published>2019-03-21T02:02:47.000Z</published>
    <updated>2019-08-26T01:48:03.950Z</updated>
    
    <content type="html"><![CDATA[<p>写分治和贪心时，习惯性地会去思索程序的全局，而一旦展开去想，基本上就大脑溢出了<br>目前还是无法把握<strong>递归式</strong>和<strong>递归</strong>边界，这算法终将是一生之敌。<br><a id="more"></a></p><h2 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h2><p>用Fibonacci数列简单熟悉一下算法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span> | n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//递归边界</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>);  <span class="comment">//递归式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,Fibonacci(n));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>按照字典顺序从小到大顺序输出1-n全排列</p><p>思路：数组P存放当前排列，hashTable 置为 true 存放已在P中的数字<br>递归式：P按位处理，数字x不在P中，将x填入P，P处理下一位<br>递归边界：处理完n位，输出排列，hashTable[x]=false 还原</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> P[maxn],hashTable[maxn] = &#123;<span class="literal">false</span>&#125;,n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理第index位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index == n+<span class="number">1</span>)  <span class="comment">//到达递归边界</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>,P[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)  <span class="comment">//递归式逻辑</span></span><br><span class="line">      &#123;</span><br><span class="line">        P[index] = x;</span><br><span class="line">        hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">        generateP(index+<span class="number">1</span>);</span><br><span class="line">        hashTable[x] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);  <span class="comment">//输入有几个数</span></span><br><span class="line">  generateP(<span class="number">1</span>)；  <span class="comment">//从1开始递归</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h2><p>皇后两两不在同行同列同对角线</p><p>思路：到达递归边界时，遍历任意两个皇后查看是否满足条件<br>递归边界：列index到达n，满足八皇后条件，count+1<br>递归式：行x不在hashTable中，此列放置皇后，index移动到下一列</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span>(index == n+<span class="number">1</span>)  <span class="comment">//到达递归边界，判断是否合法</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(P[i]-P[j]) == <span class="built_in">abs</span>(i-j))</span><br><span class="line">          flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag) count++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)  <span class="comment">//递归式</span></span><br><span class="line">      &#123;</span><br><span class="line">        P[index] = x;</span><br><span class="line">        hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">        generateP(index+<span class="number">1</span>);</span><br><span class="line">        hashTable[x] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举所有情况会比较耗时间，可以在放置皇后的同时遍历之前的，判断是否有冲突</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(inedx == n+<span class="number">1</span>)  <span class="comment">//到达递归边界</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">1</span>; pre&lt;index; pre++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">abs</span>(P[index]-P[pre]) == <span class="built_in">abs</span>(index-pre))</span><br><span class="line">          &#123;</span><br><span class="line">            flag == <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">          P[index] = x;</span><br><span class="line">          hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">          generateP(index+<span class="number">1</span>);</span><br><span class="line">          hashTable[x] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写分治和贪心时，习惯性地会去思索程序的全局，而一旦展开去想，基本上就大脑溢出了&lt;br&gt;目前还是无法把握&lt;strong&gt;递归式&lt;/strong&gt;和&lt;strong&gt;递归&lt;/strong&gt;边界，这算法终将是一生之敌。&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>cpp_stl</title>
    <link href="https://hyqskevin.github.io/2019/03/20/cpp-stl/"/>
    <id>https://hyqskevin.github.io/2019/03/20/cpp-stl/</id>
    <published>2019-03-20T11:33:58.000Z</published>
    <updated>2019-04-11T01:23:02.091Z</updated>
    
    <content type="html"><![CDATA[<p>C++ STL接触(loading…)<br>在学习C++，数据结构基础上，STL是基础和进阶的分水岭，要多尝试用STL实现常用的算法和数据结构<br><a id="more"></a></p><h2 id="Template（模板）"><a href="#Template（模板）" class="headerlink" title="Template（模板）"></a>Template（模板）</h2><p>模板（Template）指C++程序设计设计语言中采用类型作为参数的程序设计，支持通用程序设计。C++ 的标准库提供许多有用的函数大多结合了模板的观念，如STL以及IO Stream。</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>可以实现不同类型的函数代码的复用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt; swap(t &amp;t1, t &amp;t2)&#123;</span><br><span class="line">  t tmpT;</span><br><span class="line">  tmpT = t1;</span><br><span class="line">  t1 = t2;</span><br><span class="line">  t2 = tmpT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板实例化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">float</span> num3 = <span class="number">1.0</span>, num4 = <span class="number">2.0</span>;</span><br><span class="line">  swap&lt;<span class="keyword">int</span>&gt;(num1, num2);</span><br><span class="line">  swap&lt;<span class="keyword">float</span>&gt;(num3, num4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>可以实现不同类型的类的复用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">t</span>&gt; <span class="title">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Stack()&#123;</span><br><span class="line">      maxSize = <span class="number">100</span>;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      p = <span class="keyword">new</span> t[maxSize];</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Stack()&#123;</span><br><span class="line">      <span class="keyword">delete</span> p[];</span><br><span class="line">      p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(t num)</span></span>&#123;</span><br><span class="line">      size++;</span><br><span class="line">      p[size<span class="number">-1</span>] = num;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">t <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">      t num = p[size<span class="number">-1</span>];</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    t *p;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板实例化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Stack&lt;<span class="keyword">int</span>&gt; intStack;</span><br><span class="line">  Stack&lt;<span class="keyword">float</span>&gt; floatStack;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  intStack.push(<span class="number">1</span>);</span><br><span class="line">  intStack.push(<span class="number">2</span>);</span><br><span class="line">  intStack.push(<span class="number">3</span>);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!intStack.isEmpty())&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,intStack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>模板可以有常规的类型参数，也可以有默认模板参数<br><code>template&lt;class t, int maxSize = 100&gt; class stack{}</code></p><p>一个类没有模板参数，但是成员函数有模板参数，是可行的</p><p>有些特殊的参数可以使用模板专门化<br><code>template&lt;&gt; void swap(std::vector&lt;int&gt;&amp; t1, std::vector&lt;int&gt;&amp; t2){}</code></p><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p>使用指针 ++ 和 — 操作符来遍历字符串，无论 ASCII 码字符串还是 Unicode 字符串，使用指针均能够正确无误地返回要寻求的字符位置。使用数组处理字符串中的字符也非常方便。</p><p>STL 中只有一个字符串类，即 basic_string。类 basic_string 实现管理以 \0 结尾的字符数组，字符类型由模板参数决定。basic_string 有两个预定义类型：包含 char 的 string 类型和包含 wchar 的 wstring 类型。</p><p>string 作为类出现，其集成的操作函数足以完成多数情况下的需要。可以使用 “=” 进行赋值，使用 “==” 进行等值比较，使用 “+” 做串联。</p><p>string 类包含了 6 个构造函数。string 类支持 cin 方式和 getline() 方式两种输入方式。</p><h3 id="basic-string"><a href="#basic-string" class="headerlink" title="basic_string"></a>basic_string</h3><p>basic_string是一个类模板，包括string，wstring，u16stirng和u32string<br><code>typedef basic_string &lt;char&gt; string;</code><br><code>typedef basic_string &lt;wchar&gt; wstring;</code>  //wstring 类是为了便于使用宽字符集，例如 Unicode 或某些欧洲字符集</p><h3 id="string函数"><a href="#string函数" class="headerlink" title="string函数"></a>string函数</h3><p>string 类提供的各种操作函数大致分为八类：构造器和析构器、大小和容量、元素存取、字 符串比较、字符串修改、字符串接合、I/O 操作以及搜索和查找。</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数名称</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">构造函数</td><td style="text-align:left">产生或复制字符串</td></tr><tr><td style="text-align:left">析构函数</td><td style="text-align:left">销毁字符串</td></tr><tr><td style="text-align:left">=，assign</td><td style="text-align:left">赋以新值</td></tr><tr><td style="text-align:left">Swap</td><td style="text-align:left">交换两个字符串的内容</td></tr><tr><td style="text-align:left"><strong>+ =，append( )，push_back()</strong></td><td style="text-align:left">添加字符</td></tr><tr><td style="text-align:left">insert ()</td><td style="text-align:left">插入字符</td></tr><tr><td style="text-align:left">erase()</td><td style="text-align:left">删除字符</td></tr><tr><td style="text-align:left">clear ()</td><td style="text-align:left">移除全部字符</td></tr><tr><td style="text-align:left">resize ()</td><td style="text-align:left">改变字符数量</td></tr><tr><td style="text-align:left">replace()</td><td style="text-align:left">替换字符</td></tr><tr><td style="text-align:left"><strong>+</strong></td><td style="text-align:left">串联字符串</td></tr><tr><td style="text-align:left">==，！ =，&lt;，&lt;=，&gt;，&gt;=，<strong>compare()</strong></td><td style="text-align:left">比较字符串内容</td></tr><tr><td style="text-align:left"><strong>size()，length()</strong></td><td style="text-align:left">返回字符数量</td></tr><tr><td style="text-align:left">max_size ()</td><td style="text-align:left">返回字符的最大可能个数</td></tr><tr><td style="text-align:left">empty ()</td><td style="text-align:left">判断字符串是否为空</td></tr><tr><td style="text-align:left">capacity ()</td><td style="text-align:left">返回重新分配之前的字符容量</td></tr><tr><td style="text-align:left">reserve()</td><td style="text-align:left">保留内存以存储一定数量的字符</td></tr><tr><td style="text-align:left"><strong>[ ],at()</strong></td><td style="text-align:left">获取字符串元素</td></tr><tr><td style="text-align:left">&gt;&gt;，getline()</td><td style="text-align:left">从 stream 中读取某值</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">将值写入 stream</td></tr><tr><td style="text-align:left">copy()</td><td style="text-align:left">将内容复制为一个 C - string</td></tr><tr><td style="text-align:left"><strong>c_str()</strong></td><td style="text-align:left">将内容以 C - string 形式返回</td></tr><tr><td style="text-align:left">data()</td><td style="text-align:left">将内容以字符数组形式返回</td></tr><tr><td style="text-align:left">substr()</td><td style="text-align:left">返回子字符串</td></tr><tr><td style="text-align:left"><strong>find()</strong></td><td style="text-align:left">搜寻某子字符串或字符</td></tr><tr><td style="text-align:left"><strong>rfind()</strong></td><td style="text-align:left">逆向搜寻字符串或字符</td></tr><tr><td style="text-align:left"><strong>find_first_of()**</strong>find_last_of()**</td><td style="text-align:left">搜寻第一个/最后一个匹配的字符串</td></tr><tr><td style="text-align:left">begin( )，end()</td><td style="text-align:left">提供正向迭代器支持</td></tr><tr><td style="text-align:left">rbegin()，rend()</td><td style="text-align:left">提供逆向迭代器支持</td></tr><tr><td style="text-align:left">get_allocator()</td><td style="text-align:left">返回配置器</td></tr></tbody></table></div><h3 id="string构造和析构函数"><a href="#string构造和析构函数" class="headerlink" title="string构造和析构函数"></a>string构造和析构函数</h3><ul><li>类构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> strs <span class="comment">//生成空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str)</span> <span class="comment">//生成字符串str的复制品</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, stridx)</span> <span class="comment">//将字符串str中始于stridx的部分作为构造函数的初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str, strbegin, <span class="built_in">strlen</span>)</span> <span class="comment">//将字符串str中始于strbegin、长度为strlen的部分作为字符串初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr)</span> <span class="comment">//以C_string类型cstr作为字符串s的初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cstr,char_len)</span>    <span class="comment">//以C_string类型cstr的前char_len个字符串作为字符串s的初值</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(num, c)</span> <span class="comment">//生成一个字符串，包含num个c字符</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(strs, beg, end)</span>    <span class="comment">//以区间[beg, end]内的字符作为字符串s的初值</span></span></span><br></pre></td></tr></table></figure><ul><li>析构函数<br><code>~string() //销毁所有内存，释放内存</code></li></ul><h2 id="5种序列容器"><a href="#5种序列容器" class="headerlink" title="5种序列容器"></a>5种序列容器</h2><p>序列容器以线性序列的方式存储元素。它没有对元素进行排序，元素的顺序和存储它们的顺序相同。</p><ol><li><code>array&lt;T,N&gt;</code> (数组容器) ：是一个长度固定的序列，有 N 个 T 类型的对象，不能增加或删除元素。</li><li><code>vector&lt;T&gt;</code> (向量容器) ：是一个长度可变的序列，用来存放T类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。</li><li><code>deque&lt;T&gt;</code> (双向队列容器) ：是一个长度可变的、可以自动增长的序列，在序列的两端都不能高效地增加或删除元素。</li><li><code>list&lt;T&gt;</code> (链表容器) 是一个长度可变的、由 T 类型对象组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。访问容器中任意元素的速度要比前三种容器慢，这是因为 <code>list&lt;T&gt;</code> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li><li><code>forward list&lt;T&gt;</code> (正向链表容器) ：是一个长度可变的、由 T 类型对象组成的序列，它以单链表的形式组织元素，是一类比链表容器快、更节省内存的容器，但是它内部的元素只能从第一个元素开始访问。</li></ol><h3 id="常用函数成员"><a href="#常用函数成员" class="headerlink" title="常用函数成员"></a>常用函数成员</h3><p>函数成员    array<t,n>    vector<t>    deque<t><br>begin() - 返回幵始迭代器    是    是    是<br>end() - 返回结束迭代器    是    是    是<br>rbegin() - 返回反向’开始迭代器    是    是    是<br>rend() - 返回反向结束迭代器    是    是    是<br>cbegin() - 返M const开始迭代器    是    是    是<br>cend() - 返回const结束迭代器    是    是    是<br>crbegin() - 返回const反向开始迭代器    是    是    是<br>crend() - 返回const反向结束迭代器    是    是    是<br>assign() - 用新元素替换原有内容    -    是    是<br>operator=() - 复制同类型容器的元素，或者用初始化列表替换 现有内容    是    是    是<br>size() - 返回实际元素个数    是    是    是<br>max_size() - 返回元素个数的设大值    是    是    是<br>capacity() - 返回当前容量    -    是    -<br>empty() - 返回true,如果容器中没有元素的话    是    是    是<br>resize() - 改变实际元素的个数    -    是    是<br>shrink _to_fit() - 将内存减少到等于当前元素实际所使用的大小    -    是    是<br>front() - 返回第一个元素的引用    是    是    是<br>back() - 返回铖后一个元素的引用    是    是    是<br>operator<a href></a> - 使用索弓丨访问元素    是    是    是<br>at() - 使用经过边界检査的索引访问元素    是    是    是<br>push_back() - 在序列的尾部添加一个元素    -    是    是<br>insert() - 在指定的位置插入一个或多个元素    -    是    是<br>emplace() - 在指定的位置直接生成一个元素    -    是    是<br>emplace_back() - 在序列尾部生成一个元素    -    是    是<br>pop_back() - 移出序列尾部的元素    -    是    是<br>erase() - 移出一个元素或一段元素    -    是    是<br>clear() - 移出所苻的元素，容器大小变为 0    -    是    是<br>swap() - 交换两个容器的所有元素    是    是    是<br>data() - 返回包含元素的内部数组的指针    是    是    -</t></t></t,n></p><p>函数成员    list<t>    forward list<t><br>begin() - 返回开始迭代器    是    是<br>end() - 返回结束迭代器    是    是<br>rbegin() - 返回反向开始迭代器    是    -<br>rend() - 返回反向结束迭代器    是    -<br>cbegin() - 返回 const 开始结束迭代器    是    是<br>before_begin() - 返回一个指向第一个元素前一个位置的迭代器    -    是<br>cbefore_begin() - 返回一个指向第一个元素前一个位置的const迭代器    -    是<br>cend() - 返回 const 结束迭代器    是    是<br>crbegin() - 返回 const 反向开始迭代器    是    -<br>crend() - 返回 const 反向结束迭代器    是    -<br>assign() - 用新元素替换原有内容    是    是<br>operator=() - 复制同类型容器的元素，或者用初始化列表替换现有内容    是    是<br>size() - 返回实际元素个数    是    -<br>max_size() - 返回元素个数的最大值    是    是<br>resize() - 改变实际元素的个数    是    是<br>empty() - 返回 true，如果容器中没有元素的话    是    是<br>from() - 返回第一个元素的引用    是    是<br>back() - 返回最后一个元素的引用    是    -<br>push_back() - 在序列的潘部添加一个元素    是    -<br>push_front() - 在序列的起始位置添加一个元素    是    是<br>emplace() - 在指矩位置直接生成一个元素    是    -<br>emplace_after() - 在指定位置的后面直接生成一个元素    -    是<br>emplace_back() - 在序列尾部生成一个元素    是    -<br>cmplacc_front() - 在序列的起始位生成一个元索    是    是<br>insert() - 在指定的位置插入一个或多个元素    是    -<br>insert_after() - 在指定位置的后面插入一个或多个元素    -    是<br>pop_back() - 移除序列尾部的元素    是    -<br>pop_front() - 移除序列头部的元素    是    是<br>reverse()-反向元素的顺序    是    是<br>erase() - 移除指定位置的一个元素或一段元素    是    -<br>erase_after() - 移除指定位 1；后面的一个元素或一段元素    -    是<br>remove() - 移除所苻和参数匹配的元素    是    是<br>remove_if() - 移除满足一元函数条件的所有元素    是    是<br>unique() - 移除所有连续重复的元素    是    是<br>clear() - 移除所有的元素，容器大小变为 0    是    是<br>swap() - 交换两个容器的所有元素    是    是<br>sort() - 对元素进行排序    是    是<br>merge() - 合并两个有序容器    是    是<br>splice() - 移动指定位置前面的所有元素到另一个同类型的 list 中    是    -<br>splice_after() - 移动指定位置后面的所有元素到另一个同类型的 list 中    -    是</t></t></p><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p>array：<code>std::array&lt;typename, 100&gt; data {};</code></p><ul><li>通过调用数组对象的成员函数 fill()，可以将所有元素设成给定值 <code>data.fill(0.0);</code></li><li>获取元素 <code>data[num]</code><ul><li>为了获取时能够检查越界索引值，可以使用成员函数 at()，当传给 at() 的索引是一个越界值时，这时会抛出 std::out_of_rang 异常 <code>data.at(num)</code></li></ul></li></ul><p>vector：<code>std::vector&lt;typename&gt; values(num) {1,2,3,...};</code></p><ul><li>通过调用 reserve() 来增加容器的容量 <code>values.reserve(20)</code></li><li>通过调用成员函数 resize() 可以改变容器大小 <code>values.resize(size, num)</code></li><li>使用 push_back()、insert()、emplace() 或 emplace_back() 函数来添加一个元素<br><code>values.push_back()</code>  //使用时会调用构造函数和拷贝构造函数<br><code>values.emplace_back()</code>  // 不需要触发构造函数和拷贝构造函数<br><code></code></li><li>front() 和 back() 分別返回序列中第一个和最后一个元素的引用 <code>values.front()</code></li><li>data() 返回指向数组的指针 <code>values.data()</code></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li>迭代器<br><code>auto first = std::begin(data);</code><br><code>auto last = std::end (data);</code></li></ul><h2 id="3种容器适配器"><a href="#3种容器适配器" class="headerlink" title="3种容器适配器"></a>3种容器适配器</h2><p>容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。</p><ol><li><code>stack&lt;T&gt;</code>：是一个封装了 <code>deque&lt;T&gt;</code> 容器的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。<code>stack&lt;T&gt;</code>· 模板定义在头文件 stack 中。</li><li><code>queue&lt;T&gt;</code>：是一个封装了 <code>deque&lt;T&gt;</code> 容器的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器。<code>queue&lt;T&gt;</code> 模板定义在头文件 queue 中。</li><li><code>priority_queue&lt;T&gt;</code>：是一个封装了 <code>vector&lt;T&gt;</code> 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。<code>priority_queue&lt;T&gt;</code> 模板定义在头文件 queue 中。</li></ol><h2 id="4种map容器"><a href="#4种map容器" class="headerlink" title="4种map容器"></a>4种map容器</h2><p><code>map&lt;K，T&gt;</code>容器，保存的是 <code>pair&lt;const K，T&gt;</code> 类型的元素。<code>pair&lt;const K,T&gt;</code> 封装了一对键对象，键的类型是 K，对象的类型是 T。每个键都是唯一的，所以不允许有重复的键；但可以保存重复的对象，只要它们的键不同。map 容器中的元素都是有序的，元素在容器内的顺序是通过比较键确定的。默认使用 less<k> 对象比较。<br>multimap<k，t> 容器和 map<k，t> 容器类似，也会对元素排序。它的键必须是可比较的，元素的顺序是通过比较键确定的。和 map<k，t> 不同的是，multimap<k，t> 允许使用重复的键。因此，一个 multimap 容器可以保存多个具有相同键值的 <const k,t> 元素。<br>unordered_map<k，t> 中 pair&lt; const K，T&gt;元素的顺序并不是直接由键值确定的，而是由键值的哈希值决定的。哈希值是由一个叫作哈希的过程生成的整数，本章后面会解释这一点。unordered_map<k，t>不允许有重复的键。<br>unordered_multimap<k,t> 也可以通过键值生成的哈希值来确定对象的位置，但它允许有重复的键。</k,t></k，t></k，t></const></k，t></k，t></k，t></k，t></k></p><h2 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h2><p>set 容器是关联容器，其中的对象是对象它们自己的键</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h2 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h2><h2 id="数值、时间和复数"><a href="#数值、时间和复数" class="headerlink" title="数值、时间和复数"></a>数值、时间和复数</h2><h2 id="C-常用算法和algorithm库"><a href="#C-常用算法和algorithm库" class="headerlink" title="C++常用算法和algorithm库"></a>C++常用算法和algorithm库</h2><hr><p>参考资料<br><a href="http://c.biancheng.net/stl/" target="_blank" rel="noopener">C语言中文网</a><br>C++ Primer Plus 第6版中文版<br>学校教材</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ STL接触(loading…)&lt;br&gt;在学习C++，数据结构基础上，STL是基础和进阶的分水岭，要多尝试用STL实现常用的算法和数据结构&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="c++" scheme="https://hyqskevin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>散列表基础算法</title>
    <link href="https://hyqskevin.github.io/2019/03/19/hashtable/"/>
    <id>https://hyqskevin.github.io/2019/03/19/hashtable/</id>
    <published>2019-03-19T02:10:47.000Z</published>
    <updated>2019-08-26T01:48:45.908Z</updated>
    
    <content type="html"><![CDATA[<p>-散列基础-<br>散列（hash）是常用的算法思想之一，它使用空间换时间的思想在我第一次碰到时就感觉巧妙如魔法一般。特别是在进行一些大量数字和字符串比较方面，hash能瞬间将O(n^2)的复杂度降到O(n),单次查询的复杂度降到O(1)，靠的就是数组下标与查询的元素之间建立的唯一转换关系。<br><a id="more"></a></p><h2 id="常用hash"><a href="#常用hash" class="headerlink" title="常用hash"></a>常用hash</h2><p>线性变换函数：H(key) = a*key+b<br>除留余数：h(key) = key%mod</p><p>除留余数法会出现<strong>冲突</strong>的情况，需要解决多个hash值相同的情况</p><ol><li>线性探测法：从当前位置检查相邻地址是否被占用，如果都被占用，循环检查下一个位置</li><li>平方探测法：从当前位置检查+1，-1，+4，-4，+9，-9……如果检查中+k^2超过表长（Tablesize），[H(key)+k^2]%Tablesize</li><li>链地址法：把hash相同的key连接成单链表</li></ol><h2 id="整数hash"><a href="#整数hash" class="headerlink" title="整数hash"></a>整数hash</h2><h3 id="查询数组M中的数在数组N中是否出现过"><a href="#查询数组M中的数在数组N中是否出现过" class="headerlink" title="查询数组M中的数在数组N中是否出现过"></a>查询数组M中的数在数组N中是否出现过</h3><p>常规思路：遍历所有N，要遍历M次，时间复杂度O(MN)<br>hash思路：bool hashTable[maxn]={false}，先读入N，N中出现的数x，hashTable[x]=true,再查询M，时间复杂度O(M+N)</p><ul><li>示例</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n[<span class="number">10</span>] = &#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> m[<span class="number">3</span>] = &#123;<span class="number">8</span>,<span class="number">22</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> x;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">      hashTable&#123;n[i]&#125; = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(hashTable&#123;m[j]]&#125; == <span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,yes\n"</span>,m[j]);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d,no\n"</span>,m[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询M中的数在N中出现的次数"><a href="#查询M中的数在N中出现的次数" class="headerlink" title="查询M中的数在N中出现的次数"></a>查询M中的数在N中出现的次数</h3><p>将hashTable 替换为int类型进行计数</p><ul><li>示例</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> hashTable[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n[<span class="number">10</span>] = &#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> m[<span class="number">3</span>] = &#123;<span class="number">8</span>,<span class="number">12</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">      hashTable&#123;n[i]&#125;++;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hashTable&#123;m[j]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><p>需要将字符串和整数唯一对应，可以直接对应或使用hash函数对应：A-Z 0~25，a-z 26~51</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字符串S转换为整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> hashID = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(S[i]&gt;=<span class="string">'A'</span> &amp;&amp; S[i]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">      hashID = hashID*<span class="number">52</span> + S[i] - <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S[i]&gt;=<span class="string">'a'</span> &amp;&amp; S[i]&lt;=<span class="string">'z'</span>)</span><br><span class="line">      hashID = hashID*<span class="number">52</span> + S[i]-<span class="string">'a'</span>+ <span class="number">26</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id = hashFunc(P[i],<span class="number">52</span>);</span><br><span class="line">hashTable[id] = P[i];</span><br></pre></td></tr></table></figure><h3 id="查询N个字符串中M个字符串出现的次数，每个字符串长度固定为5"><a href="#查询N个字符串中M个字符串出现的次数，每个字符串长度固定为5" class="headerlink" title="查询N个字符串中M个字符串出现的次数，每个字符串长度固定为5"></a>查询N个字符串中M个字符串出现的次数，每个字符串长度固定为5</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">char</span> S[maxn][<span class="number">5</span>],temp[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> hashTable[<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个字符串拥有唯一id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    id = id*<span class="number">26</span> + (S[i]-<span class="string">'A'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sacnf(<span class="string">"%s"</span>, S[i]);</span><br><span class="line">    <span class="keyword">int</span> id  = hashFunc(s[i], <span class="number">3</span>);</span><br><span class="line">    hashTable[id]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sacnf(<span class="string">"%s"</span>,temp);</span><br><span class="line">    <span class="keyword">int</span> id = hashFunc(temp, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,hashTable[id]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-散列基础-&lt;br&gt;散列（hash）是常用的算法思想之一，它使用空间换时间的思想在我第一次碰到时就感觉巧妙如魔法一般。特别是在进行一些大量数字和字符串比较方面，hash能瞬间将O(n^2)的复杂度降到O(n),单次查询的复杂度降到O(1)，靠的就是数组下标与查询的元素之间建立的唯一转换关系。&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Autonomous Vehicles translate -- datasets &amp; bechmarks</title>
    <link href="https://hyqskevin.github.io/2019/03/18/datasets-benchmarks/"/>
    <id>https://hyqskevin.github.io/2019/03/18/datasets-benchmarks/</id>
    <published>2019-03-17T16:03:14.000Z</published>
    <updated>2019-03-18T04:31:51.888Z</updated>
    
    <content type="html"><![CDATA[<p>Computer Vision for Autonomous Vehicles:<br>Problems, Datasets and State-of-the-Art<br>自动驾驶技术的计算机视觉：问题，数据和前沿技术<br><strong>数据集和基准</strong></p><a id="more"></a><h2 id="datasets-amp-Benchmarks-数据集和基准"><a href="#datasets-amp-Benchmarks-数据集和基准" class="headerlink" title="datasets &amp; Benchmarks 数据集和基准"></a>datasets &amp; Benchmarks 数据集和基准</h2><ul><li><p>Datasets have played a key role in the progress of many research fields by providing problem specific examples with ground truth. They allow quantitative evaluation of approaches providing key insights about their capacities and limitations. |In particular, several of these datasets Geiger et al. (2012b); Scharstein &amp; Szeliski (2002); Baker et al. (2011); Everingham et al. (2010); Cordts et al. (2016) also provide online evaluation servers which allow for a fair comparison on held-out test sets and provide researchers in the field an up-to-date overview over the state-of-the-art. |This way, current progress and remaining challenges can be easily identified by the research community. In the context of autonomous vehicles, the KITTI dataset Geiger et al. (2012b) and the Cityscapes dataset Cordts et al.(2016) have introduced challenging benchmarks for reconstruction, motion estimation and recognition tasks, and contributed to closing the gap between laboratory settings and challenging real-world situations. |Only a few years ago, datasets with a few hundred annotated examples were considered sufficient for many problems. The introduction of datasets with many hundred to thousands of labeled examples, however, has led to spectacular breakthroughs in many computer vision disciplines by training high-capacity deep models in a supervised fashion. |However, collecting a large amount of annotated data is not an easy endeavor, in particular for tasks such as optical flow or semantic segmentation. This initiated a collective effort to produce that kind of data in several areas by searching for ways to automate the process as much as possible such as through semi-supervised learning or synthesization.</p></li><li><p>数据集在许多研究领域进展方面发挥了关键作用，提供了真实的(ground truth)问题特例。它们允许通过提供有关其能力与局限的核心信息，数据集还可以对方法进行量化评估。</p></li><li>特别地，这些数据集中的几个比如Geiger（2012b）;Scharstein＆Szeliski（2002）; Baker（2011）;Everinghamet al（2010）; Cordts（2016）也提供在线评估服务器允许在延期测试（held-out）中进行公平的比较，而且为该领域的研究人员提供更新的目前最好的算法。</li><li>这种方式可以让研究团队很容易地确定目前的进展和剩下的挑战。在自主车辆的环境中，KITTI数据集Geiger（2012b）和Cityscapes数据集Cordts （2016）为重建、运动估计和识别任务引入了挑战性的基准，因此缩小了实验室设置与挑战现实世界的情况之间的差距。</li><li>几年前，有数百个注释例子的数据集对于解决很多问题是足够的。然而，有数百到数千个有标签的例子的数据集的引入，通过以监督的方式训练大容量深度模型，已经使得许多计算机视觉学科的重大突破。</li><li>然而，收集大量的注释数据不是一个容易的事情，特别是对于诸如光流或者语义分割的任务。这使得集体努力通过搜索尽可能多的方式来自动化过程，例如通过半监督学习或合成，从而在多个领域产生了这种数据。</li></ul><h4 id="Real-World-Datasets-真实数据集"><a href="#Real-World-Datasets-真实数据集" class="headerlink" title="Real-World Datasets 真实数据集"></a>Real-World Datasets 真实数据集</h4><ul><li>While several algorithmic aspects can be inspected using synthetic data, real-world datasets are necessary to guarantee performance of algorithms in real situations. For example, algorithms employed in practice need to handle complex objects and environments while facing challenging environmental conditions such as direct lighting, reflections from specular surfaces, fog or rain. The acquisition of ground truth is often labor intensive because very often this kind of information cannot be directly obtained with a sensor but requires tedious manual annotation. |For example, (Scharstein &amp; Szeliski (2002),Baker et al. (2011)) acquire dense pixel-level annotations in a controlled lab environment whereas Geiger et al. (2012b); Kondermann et al. (2016) provide sparse pixel-level annotations of real street scenes using a LiDAR laser scanner.</li><li><p>Recently, crowdsourcing with Amazon’s Mechanical Turk9 have become very popular to create annotations for large scale datasets, e.g., Deng et al. (2009); Lin et al. (2014); Leal-Taix´e et al. (2015); Milan et al. (2016). However, the annotation quality obtained via Mechanical Turk is often not sufficient to be considered as reference and significant efforts in post-processing and cleaning-up the obtained labels is typically required. |In the following, we will first discuss the most popular computer vision datasets and benchmarks addressing tasks relevant to autonomous vision. Thereafter, we will focus on datasets particularly dedicated to autonomous vehicle applications.</p></li><li><p>虽然可以使用合成数据检查几个算法方面，但实际数据集对于确保算法在实际情况下的性能是必要的。例如，在实践中使用的算法需要处理复杂的对象和环境，同时面对挑战性的环境条件，例如直接照明，镜面反射，雾或雨。获取ground truth通常是劳动密集型的，因为这种信息通常不能用传感器直接获得，而是需要繁琐的手动注释。</p></li><li>例如，（Scharstein＆Szeliski（2002），Baker（2011））在受控实验室环境中获得了密集的像素级注释，而Geiger等人（2012B）; Kondermann等人（2016）使用LiDAR激光扫描仪提供实际街景场景的稀疏像素级注解。</li><li>最近，亚马逊的Mechanical Turk的众包已经变得非常受欢迎，为大型数据集创建注释，例如Deng（2009）;Lin（2014）; Leal-Taix’e（2015）; Milan（2016）。然而，通过Mechanical Turk获得的注释质量通常不太合适被认为是参考，并且通常需要在后处理中最初的重大努力和清理所获得的标签中也是非常需要的。</li><li><p>在下文中，我们将首先讨论最流行的计算机视觉数据集和基准，以解决与自主视觉相关的任务。此后，我们将专注于数据集，尤其致力于自动驾驶车辆的应用。</p></li><li><p><strong>Stereo and 3D Reconstruction</strong>: The Middlebury stereo benchmark introduced by Scharstein &amp; Szeliski (2002) provides several multi-frame stereo data sets for comparing the performance of stereo matching algorithms. |Pixel-level ground truth is obtained by hand labeling and reconstructing planar components in piecewise planar scenes. Scharstein &amp; Szeliski (2002) further provide a taxonomy of stereo algorithms that allows the comparison of design decisions and a test bed for quantitative evaluation. |Approaches submitted to their benchmark website are evaluated using the root mean squared error and the percentage of bad pixels between the estimated and ground truth disparity maps.</p></li><li>Scharstein &amp; Szeliski (2003) and Scharstein et al. (2014) introduced novel datasets to the Middlebury benchmark comprising more complex scenes and including ordinary objects like chairs, tables and plants. In both works a structured lighting system was used to create ground truth. |For the latest version Middlebury v3, Scharstein et al. (2014) generate highly accurate ground truth for high-resolution stereo images with a novel technique for 2D subpixel correspondence search and self-calibration of cameras as well as projectors. This new version achieves significantly higher disparity and rectification accuracy than those of existing datasets and allows a more precise evaluation. An example depth map from the dataset is illustrated in Figure 1.</li><li><p>The Middlebury multi-view stereo (MVS) benchmark11 by Seitz et al. (2006) is a calibrated multi-view image dataset with registered ground truth 3D models for the comparison of MVS approaches. The benchmark played a key role in the advances of MVS approaches but is relatively small in size with only two scenes. |In contrast, the TUD MVS dataset12 by Jensen et al. (2014) provides 124 different scenes that were also recorded in controlled laboratory environment. Reference data is obtained by combining structured light scans from each camera position and the resulting scans are very dense, each containing 13.4 million points on average. For 44 scenes the full 360 degree model was obtained by rotation and scanning four times with 90 degree intervals. In contrast to the datasets so far, Sch¨ops et al. (2017) provide scenes that are not carefully staged in a controlled laboratory environment and thus represent real world challenges. Sch¨ops et al. (2017) recorded high-resolution DSLR imagery as well as synchronized low-resolution stereo videos in a variety of indoor and outdoor scenes. A high-precision laser scanner allows to register all images with a robust method. The high-resolution images enable the evaluation of detailed 3D reconstruction while the low-resolution stereo images are provided to compare approaches for mobile devices.</p></li><li><p>立体与 3D 重建类数据集：由Scharstein＆Szeliski（2002）引入的Middlebury立体声基准测试仪提供了多个立体声数据集，用于比较立体匹配算法的性能。</p></li><li>通过在分段平面场景中手工标记和重建平面构成获得像素级地面真值。Scharstein和Szeliski（2002）进一步提供立体声算法的分类法，允许通过比较设计决策和测试台来进行定量评估。</li><li>使用均方误差以及估计值和地面真实视差图之间坏像素的百分比来评估提交给其基准网站的方法。</li><li>Scharstein &amp; Szeliski (2003) 和 Scharstein et al. (2014)为Middlebury基准引入了一种新颖的数据集，这个数据及包含更多复杂的场景和普通的物体，比如椅子、桌子、植物等对象。在这两个工作中，均使用一个结构化的照明系统来创造地面实况。</li><li><p>对于最新版本的Middlebury v3，Scharstein（2014）采用新颖的2D子像素对应搜索和相机自动校准技术以及投影机为高分辨率立体图像生成高精度的地面实况。与现有数据集相比，该新版本的差异和整改精度明显提高，可以进行更精确的评估。 Figure 1是来自数据集的示例深度图：<br>Seitz等人的Middlebury多视点立体声（MVS）基准测试（2006）是注册地面真相3D模型用于比较MVS方法一种校准的多视图图像数据集。基准测试在MVS方法的进步中发挥了关键作用，但只有两个场景，尺寸相对较小。相比之下，Jensen等人的TUD MVS数据集（2014年）提供了124个不同的场景，这些场景也被记录在受控实验室环境中。 参考数据通过组合来自每个摄像机位置的结构光扫描获得，并且所得到的扫描非常密集，平均每个包含13.4million个点。对于44个场景，通过以90度的间隔旋转和扫描四次获得完整的360度模型。 与迄今为止的数据集相比，Sch¨ops等人（2017年）提供了在受控实验室环境中未仔细分级的场景，从而代表了现实世界的挑战。Sch¨ops et al. (2017) 录制了高分辨率DSLR单反相机图像以及各种室内和室外场景中同步的低分辨率立体视频。 高精度激光扫描仪允许以强大的方法注册所有图像。高分辨率图像可以评估详细的3D重建，同时提供低分辨率立体图像来比较移动设备的方法。</p></li><li><p><strong>Optical Flow</strong>: The Middlebury flow benchmark13 by Baker et al. (2011) provides sequences with non-rigid motion, synthetic sequences and a subset of the Middlebury stereo benchmark sequences (static scenes) for the evaluation of optical flow methods. For all non-rigid sequences, ground truth flow is obtained by tracking hidden fluorescent textures sprayed onto the objects using a toothbrush. The dataset comprises eight different sequences with eight frames each. Ground truth is provided for one pair of frames per sequence.</p></li><li>Besides the limited size, real world challenges like complex structures, lighting variation and shadows are missing as the dataset necessitates laboratory conditions which allow for manipulating the light source between individual captures. In addition, it only comprises very small motions of up to twelve pixels which do not admit the investigation of challenges provided by fast motions. Compared to other datasets, however, the Middlebury dataset allows to evaluate sub-pixel precision since it provides very accurate and dense ground truth. Performance is measured using the angular error (AEE) and the absolute end point error (EPE) between the estimated flow and the ground truth.</li><li>Janai et al. (2017) present a novel optical flow dataset comprising of complex real world scenes in contrast to the laboratory setting in Middlebury. High-speed video cameras are used to create accurate reference data by tracking pixel through densely sampled space-time volumes. This method allows to acquire optical flow ground truth in challenging everyday scenes in an automatic fashion and to augment realistic effects such as motion blur to compare methods in varying conditions. Janai et al. (2017) provide 160 diverse real-world sequences of dynamic scenes with a significantly larger resolution (1280X1024 Pixels) than previous optical datasets and compare several state of-the-art optical techniques on this data.</li></ul><p>光流类数据集：Baker等人的“Middlebury流量标准” （2011）提供了具有非刚性运动序列，合成序列和Middlebury立体声基准序列（静态场景）的子集的序列，用于评估光流方法。 对于所有非刚性序列，通过使用toothbrush牙刷追踪在物体上喷洒的隐藏的荧光纹理来获得地面真实流。 数据集包含八个不同的序列，每个序列具有八个帧。 每个序列提供一对帧的地面实况。<br>除了有限的大小之外，由于数据集需要实验室条件，允许在各个捕获之间操纵光源，所以缺少像复杂结构，照明变化和阴影这样的真实世界挑战。 此外，它只包含最多十二个像素的非常小的运动，不承认对快速运动提供的挑战的调查。 然而，与其他数据集相比，Middlebury数据集可以评估子像素精度，因为它提供了非常精确和密集的地面实例。 使用角度误差（AEE）和估计流量与地面实数之间的绝对终点误差（EPE）来测量性能。<br>Janai等人 （2017）提出了一个新颖的光流数据集，其中包括复杂的现实世界场景，与Middlebury的实验室设置相反。 高速视频摄像机用于通过密集采样的时空容量跟踪像素来创建精确的参考数据。 该方法允许以自动方式在挑战性的日常场景中获取光流场地真相，并且增加诸如运动模糊的现实效果以在不同条件下比较方法。  Janai等人 （2017年）提供了160个不同的现实世界动态场景序列，具有比以前的光学数据集显着更大的分辨率（1280x1024像素），并比较了这些数据的几种最先进的光学技术。</p><ul><li><strong>Object Recognition and Segmentation</strong>: The availability of large-scale, publicly available datasets such as ImageNet (Denget al. (2009)), PASCAL VOC (Everingham et al. (2010)), Microsoft COCO (Lin et al.(2014)), Cityscapes (Cordts et al.(2016)) and TorontoCity (Wang et al. (2016)) have had a major impact on the success of deep learning in object classification, detection, and semantic segmentation tasks.</li><li>The PASCAL Visual Object Classes (VOC) challenge14 by Everingham et al. (2010) is a benchmark for object classification, object detection, object segmentation and action recognition. It consists of challenging consumer photographs collected from Flickr with high quality annotations and contains large variability in pose, illumination and occlusion. Since its introduction, the VOC challenge has been very popular and was yearly updated and adapted to the needs of the community until the end of the program in 2012. Whereas the first challenge in 2005 had only 4 different classes, 20 dierent object classes<br>were introduced in 2007. Over the years, the benchmark grew in size reaching a total of 11,530 images with 27,450 ROI annotated objects in 2012.</li><li><p>In 2014, Lin et al. (2014) introduced the Microsoft COCO dataset15 for the object detection, instance segmentation and contextual reasoning. They provide images of complex everyday scenes containing common objects in their natural context. The dataset comprises 91 object classes, 2.5 million annotated instances and 328k images in total. Microsoft COCO is significantly larger in the number of instances per class than the PASCAL VOC object segmentation benchmark. All objects are annotated with per-instance segmentations in an extensive crowd worker effort. Similar to PASCAL VOC, the intersection-overunion metric is used for evaluation.</p></li><li><p>对象识别与分割类数据集：大量的公开数据集，如ImageNet（Deng等人（2009）），PASCAL VOC（Everingham等（2010）），Microsoft COCO（Lin等人（2014）），Cityscapes（Cordts （2016））和TorontoCity（Wang等人（2016年））对物体分类，目标检测和语义分割任务中深入学习的成功产生了重大影响。</p></li><li>由Everingham等人（2010）提供的PASCAL视觉对象类（VOC）挑战是对象分类，物体检测，物体分割和动作识别的基准。它由具有高质量标注的Flickr收集的有挑战性的消费者照片组成，并且包含姿势，照明和遮挡的大变化。 自从介绍以来，VOC的挑战一直很受欢并且逐年更新并适应社区的需求直到2012年计划结束。而2005年的第一个挑战只有4个不同的类，2007年引入了20个不同的对象类。多年来，基准规模在2012年达到总共11,530张图像当中共有27,450张ROI注释物体。</li><li><p>2014年，Lin等 （2014）介绍了Microsoft COCO数据集，用于物体检测，实例分割和上下文推理。 它们在自然环境中提供包含常见对象的复杂日常场景的图像。 数据集总共包括91个对象类，250万个注释实例和328k个图像。 Microsoft COCO在PASCAL VOC对象分割基准测试中每个类的实例数显著增加。 所有物体都在广泛的人群工作人员的努力下对每个实例进行标注。 与PASCAL VOC类似，IOU度量用于评估。</p></li><li><p><strong>Tracking</strong>: Leal-Taix´e et al. (2015); Milan et al. (2016) present the MOTChallenge16 which addresses the lack of a centralized benchmark for multi object tracking. The benchmark contains 14 challenging video sequences in unconstrained environments filmed with static and moving cameras and subsumes many existing multi-object tracking benchmarks such as PETS (Ferryman &amp; Shahrokni (2009)) and KITTI (Geiger et al.(2012b)). The annotations for three object classes are provided: moving or standing pedestrians, people that are not in an upright position and others. They use the two popular tracking measures, Multiple Object Tracking Accuracy (MOTA) and Multiple Object Tracking Precision (MOTP) introduced by Stiefelhagen et al. (2007) for the evaluation of the approaches. Detection ground truth provided by the authors allows to analyze the performance of tracking systems independent of a detection system. Methods using a detector and methods using the detection ground truth can be compared separately on their website. - Aerial Image Datasets: The ISPRS benchmark17 (Rottensteiner et al. (2013, 2014)) provides data acquired by airborne sensors for urban object detection and 3D building reconstruction and segmentation. It consists of two datasets: Vaihingen and Downtown Toronto. The object classes considered in the object detection task are building, road, tree, ground, and car. The Vaihingen dataset provides three areas with various object classes and a large test site for road detection algorithms. The Downtown Toronto dataset covers an area of about 1.45 km2 in the central area of Toronto, Canada. Similarly to Vaihingen, there are two smaller areas for object extraction and building reconstruction, as well as one large area for road detection. For each test area, aerial images with orientation parameters, digital surface model (DSM), orthophoto mosaic and airborne laser scans are provided. The quality of the approaches is assessed using several metrics for detection and reconstruction. In both cases completeness, correctness and quality is assessed on a per-area level and a per-object level.</p></li><li><p>追踪：Leal-Taix’e（2015），Milan（2016）提出了MOTChallenge16，解决了多对象跟踪缺乏集中的基准。该基准测试包含14个具有静态和移动摄像机拍摄的无约束环境的挑战性视频序列，并包含许多现有的多对象跟踪基准，如PETS（Ferryman＆Shahrokni（2009））和KITTI（Geiger等（2012b））。提供三个对象类的注释：移动或站立的行人，不在直立位置的人等。他们使用Stiefelhagen等人介绍的两个流行的跟踪措施，多目标跟踪精度（MOTA）和多对象跟踪精度（MOTP）。 （2007）评估方法。作者提供的检测基准真实性可以分析独立于检测系统的跟踪系统的性能。使用检测器的方法和使用检测基准的方法可以在其网站上单独进行比较。 - 空中图像数据集：ISPRS benchmark17（Rottensteiner等（2013，2014））提供了用于城市物体检测和3D建筑重建和分割的机载传感器获取的数据。它包括两个数据集：Vaihingen和多伦多市区。对象检测任务中考虑的对象类是建筑，道路，树木，地面和汽车。 Vaihingen数据集提供了三个不同对象类别的区域和一个用于道路检测算法的大型测试站点。多伦多市中心数据集在加拿大多伦多的中部地区面积约1.45平方公里。与Vaihingen类似，有两个较小的对象提取和建筑重建区域，以及一个大面积的道路检测。对于每个测试区域，提供具有取向参数，数字表面模型（DSM），正射影像马赛克和机载激光扫描的航空图像。使用检测和重建的几个度量来评估方法的质量。在这两种情况下，完整性，正确性和质量都在每个面积水平和每个物体水平上进行评估。</p></li><li><p><strong>Autonomous Driving</strong>: In 2012, Geiger et al. (2012b, 2013) have introduced the KITTI Vision Benchmark18 for stereo, optical flow, visual odometry/SLAM and 3D object detection (Figure). The dataset has been captured from an autonomous driving platform and comprises six hours of recordings using high-resolution color and grayscale stereo cameras, a Velodyne 3D laser scanner and high-precision GPS/IMU inertial navigation system. The stereo and optical flow benchmarks derived from this dataset comprise 194 training and 195 test image pairs at a resolution of 1280  376 pixels and sparse ground truth obtained by projecting accumulated 3D laser point clouds onto the image. Due to the limitations of the rotating laser scanner used as reference sensor, the stereo and optical flow benchmark is restricted to static scenes with camera motion.</p></li><li>To provide ground truth motion fields for dynamic scenes, Menze &amp; Geiger (2015) have annotated 400 dynamic scenes, fitting accurate 3D CAD models to all vehicles in motion in to order to obtain flow and stereo ground truth for these objects. The KITTI flow and stereo benchmarks use the percentage of erroneous (bad) pixels to assess the performance of the submitted methods. Additionally, Menze &amp; Geiger (2015) combined the stereo and flow ground truth to form a novel 3D scene flow benchmark. For evaluating scene flow, they combine classical stereo and optical flow measures.</li><li>The visual odometry / SLAM challenge consists of 22 stereo sequences, with a total length of 39.2 km. The ground truth pose is obtained using GPS/IMU localization unit which was fed with RTK correction signals. The translational and rotational error averaged over a particular trajectory length is considered for evaluation.</li><li>For the KITTI object detection challenge, a special 3D labeling tool has been developed to annotate all 3D objects with 3D bounding boxes for 7481 training and 7518 test images. The benchmark for the object detection task was separated into a vehicle, pedestrian and cyclist detection tasks, allowing to focus the analysis on the most important problems in the context of autonomous vehicles. Following PASCAL VOC Everingham et al. (2010), the intersection-over-union (IOU) metric is used for evaluation. For an additional evaluation, this metric has been extended to capture both 2D detection and 3D orientation estimation performance. A true 3D evaluation is planned to be released shortly.</li><li><p>The KITTI benchmark was extended by Fritsch et al. (2013) to the task of road/lane detection. In total, 600 diverse training and test images have been selected for manual annotation of road and lane areas. Mattyus et al. (2016) used aerial images to enhance the KITTI dataset with fine grained segmentation categories such as parking spots and sidewalk as well as the number and location of road lanes. The KITTI dataset has established itself as one of the standard benchmarks in all of the aforementioned tasks, in particular in the context of autonomous driving applications.</p></li><li><p>2012年，Geiger等（2012b，2013）推出了用于立体声，光流，视觉测距/ SLAM和3D物体检测的KITTI Vision Benchmark18（图）。数据集已从自主驾驶平台捕获，包括使用高分辨率彩色和灰度立体相机的六小时录音，Velodyne 3D激光扫描仪和高精度GPS / IMU惯性导航系统。从该数据集派生的立体声和光流基准测试包括194次训练和195个测试图像对，分辨率为1280？通过将累积的3D激光点云投影到图像上获得的376个像素和稀疏的地面真实。由于用作参考传感器的旋转激光扫描仪的局限性，立体声和光学流量基准仅限于具有摄像机运动的静态场景。</p></li><li>为了为动态场景提供地面真相运动场，Menze＆Geiger（2015）已​​经注明了400个动态场景，将精确的3D CAD模型适用于所有运动的车辆，以获得这些物体的流动和立体声地面实况。 KITTI流量和立体声基准使用错误（不良）像素的百分比来评估提交的方法的性能。此外，Menze＆Geiger（2015）结合了立体声和流动地面的真相，形成了一种新颖的3D场景流动基准。为了评估场景流，它们结合了古典立体声和光学流量测量。</li><li>视觉测距/ SLAM挑战包括22个立体声序列，总长39.2公里。使用馈送有RTK校正信号的GPS / IMU定位单元获得地面真实姿势。考虑在特定轨迹长度上平均的平移和旋转误差进行评估。</li><li>对于KITTI对象检测挑战，已经开发了一种特殊的3D标签工具，用于通过3D边界框注释所有3D对象，用于7481个训练和7518个测试图像。物体检测任务的基准被分为车辆，行人和骑车人员检测任务，允许将分析集中在自主车辆的上下文中最重要的问题。按照PASCAL VOC Everingham等（2010），交叉联合（IOU）度量用于评估。为了进一步评估，该指标已扩展到捕获2D检测和3D定向估计性能。计划即将发布真正的3D评估。</li><li><p>由Fritsch等人扩展了KITTI基准。 （2013年）到道路/车道检测任务。总共选择了600多种不同的训练和测试图像，用于手动注释道路和车道区域。 Mattyus等人（2016）使用航空图像来增强KITTI数据集，并提供诸如停车位和人行道之类的细粒度细分类别，以及道路的数​​量和位置。 KITTI数据集已经成为所有上述任务的标准基准之一，特别是在自主驾驶应用的上下文中。</p></li><li><p>Complementary to other datasets, the HCI benchmark19 proposed in Kondermann et al. (2016) specifically includes realistic, systematically varied radiometric and geometric challenges. Overall, a total of 28,504 stereo pairs with stereo and flow ground truth is provided. In contrast to previous datasets, ground truth uncertainties have been estimated for all static regions. The uncertainty estimate is derived from pixel-wise error distributions for each frame which are computed based on Monte Carlo sampling. Dynamic regions are manually masked out and annotated with approximate ground truth for 3,500 image pairs.</p></li><li>The major limitation of this dataset is that all sequences were recorded in a single street section, thus lacking diversity. On the other hand, this enabled better control over the content and environmental conditions. In contrast to the mobile laser scanning solution of KITTI, the static scene is scanned only once using a high-precision laser scanner in order to obtain a dense and highly accurate ground truth of all static parts. Besides the metrics used in KITTI and Middlebury, they use semantically meaningful performance metrics such as edge fattening and surface smoothness for evaluation Honauer et al. (2015). The HCI benchmark is rather new and not established yet but the controlled environment allows to simulate rarely occurring events such as accidents which are of great interest in the evaluation of autonomous driving systems.</li><li>The Caltech Pedestrian Detection Benchmark20 proposed by Dollar et al. (2009) provides 250,000 frames of sequences recorded by a vehicle while driving through regular traffic in an urban environment. 350,000 bounding boxes and 2,300 unique pedestrians were annotated including temporal correspondence between bounding boxes and detailed occlusion labels. Methods are evaluated by plotting the miss rate against false positives and varying the threshold on detection confidence.</li><li>The Cityscapes Dataset21 by Cordts et al. (2016) provides a benchmark and large-scale dataset for pixel-level and instancelevel semantic labeling that captures the complexity of realworld urban scenes. It consists of a large, diverse set of stereo video sequences recorded in streets of different cities. High quality pixel-level annotations are provided for 5,000 images while 20,000 additional images have been annotated with coarse labels obtained using a novel crowd sourcing platform. For two semantic granularities, i.e., classes and categories, they report mean performance scores and evaluate the intersection-overunion metric at instance-level to assess how well individual instances are represented in the labeling.</li><li><p>The TorontoCity benchmark presented byWang et al. (2016) covers the greater Toronto area with 712 km2 of land, 8,439 km of road and around 400,000 buildings. The benchmark covers a large variety of tasks including building height estimation (reconstruction), road centerline and curb extraction, building instance segmentation, building contour extraction, semantic labeling and scene type classification. The dataset was captured from airplanes, drones, and cars driving around the city to provide different perspectives.</p></li><li><p>与其他数据集的补充，在Kondermann等人提出的HCI基准19。 （2016）具体包括现实的，有系统地变化的辐射和几何挑战。总的来说，共提供了28,504立体声和流动地面真相的立体声对。与以前的数据集相比，所有静态区域的地面真实不确定度已被估计。不确定性估计是根据基于蒙特卡洛取样计算的每个帧的像素误差分布得出的。手动屏蔽动态区域并用3,500个图像对的近似地面实例进行注释。</p></li><li>这个数据集的主要限制是所有序列记录在单个街区，因此缺乏多样性。另一方面，这能够更好地控制内容和环境条件。与KITTI的移动激光扫描解决方案相比，静态场景仅使用高精度激光扫描仪扫描一次，以获得所有静态部件的致密和高精度的地面实况。除了KITTI和Middlebury使用的指标之外，他们使用语义有意义的性能指标，如边缘育肥和表面平滑度评估Honauer等。 （2015年）。 HCI基准相当新，尚未建立，但受控环境允许模拟很少发生的事件，例如对自主驾驶系统的评估感兴趣的事故。</li><li>美国加州大学提出的Caltech行人检测基准20 （2009）提供了车辆记录的25万帧序列，同时在城市环境中经常进行交通。包括350,000个边界框和2,300个独特的行人，包括边界框和详细遮挡标签之间的时间对应关系。通过绘制误差率与误报率并在检测置信度上改变阈值来评估方法。</li><li>由Cordts等人的Cityscapes Dataset21 （2016）为像素级和实例级语义标注提供了基准和大型数据集，捕捉到现实城市场景的复杂性。它由不同城市的街道上记录的大型，多样化的立体视频序列组成。为5,000张图像提供了高质量的像素级注释，而使用新颖的人群采购平台获得的粗略标签已经注明了20,000张附加图像。对于两个语义粒度，即类别和类别，他们报告平均绩效评分，并评估实例级别的交叉点平均度量，以评估在标签中表示个体实例的程度。</li><li><p>Wang等人提出的多伦多城市基准（2016年）覆盖多伦多地区，712平方公里的土地，8,439公里的道路和大约40万个建筑物。该基准涵盖了建筑高度估计（重建），道路中心线和路缘提取，建筑物实例分割，建筑轮廓提取，语义标注和场景类型分类等各种任务。数据集被从飞机，无人驾驶飞机和汽车驾驶在城市周围捕获，以提供不同的观点。</p></li><li><p><strong>Long-Term Autonomy</strong>: Several datasets such as KITTI or Cityscapes focus on the development of algorithmic competences for autonomous driving but do not address challenges of long-term autonomy, as for examples environmental changes over time. To address this problem, a novel dataset for autonomous driving has been presented by Maddern et al. (2016). They collected images, LiDAR and GPS data while traversing 1,000 km in central Oxford in the UK during one year. This allowed them to capture large variations in scene appearance due to illumination, weather and seasonal changes, dynamic objects, and constructions. Such long-term datasets allow for in-depth investigation of problems that detain the realization of autonomous vehicles such as localization in different times of the year.</p></li><li><p>长期自动：几个数据集，如KITTI或Cityscapes，着重于开发自主驾驶的算法能力，但不能解决长期自主的挑战，例如随着时间的推移环境变化。 为了解决这个问题，Maddern等人提出了一个用于自主驾驶的新型数据集。（2016）。 他们在一年内在英国牛津中心穿过1000公里的地方收集图像，LiDAR和GPS数据。 这允许他们捕获由于照明，天气和季节变化，动态对象和结构而导致的场景外观的大变化。 这些长期数据集允许深入调查在一年中的不同时期扣留自主车辆的实现问题，例如本地化。</p></li></ul><h4 id="Synthetic-Data"><a href="#Synthetic-Data" class="headerlink" title="Synthetic Data"></a>Synthetic Data</h4><ul><li><p>The generation of ground truth for real examples is very labor intensive and often not even possible at large scale when pixel-level annotations are required. On the other hand, pixel-level ground truth for large-scale synthetic datasets can be easily acquired. However, the creation of realistic virtual world is time-consuming. The popularity of movies and video games have led to an industry creating very realistic 3D content which nourishes the hope to replace real data completely using synthetic datasets. Consequently, several synthetic datasets have been proposed, recently, but it remains an open question whether the realism and variety attained is sufficient to replace real world datasets. Besides, creating realistic virtual content is a time consuming and expensive process itself and the trade-off between real and synthetic (or augmented) data is not clear yet.</p></li><li><p>为真实的例子生成地面真相是非常劳动密集型的，并且在需要像素级注释时通常甚至不可能大规模地实现。 另一方面，可以轻松获取大规模合成数据集的像素级地面实况。 然而，创造现实的虚拟世界是耗时的。 电影和视频游戏的普及导致了行业创造了非常逼真的3D内容，这些内容丰富了使用合成数据集完全替代实际数据的希望。 因此，最近已经提出了几个合成数据集，但是现实主义和品种是否足以替代现实世界数据集仍然是一个悬而未决的问题。 此外，创建逼真的虚拟内容是一个耗时且昂贵的过程本身，真实和合成（或增强）数据之间的权衡尚不清楚。</p></li><li><p><strong>MPI Sintel</strong>: The MPI Sintel Flow benchmark22 presented by Butler et al. (2012) takes advantage of the open source movie Sintel, a short animated film, to render scenes of varying complexity with optical flow ground truth. In total, Sintel comprises 1,628 frames. Different datasets obtained using different passes of the rendering pipeline vary in complexity shown in Figure 3. The albedo pass has roughly piecewise constant colors without illumination effects while the clean pass introduces illumination of various kinds. The final pass adds atmospheric effects, blur, color correction and vignetting. In addition to the average endpoint error, the benchmark website provides different rankings of the methods based on speed, occlusion boundaries, and disocclusions.</p></li><li><strong>Flying Chairs and Flying Things</strong>: The limited size of optical flow datasets hampered the training of deep high-capacity models. To train a convolutional neural network, Dosovitskiy et al.(2015) thus introduced a simple synthetic 2D dataset of flying chairs rendered on top of random background images from Flickr. As the limited realism and size of this dataset proved insufficient to learn highly accurate models, Mayer et al. (2016) presented another large-scale dataset consisting of three synthetic stereo video datasets: FlyingThings3D, Monkaa, Driving. FlyingThings3D provides everyday 3D objects flying along randomized 3D trajectories in a randomly created scene. Inspired by the KITTI dataset a driving dataset has been created which uses car models from the same pool as FlyingThings3D and additionally highly detailed tree and building models from 3D Warehouse. Monkaa is an animated short movie similar to Sintel used in the MPI Sintel benchmark.</li><li><p><strong>Game Engines</strong>: Unfortunately, data from animated movies is very limited since the content is hard to change and such movies are rarely open source. In contrast, game engines allow for creating an infinite amount of data. One way to create virtual worlds using a game engine is presented by Gaidon et al. (2016) which introduces the Virtual KITTI dataset23. They present an efficient real-to-virtual world cloning method to create realistic proxy worlds. A cloned virtual world allows to vary conditions such as weather or illumination and to use different camera settings. This way, the proxy world can be used for virtual data augmentation to train deep networks. Virtual KITTI contains 35 photo-realistic synthetic videos with a total of 17,000 high resolution frames. They provide ground truth for object detection, tracking, scene and instance segmentation, depth and optical flow.</p></li><li><p>MPI Sintel ：由Butler等人提出的MPI Sintel Flow benchmark22 （2012）利用开源电影Sintel（短片动画），以光流地面的真相呈现不同复杂度的场景。总共有Sintel包括1,628帧。使用不同渲染流程获得的不同数据集的复杂度如图3所示。反照率传递具有大致分段恒定颜色，无照明效果，而清洁通道则引入各种照明。最后的通行证增加了大气效果，模糊，颜色校正和渐晕。除了平均终点误差之外，基准网站还提供了基于速度，遮挡边界和不相关的方法的不同排名。</p></li><li>飞行椅和飞行事物：光流数据集的数量有限，妨碍了深层大容量模型的训练。为了训练卷积神经网络，Dosovitskiy等人（2015）引入了一个简单的合成2D数据集，它们呈现在Flickr的随机背景图像之上。由于该数据集的有限现实性和大小证明不足以学习高精度模型，Mayer等（2016）提出了另外一个由三个合成立体视频数据集组成的大型数据集：FlyingThings3D，Monkaa，Driving。 FlyingThings3D在随机创建的场景中提供随机3D轨迹飞行的每天3D对象。受KITTI数据集的启发，已经创建了一个驱动数据集，它使用与FlyingThings3D相同的池中的汽车模型，以及来自3D Warehouse的另外高度详细的树和建筑模型。 Monkaa是一个类似于Sintel的动画短片，用于MPI Sintel基准测试。</li><li><p>游戏引擎：不幸的是，动画电影的数据非常有限，因为内容很难改变，这样的电影很少是开源的。相比之下，游戏引擎允许创建无限量的数据。 Gaidon等人提出了使用游戏引擎创建虚拟世界的一种方式。 （2016）介绍了虚拟KITTI数据集23。他们提出了一种高效的实时虚拟世界克隆方法来创建现实的代理世界。克隆的虚拟世界允许改变诸如天气或照明的条件，并使用不同的相机设置。这样，代理世界可以用于虚拟数据扩充来训练深层网络。虚拟KITTI包含35张照片合成视频，总共17,000个高分辨率帧。它们为物体检测，跟踪，场景和实例分割，深度和光流提供了基础。</p></li><li><p>In concurrent work, Ros et al. (2016) created SYNTHIA24, a synthetic collection of Imagery and Annotations of urban scenarios for semantic segmentation. They rendered a virtual city with the Unity Engine. The dataset consists of 13,400 randomly taken virtual images from the city and four video sequences with 200,000 frames in total. Pixel-level semantic annotations are provided for 13 classes.</p></li><li><p>Richter et al. (2016) have extracted pixel-accurate semantic label maps for images from the commercial video game Grand Theft Auto V. Towards this goal, they developed a wrapper which operates between the game and the graphics hardware to obtain pixel-accurate object signatures across time and instances. The wrapper allows them to produce dense semantic annotations for 25 thousand images synthesized by the photorealistic open-world computer game with minimal human supervision. However, for legal reasons, the extracted 3D geometry can not be made publicly available. Similarly, Qiu &amp; Yuille (2016) provide an open-source tool to create virtual worlds by accessing and modifying the internal data structure of Unreal Engine 4. They show how virtual worlds can be used to test deep learning algorithms by linking them with the deep learning framework Caffe Jia et al. (2014).</p></li><li><p>在并行工作中，Ros et al。 （2016）创建了SYNTHIA24，一种用于语义分割的城市场景图像和注释的综合集合。他们用Unity Engine渲染了一个虚拟的城市。该数据集由13,400个随机抽取的城市虚拟图像和四个视频序列组成，共20万帧。为13个类提供像素级语义注释。</p></li><li>Richter et al。 （2016）已经为商业视频游戏“侠盗猎车手”V提取了图像的像素精确语义标签贴图。为了实现这一目标，他们开发了一种在游戏和图形硬件之间运行的包装器，以便跨越时间获得像素精确的对象签名，实例。包装器允许他们通过最小的人力监督来生成由真实感的开放世界电脑游戏合成的2.5万张图像的密集语义注释。然而，出于法律原因，提取的3D几何不能公开获得。同样，Qiu&amp;Yuille（2016）通过访问和修改虚幻引擎4的内部数据结构，提供了一个开源工具来创建虚拟世界。他们展示了虚拟世界如何通过将深度学习算法与深层次学习框架Caffe Jia（2014）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Computer Vision for Autonomous Vehicles:&lt;br&gt;Problems, Datasets and State-of-the-Art&lt;br&gt;自动驾驶技术的计算机视觉：问题，数据和前沿技术&lt;br&gt;&lt;strong&gt;数据集和基准&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="paper" scheme="https://hyqskevin.github.io/categories/paper/"/>
    
    
  </entry>
  
  <entry>
    <title>各类排序算法实践</title>
    <link href="https://hyqskevin.github.io/2019/03/17/sort/"/>
    <id>https://hyqskevin.github.io/2019/03/17/sort/</id>
    <published>2019-03-17T13:33:15.000Z</published>
    <updated>2019-08-26T01:50:39.468Z</updated>
    
    <content type="html"><![CDATA[<p>比较重要的基础算法，简单罗列一下一些排序的实践过程</p><a id="more"></a><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>从待排序部分a[i,m]选择最小元素，与待排序部分的第一个元素a[i]交换，形成新的有序区间a[1,i+1]<br>选择排序总体实践复杂度O(n^2)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;=n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j] &lt; a[flag]) flag = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换a[i]和a[flag]</span></span><br><span class="line">    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">    a[i] = a[flag];</span><br><span class="line">    a[flag] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="sort函数运用"><a href="#sort函数运用" class="headerlink" title="sort函数运用"></a>sort函数运用</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较重要的基础算法，简单罗列一下一些排序的实践过程&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Autonomous Vehicles translate -- abstract &amp; previous &amp; history</title>
    <link href="https://hyqskevin.github.io/2019/03/14/abstract-previous-history/"/>
    <id>https://hyqskevin.github.io/2019/03/14/abstract-previous-history/</id>
    <published>2019-03-13T16:03:14.000Z</published>
    <updated>2019-03-13T16:09:58.768Z</updated>
    
    <content type="html"><![CDATA[<p>Computer Vision for Autonomous Vehicles:<br>Problems, Datasets and State-of-the-Art<br>自动驾驶技术的计算机视觉：问题，数据和前沿技术<br><strong>摘要，前沿和技术历史</strong></p><a id="more"></a><h2 id="Abstract-摘要"><a href="#Abstract-摘要" class="headerlink" title="Abstract 摘要"></a>Abstract 摘要</h2><ul><li>Recent years have witnessed amazing progress in AI related fields such as computer vision, machine learning and autonomous vehicles. |As with any rapidly growing field, however, it becomes increasingly difficult to stay up-to-date or enter the field as a beginner. |While several topic specific survey papers have been written, to date no general survey on problems, datasets and methods in computer vision for autonomous vehicles exists.|This paper attempts to narrow this gap by providing a state-of-the-art survey on this topic. Our survey includes both the historically most relevant literature as well as the current state-of-the-art on several specific topics, including recognition, reconstruction, motion estimation, tracking, scene understanding and end-to-end learning. |Towards this goal, we first provide a taxonomy to classify each approach and then analyze the performance of the state-of-the-art on several challenging benchmarking datasets including KITTI, ISPRS, MOT and Cityscapes. |Besides, we discuss open problems and current research challenges. To ease accessibility and accommodate missing references, we will also provide an interactive platform which allows to navigate topics and methods, and provides additional information and project links for each paper.<br>Keywords: Computer Vision, Autonomous Vehicles, Autonomous Vision</li><li>概述：人类见证了最近几年AI相关领域的惊人进步，如计算机视觉，机器学习和自动驾驶。<br>然而任何一个快速发展的领域，保持领先或刚开始进入这些领域变得越来越难(业内人员难以跟上行业节奏或者业外人员难入行)。<br>尽管已经(有人)发表了一些这方面的专题研究文章，但在自动驾驶技术中，计算机视觉的问题、数据和方法至今没有普遍的研究。<br>对于这个话题，这篇论文试图通过提供对前沿技术的研究来减少这种缺口。我们的研究包括最相关的历史资料和当前最前沿的技术，包括识别、重建运动估测、追踪场景理解和端到端学习等。<br>为完成这个目标，我们首先通过分类学对每一个方法进行分类，然后在一些具有挑战性的基础数据集上，如KITTI、ISPRS、MOT和Cityscapes上分析每一个方法在前沿技术上的表现<br>此外，我们还讨论了一些开放问题和当前研究的挑战，为了轻松访问和适应缺失的参考，我们将提供一个具有主题和方法的驾驶交互平台，并提供额外信息和每篇论文的项目链接<br>关键词：计算机视觉，自动驾驶，自主视觉</li></ul><h2 id="previous-前言"><a href="#previous-前言" class="headerlink" title="previous 前言"></a>previous 前言</h2><ul><li><p>Since the first successful demonstrations in the 1980s (Dick-manns &amp; Mysliwetz (1992); Dickmanns &amp; Graefe (1988); Thorpeet al. (1988)), great progress has been made in the field of autonomous vehicles. |Despite these advances, however, it is safe to believe that fully autonomous navigation in arbitrarily complex environments is still decades away. |The reason for this is two-fold: First, autonomous systems which operate in complex dynamic environments require artificial intelligence which generalizes to unpredictable situations and reasons in a timely manner. |Second, informed decisions require accurate perception, yet most of the existing computer vision systems produce errors at a rate which is not acceptable for autonomous navigation.</p></li><li><p>从20世纪80年代首次成功展示以来(Dick-manns &amp; Mysliwetz (1992); Dickmanns &amp; Graefe (1988); Thorpeet al. (1988))(Dick-manns &amp; Mysliwetz (1992); Dickmanns &amp; Graefe (1988); Thorpeet al. (1988))，自动驾驶技术领域已经取得了很大进展<br>尽管有了这些进展，但在任意复杂环境中，实现完全自动驾驶仍然被认为需要几十年<br>原因有两点：第一，在复杂的、动态的环境中运行的自动驾驶系统需要人工智能来归纳不可预测的情形和原因，给出及时的方法<br>第二，信息的决策需要准确的感知，目前大多数已有的计算机视觉系统有一定的错误率，这是自动驾驶技术无法接受的</p></li><li><p>In this paper, we focus on the second aspect which we call autonomous vision and investigate the performance of current perception systems for autonomous vehicles. |Towards this goal, we first provide a taxonomy of problems and classify existing datasets and techniques using this taxonomy, describing the pros and cons of each method. Second, we analyze the current state-of-the-art performance on several popular publicly available benchmarking datasets. |In particular, we provide a novel in-depth qualitative analysis of the KITTI benchmark which shows the easiest and most difficult examples based on the methods submitted to the evaluation server. |Based on this analysis, we discuss open research problems and challenges. To ease navigation, we also provide an interactive online tool which visualizes our taxonomy using a graph and provides additional information and links to project pages in an easily accessible manner. |We hope that our survey will become a useful tool for researchers in the field of autonomous vision and lowers the entry barrier for beginners by providing an exhaustive overview over the field.</p></li><li><p>在这篇论文中，我们关注第二个方面的问题，也就是自动驾驶视觉，同时调查最近的自动驾驶视觉中感知系统的表现<br>为完成这个目标，我们首先给出了问题的分类，归类了已有的数据和可使用的技术，描述每种方法的优缺点。第二，我们在几个流行的公开数据集上分析了最近前沿成果的表现<br>特别是我们给出一种KITTI基准的新的深入定性分析，这些分析展示了提交给评价服务器的方法中最简单和最困难的例子<br>基于这些分析，我们讨论了开放的研究问题和挑战，为了简化学习，我们也给出一个在线交互式工具，用图像可视化了分类，并提供额外信息和一个简单可行的方法与项目页链接<br>我们希望我们的研究能够成为自动驾驶领域研究人员的一个有用的工具，并通过透彻的概述，降低新人进入该领域的门槛</p></li><li><p>There exist several other related surveys. Winner et al. (2015) explains in detail systems for active safety and driver assistance, considering both their structure and their function. |Their focus is to cover all aspects of driver assistance systems and the chapter about machine vision covers only the most basic concepts of the autonomous vision problem. |Klette (2015) provide an overview over vision-based driver assistance systems. They describe most aspects of the perception problem at a high level, but do not provide an in-depth review of the state-of-the-art in each task as we pursue in this paper. |Complementary to our survey, Zhu et al. (2017) provide an overview of environment perception for intelligent vehicles, focusing on lane detection, traffic sign/light recognition as well as vehicle tracking. |In contrast, our goal is to bridge the gap between the robotics, intelligent vehicles, photogrammetry and computer vision communities by providing an extensive overview and comparison which includes works from all fields.</p></li><li>目前也有一些其它相关的研究，Winner et al. (2015)详细地解释了主动安全性和驾驶辅助系统，同时考虑了它们的结构和功能<br>这些研究注重覆盖辅助驾驶系统的所有方面，但关于机器视觉的章节只覆盖到了自动驾驶技术中最基础的概念。<br>Klette (2015)提供了一个基于视觉的辅助驾驶系统的概述，他们描述了高层次感知问题的大部分方面，但并没有像我们在论文中追求的一样，给出在各种前沿任务中比较深入的评测<br>Zhu et al. (2017)提出了智能汽车环境感知的概述，聚焦在车道检测，交通信号灯识别和机车追踪问题，这与我们的研究相互补充。<br>相比较下，我们的目标是通过提供广泛的概述和比较，包括在这个领域所有的成果，在机器人、智能汽车、摄影测绘和计算机视觉之间建立起一座桥梁</li></ul><h2 id="History-of-Autonomous-Driving-自动驾驶技术历史"><a href="#History-of-Autonomous-Driving-自动驾驶技术历史" class="headerlink" title="History of Autonomous Driving 自动驾驶技术历史"></a>History of Autonomous Driving 自动驾驶技术历史</h2><h3 id="Autonomous-Driving-Projects-自动驾驶项目"><a href="#Autonomous-Driving-Projects-自动驾驶项目" class="headerlink" title="Autonomous Driving Projects 自动驾驶项目"></a>Autonomous Driving Projects 自动驾驶项目</h3><ul><li><p>Many governmental institutions worldwide started various projects to explore intelligent transportation systems (ITS). The PROMETHEUS project started 1986 in Europe and involved more than 13 vehicle manufacturers, several research units from governments and universities of 19 European countries. |One of the first projects in the United States was Navlab Thorpe et al. (1988) by the Carnegie Mellon University which achieved a major milestone in 1995, by completing the first autonomous drive from Pittsburgh, PA and Sand Diego, CA. |After many initiatives were launched by universities, research centers and automobile companies, the U.S. government established the National Automated Highway System Consortium (NAHSC) in 1995. |Similar to the U.S., Japan established the Advanced Cruise-Assist Highway System Research Association in 1996 among many automobile industries and research centers to foster research on automatic vehicle guidance. |Bertozzi et al. (2000) survey many approaches to the challenging task of autonomous road following developed during these projects. They concluded that suffcient computing power is become increasingly available, but diffculties like reflections, wet road, direct sunshine, tunnels and shadows still make data interpretation challenging. |Thus, they suggested the enhancement of sensor capabilities. They also pointed out that the legal aspects related to the responsibility and impact of automatic driving on human passengers need to be considered carefully. |In summary, the automation will likely be restricted to special infrastructures and will be extended gradually.</p></li><li><p>世界各地的许多政府机构启动各式各样的项目来开发智能交通系统（ITS）。PROMETHEUS这个项目1986年在欧洲启动，包括超过13个交通工具生产商，当中的许多研究成员来自19个欧洲国家的政府和高校。<br>美国的其中一个项目就是由卡耐基梅隆大学的Navlab Thorpe等人(1988)创建的。这个项目完成了第一次从Pittsburgh，PA,Sand Diego和CA的自动驾驶，在1995年是一个重要的里程碑。<br>在许多大学，研究中心和自动驾驶公司的倡议下，美国政府在1995年成立了自动化公路系统联盟（NAHSC）。<br>和美国一样，日本于1996年成立了高级巡航公路系统研究协会(Advanced Cruise-Assist Highway System Research Association)，包括各大自动驾驶公司和研究中心，来促进自动驾驶导航的研究。<br>Bertozzi等人（2000）调查了许多具有挑战性的任务(通过这些项目发展的自动道路跟随),给出解决方法。他们得出结论，计算能力逐渐得到满足，但像反射，湿面潮湿，阳光直射，隧道和阴影这样的困难仍然使数据解释具有挑战性。<br>因此，他们建议提高传感器性能，同时也指出，关系到自动驾驶对行人法律方面的责任和影响，应该认真的考虑<br>总之，自动化技术(发展)可能会受限于特殊的基础设施，然后再慢慢的普及开来。</p></li><li><p>Motivated by the success of the PROMETHEUS projects to drive autonomously on highways, Franke et al. (1998) describe a real-time vision system for autonomous driving in complex urban traffic situations. |While highway scenarios have been studied intensively, urban scenes have not been addressed before. Their system included depth-based obstacle detection and tracking from stereo as well as a framework for monocular detection and recognition of relevant objects such as traffic signs.</p></li><li><p>The fusion of several perception systems developed by Vis-Lab have led to several proto-type vehicles including ARGO Broggi et al. (1999), TerraMax Braid et al. (2006), and BRAiVE Grisleri &amp; Fedriga (2010). |BRAiVE is the latest vehicle proto-type which is now integrating all systems that VisLab has developed so far. Bertozzi et al. (2011) demonstrated the robustness of their system at the VisLab Intercontinental Autonomous Challenge, a semi-autonomous drive from Italy to China. |The onboard system allows to detect obstacles, lane marking, ditches,berms and identify the presence and position of a preceding vehicle. The information produced by the sensing suite is used to perform different tasks such as leader-following and stop &amp; go.</p></li><li><p>PROMETHEUS项目可以实现在高速公路上自动驾驶，在这个成功的案例推动下，Franke等人描述了在复杂的城市交通场景下的自动驾驶的实时视觉系统。<br>虽然在此之前公路场景情况已经有很多深入的研究，但城市场景却从未得到解决。他们的系统包括基于深度的障碍检测和立体追踪，以及针对相关物体（比如：交通信号）的单目检测和识别框架。</p></li><li><p>Vis-Lab发展的多种传感系统的融合促成了几款原型车包括ARGO Broggi（1999），TerraMax Braid（2006）和BRAiVE Grisleri &amp; Fedriga（2010）的出现<br>BRAiVE是目前VisLab开发的整合所有系统的最新车型。 Bertozzi等人（2011）在VisLab洲际自治挑战赛（VisLab Intercontinental Autonomous Challenge，意大利到中国的半自主驾驶）展示了其系统的稳健性（鲁棒性）。<br>车载系统允许检测障碍物，标记车道、沟渠、护堤，并识别前方是否存在车辆和车辆位置。感应套件提供的信息被用于执行不同的任务，如(leader-following)和前进/停止。?</p></li><li><p>The PROUD project Broggi et al. (2015) slightly modified the BRAiVE prototype Grisleri &amp; Fedriga (2010) to drive in urban roads and freeways open to regular traffic in Parma. |Towards this goal they enrich an openly licensed map with information about the maneuver to be managed (e.g. pedestrian crossing, traffic light, . . . ). |The vehicle was able to handle complex situations such as roundabouts, intersections, priority roads, stops, tunnels, crosswalks, traffic lights, highways, and urban roads without any human intervention.</p></li><li><p>The V-Charge project Furgale et al. (2013) presents an electric automated car outfitted with close-to-market sensors. A fully operational system is proposed including vision-only localization, mapping, navigation and control. |The project supported many works on different problems such as calibration Heng et al. (2013, 2015), stereo H¨ane et al. (2014), reconstruction Haene et al. (2012, 2013, 2014), SLAM Grimmett et al.(2015) and free space detection H¨ane et al. (2015). In addition to these research objectives, the project keeps a strong focus on deploying and evaluating the system in realistic environments.</p></li><li><p>PROUD的项目Broggi（2015）略微修改了BRAiVE原型Grisleri &amp; Fedriga（2010）使得汽车可以在parma城市道路和高速公路的常规交通情况下开车。<br>为了实现这一目标，他们丰富了一份公开授权的地图，其中包含有待完成的机动信息（比如行人过路，交通信号灯等）。<br>该车辆能够在没有人为干涉的情况下处理复杂的场景，例如回旋处，交叉口，优先道路，站点，隧道，人行横道，交通信号灯，高速公路和城市道路。</p></li><li><p>V-Charge项目Furgale等人 （2013年）提供配备了近距离市场（close-to-market）传感器的电动自动车。提出了一个全面可使用的系统，包括视觉定位，映射，导航和控制。<br>该项目解决了诸多困难比如，Heng et al. (2013, 2015)的校准问题, H¨ane(2014)的立体问题,Haene(2012, 2013, 2014)的重建问题, Grimmett(2015)的SLAM问题和 H¨ane(2015)的空白区域检测的问题。除了这些研究目标，该项目还非常重视在现实环境中部署和系统评估。</p></li><li><p>Google started their self-driving car project in 2009 and completed over 1,498,000 miles autonomously until March 2016 in Mountain View, CA, Austin, TX and Kirkland, WA. |Different sensors (i.a. cameras, radars, LiDAR, wheel encoder, GPS) allow to detect pedestrians, cyclists, vehicles, road work and more in all directions. |According to their accident reports, Google’s self-driving cars were involved only in 14 collisions while 13 times were caused by others. In 2016, the project was split off to Waymo, an independent self-driving technology company.</p></li><li><p>Tesla Autopilot is an advanced driver assistant system developed by Tesla which was first rolled out(推出) in 2015 with version of their software. The automation level of the system allows full automation but requires the full attention of the driver to take control if necessary. |From October 2016, all vehicles produced by Tesla were equipped with eight cameras, twelve ultrasonic sensors and a forward-facing radar to enable full self-driving capability.</p></li><li><p>Google于2009年开始了自驾车项目，直到2016年3月完成了超过1,498,000英里的驾驶距离，在美国加利福尼亚州奥斯汀市的Mountain View，WA和柯克兰。<br>不同的传感器（例如摄像机，雷达，LiDAR，车轮编码器，GPS）可以全方位的检测行人，骑自行车的人，车辆，道路工作等等。<br>据他们的事故报道，Google的自动驾驶车只涉及14次碰撞，13次是由别人造成的。 在2016年，这个项目分引入到了一家独立的自动驾驶技术公司Waymo。</p></li><li><p>Tesla Autopilot是由特斯拉开发的高级驾驶员辅助系统，该系统于2015年第一次推出其视觉软件。系统的自动化级别允许完全的自动化，但是仍然需要 要求驾驶员集中注意来控制。<br>从2016年10月起，特斯拉生产的所有车辆配备了8台摄像机，12台超声波传感器和一个前置雷达，以实现全自动驾驶能力。</p></li><li><p><strong>Long Distance Test Demonstrations</strong>: In 1995 the team within the PROMETHEUS project Dickmanns et al. (1990); Franke et al. (1994); Dickmanns et al. (1994) performed the first autonomous long-distance drive from Munich, Germany, to Odense, Denmark, at velocities up to 175 km/h with about 95% autonomous driving. |Similarly, in the U.S. Pomerleau &amp; Jochem (1996) drove from Washington DC to San Diego in the ’No hands across America’ tour with 98% automated steering yet manual longitudinal control.</p></li><li><p>In 2014, Ziegler et al. (2014) demonstrated a 103 km ride from Mannheim to Pforzheim Germany, known as Bertha Benz memorial route, in nearly fully autonomous manner. |They present an autonomous vehicle equipped with close-to-production sensor hardware. Object detection and free-space analysis is performed with radar and stereo vision. Monocular vision is used for traffic light detection and object classification. |Two complementary vision algorithms, point feature based and lane marking based, allow precise localization relative to manually annotated digital road maps. They concluded that even thought the drive was successfully completed the overall behavior is far inferior to the performance level of an attentive human driver.</p></li><li><p>长距离测试演示：1995年，PROMETHEUS项目里Dickmanns（1990）、Franke（1994）、Dickmanns（1994年）的团队演示了从德国慕尼黑（Munich）到丹麦欧登塞（Odense）进行的第一次自动长途驾驶，速度达175公里/小时，其中约95％为自主驾驶。<br>同样，在美国Pomerleau和Jochem（1996）在‘No hands across from America ???’中从华盛顿特区开往圣地亚哥，整个行程中有98％的自动驾驶和偶尔的手动纵向控制。</p></li><li><p>2014年，Zieglar（2014）以近乎完全自动的方式，展示了从曼海姆（Mannheim）到德国普福尔茨海姆（Pforzheim Germany）的103km的骑行，也就是众人所熟知的Bertha Benz纪念路线。<br>他们展示了一种装配有接近生产(close-to-production)的传感器硬件的自动驾驶车辆。由雷达radar和立体视觉来进行物体检测和空白区域分析。单目视觉用来检测交通信号灯和目标分类。<br>两种互补的算法，基于点特征和基于场景标记，允许相对于手动注释的数字路线图进行精确定位。他们得出结论，甚至认为自动驾驶虽然成功完成了，但是整体行为远远达不到细心的驾驶司机的水平。</p></li><li><p>Recently, Bojarski et al. (2016) drove autonomously 98% of the time from Holmdel to Atlantic Highlands in Monmouth County NJ as well as 10 miles on the Garden State Parkway without intervention. |Towards this goal, a convolutional neural network which predicts vehicle control directly from images is used in the NVIDIA DRIVETM PX self-driving car. The system is discussed in greater detail in Section 11.</p></li><li><p>While all aforementioned performed impressively, the general assumption of precisely annotated road maps as well as prerecorded maps for localization demonstrates that autonomous systems are still far from human capabilities. |Most importantly, robust perception from visual information but also general artificial intelligence are required to reach human level reliability and react safely even in complex innercity situations.</p></li><li><p>最近，Bojarski（2016）从霍尔姆德尔（Holmdel）到新泽西州蒙茅斯县（Monmouth）的大西洋高原，以及在花园州立大道没有任何干扰的自动行驶了10英里，其中98%是在自动驾驶。<br>为了实现这一目标，在NVIDIA DRIVETM PX自动驾驶车中使用了一种从图像直接预测车辆控制的卷积神经网络。该系统在第11节中有更详细的讨论。</p></li><li>虽然所有上述表现令人印象深刻，但精确注释路线图的一般假设，以及用于定位的预先载入的地图证实了自主性系统仍然差强人意。<br>最重要的是，这不仅需要视觉信息的强大的感知，也需要一般的人工智能达到和人一样的可靠性，并且在复杂的城市情况下也能安全地做出反应。</li></ul><h3 id="Autonomous-Driving-Competitions-自动驾驶竞赛"><a href="#Autonomous-Driving-Competitions-自动驾驶竞赛" class="headerlink" title="Autonomous Driving Competitions 自动驾驶竞赛"></a>Autonomous Driving Competitions 自动驾驶竞赛</h3><ul><li>The European Land Robot Trial (ELROB) is a demonstration and competition of unmanned systems in realistic scenarios and terrains, focusing mainly on military aspects such as reconnaissance and surveillance, autonomous navigation and convoy transport. In contrast to autonomous driving challenges, ELROB scenarios typically include navigation in rough terrain.</li><li>The first autonomous driving competition focusing on road scenes (though primarily dirt roads) has been initiated by the American Defense Advanced Research Projects Agency (DARPA) in 2004. The DARPA Grand Challenge 2004 offered a prize money of 1 million for the team first finishing a 150 mile route which crossed the border from California to Nevada. |However, none of the robot vehicles completed the route. One year later, in 2005, DARPA announced a second edition of its challenge with 5 vehicles successfully completing the route (Buehler et al.(2007)). The third competition of the DARPA Grand Challenge, known as the Urban Challenge (Buehler et al. (2009)), took place on November 3, 2007 at the site of the George Air Force Base in California. The challenge involved a 96 km urban area course where traffic regulations had to be obeyed while negotiating with other vehicles and merging into traffic.</li><li><p>The Grand Cooperative Driving Challenge (GCDC, see also Geiger et al. (2012a)), a competition focusing on autonomous cooperative driving behavior was held in Helmond, Netherlands in 2011 for the first time and in 2016 for a second edition. During the competition, teams had to negotiate convoys, join convoys and lead convoys. The winner was selected based on a system that assigned points to randomly mixed teams.</p></li><li><p>European Land Robot Trial （ELROB）是现实场景和地形中无人系统的示范与竞赛，主要集中在军事方面，如侦察监视，自动导航和车队运输。与自主驾驶挑战相反，ELROB场景通常包括崎岖地形的导航。</p></li><li>2004年，美国国防高级研究计划署（DARPA）发起了第一个专注于道路场景（主要是泥土路）的自动驾驶比赛。挑战赛提供了100万美元的奖金给首先完成从加利福尼亚州内华达州过境的150英里的路线。<br>然而，机器人车辆都没有完成路线。 一年后，DARPA公布了第二版的挑战，5辆车顺利完成了路线（Buehler（2007））。DARPA大挑战赛的第三场比赛，被称为城市挑战赛（Buehler（2009）），于2007年11月3日在乔治航空加利福尼亚州的基地。<br>这个挑战涉及到一个96公里的城市地区航线，在这段路程中车辆在对其他车辆进行判断并汇合车流时，必须遵守交通法规。</li><li>专注于自动合作驾驶行为的大型合作驾驶挑战（GCDC，Geiger et al（2012a））在荷兰赫尔蒙德（Helmond）举行,2011年首次，2016年第二次。在比赛中，团队需要判断，加入和引导车队。获胜者是基于给随机混合团队分配点数的系统选出来的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Computer Vision for Autonomous Vehicles:&lt;br&gt;Problems, Datasets and State-of-the-Art&lt;br&gt;自动驾驶技术的计算机视觉：问题，数据和前沿技术&lt;br&gt;&lt;strong&gt;摘要，前沿和技术历史&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="paper" scheme="https://hyqskevin.github.io/categories/paper/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP &amp; MySQL learning notes (4)</title>
    <link href="https://hyqskevin.github.io/2019/03/03/php-notes3/"/>
    <id>https://hyqskevin.github.io/2019/03/03/php-notes3/</id>
    <published>2019-03-03T04:38:45.000Z</published>
    <updated>2019-03-03T08:23:01.401Z</updated>
    
    <content type="html"><![CDATA[<p>由于PHP和MySQL版本问题，对 <a href="https://hyqskevin.github.io/2018/10/28/w3school-php/#3-mySQL">PHP &amp; MySQL learning notes (1)</a> 中曾经写过用的PHP操作MySQL数据库进行笔记更新<br>完善 <a href="https://hyqskevin.github.io/2019/01/21/php-notes2/#MySQL">PHP &amp; MySQL learning notes (3)</a> 中的代码<br>重新用 MySQLi (面向对象) MySQLi (面向过程) PDO 三种方式演示PHP操作MySQL<br><a id="more"></a></p><p>可以通过 phpinfo() 查看 mysqli 和 PDO 是否可以使用</p><h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>面向对象</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = <span class="keyword">new</span> mysqli($servername, $username, $password);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"连接失败: "</span> . $conn-&gt;connect_error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"连接成功"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>面向过程</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = mysqli_connect($servername, $username, $password);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (!$conn) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"Connection failed: "</span> . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"连接成功"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PDO</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $conn = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=$servername;"</span>, $username, $password);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"连接成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(PDOException $e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关闭链接"><a href="#关闭链接" class="headerlink" title="关闭链接"></a>关闭链接</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$conn-&gt;close();  <span class="comment">//面向对象</span></span><br><span class="line">mysqli_close($conn);  <span class="comment">//面向过程</span></span><br><span class="line">$conn = <span class="keyword">null</span>;  <span class="comment">//实例PDO</span></span><br></pre></td></tr></table></figure><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>面向对象</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = <span class="keyword">new</span> mysqli($servername, $username, $password);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"连接失败: "</span> . $conn-&gt;connect_error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据库</span></span><br><span class="line">$sql = <span class="string">"CREATE DATABASE myDatabase"</span>;</span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;query($sql) === <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据库创建成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Error creating database: "</span> . $conn-&gt;error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>面向过程</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = mysqli_connect($servername, $username, $password);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (!$conn) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"连接失败: "</span> . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据库</span></span><br><span class="line">$sql = <span class="string">"CREATE DATABASE myDatabase"</span>;</span><br><span class="line"><span class="keyword">if</span> (mysqli_query($conn, $sql)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据库创建成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Error creating database: "</span> . mysqli_error($conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysqli_close($conn);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PDO</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $conn = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=$servername"</span>, $username, $password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 PDO 错误模式为异常</span></span><br><span class="line">    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class="line">    $sql = <span class="string">"CREATE DATABASE myDatabasePDO"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 exec() ，因为没有结果返回</span></span><br><span class="line">    $conn-&gt;exec($sql);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据库创建成功&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(PDOException $e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> $sql . <span class="string">"&lt;br&gt;"</span> . $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建数据表-CREATE"><a href="#创建数据表-CREATE" class="headerlink" title="创建数据表 CREATE"></a>创建数据表 CREATE</h2><p>创建Mytest表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Mytest (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">6</span>) <span class="keyword">UNSIGNED</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    firstname <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    lastname <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    email <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    reg_date <span class="built_in">TIMESTAMP</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>面向对象</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line">$dbname = <span class="string">"myDatabase"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = <span class="keyword">new</span> mysqli($servername, $username, $password, $dbname);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"连接失败: "</span> . $conn-&gt;connect_error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sql 创建数据表</span></span><br><span class="line">$sql = <span class="string">"CREATE TABLE Mytest (</span></span><br><span class="line"><span class="string">id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span></span><br><span class="line"><span class="string">firstname VARCHAR(30) NOT NULL,</span></span><br><span class="line"><span class="string">lastname VARCHAR(30) NOT NULL,</span></span><br><span class="line"><span class="string">email VARCHAR(50),</span></span><br><span class="line"><span class="string">reg_date TIMESTAMP</span></span><br><span class="line"><span class="string">)"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;query($sql) === <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Table Mytest</span></span><br><span class="line"><span class="string">   created successfully"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"创建数据表错误: "</span> . $conn-&gt;error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>面向过程</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line">$dbname = <span class="string">"myDatabase"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = mysqli_connect($servername, $username, $password, $dbname);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (!$conn) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"连接失败: "</span> . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sql 创建数据表</span></span><br><span class="line">$sql = <span class="string">"CREATE TABLE Mytest (</span></span><br><span class="line"><span class="string">id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span></span><br><span class="line"><span class="string">firstname VARCHAR(30) NOT NULL,</span></span><br><span class="line"><span class="string">lastname VARCHAR(30) NOT NULL,</span></span><br><span class="line"><span class="string">email VARCHAR(50),</span></span><br><span class="line"><span class="string">reg_date TIMESTAMP</span></span><br><span class="line"><span class="string">)"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mysqli_query($conn, $sql)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据表 Mytest</span></span><br><span class="line"><span class="string">   创建成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"创建数据表错误: "</span> . mysqli_error($conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysqli_close($conn);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PDO</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line">$dbname = <span class="string">"myDatabasePDO"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $conn = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=$servername;dbname=$dbname"</span>, $username, $password);</span><br><span class="line">    <span class="comment">// 设置 PDO 错误模式，用于抛出异常</span></span><br><span class="line">    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 sql 创建数据表</span></span><br><span class="line">    $sql = <span class="string">"CREATE TABLE MyTest</span></span><br><span class="line"><span class="string">   (</span></span><br><span class="line"><span class="string">    id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span></span><br><span class="line"><span class="string">    firstname VARCHAR(30) NOT NULL,</span></span><br><span class="line"><span class="string">    lastname VARCHAR(30) NOT NULL,</span></span><br><span class="line"><span class="string">    email VARCHAR(50),</span></span><br><span class="line"><span class="string">    reg_date TIMESTAMP</span></span><br><span class="line"><span class="string">    )"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 exec() ，没有结果返回</span></span><br><span class="line">    $conn-&gt;exec($sql);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据表 MyTest</span></span><br><span class="line"><span class="string">   创建成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(PDOException $e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> $sql . <span class="string">"&lt;br&gt;"</span> . $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插入数据-INSERT"><a href="#插入数据-INSERT" class="headerlink" title="插入数据 INSERT"></a>插入数据 INSERT</h2><p>使用INSERT进行插入操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, column3,...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3,...)</span><br></pre></td></tr></table></figure><h3 id="插入单条数据"><a href="#插入单条数据" class="headerlink" title="插入单条数据"></a>插入单条数据</h3><p>面向对象</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line">$dbname = <span class="string">"myDatabase"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = <span class="keyword">new</span> mysqli($servername, $username, $password, $dbname);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"连接失败: "</span> . $conn-&gt;connect_error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"INSERT INTO MyTest (firstname, lastname, email)</span></span><br><span class="line"><span class="string">VALUES ('John', 'Doe', 'john@example.com')"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;query($sql) === <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"新记录插入成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Error: "</span> . $sql . <span class="string">"&lt;br&gt;"</span> . $conn-&gt;error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>面向过程</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line">$dbname = <span class="string">"myDatabase"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = mysqli_connect($servername, $username, $password, $dbname);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (!$conn) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"Connection failed: "</span> . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"INSERT INTO MyTest (firstname, lastname, email)</span></span><br><span class="line"><span class="string">VALUES ('John', 'Doe', 'john@example.com')"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mysqli_query($conn, $sql)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"新记录插入成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Error: "</span> . $sql . <span class="string">"&lt;br&gt;"</span> . mysqli_error($conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysqli_close($conn);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PDO</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line">$dbname = <span class="string">"myDatabasePDO"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $conn = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=$servername;dbname=$dbname"</span>, $username, $password);</span><br><span class="line">    <span class="comment">// 设置 PDO 错误模式，用于抛出异常</span></span><br><span class="line">    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class="line">    $sql = <span class="string">"INSERT INTO MyTest</span></span><br><span class="line"><span class="string">   (firstname, lastname, email)</span></span><br><span class="line"><span class="string">    VALUES ('John', 'Doe', 'john@example.com')"</span>;</span><br><span class="line">    <span class="comment">// 使用 exec() ，没有结果返回</span></span><br><span class="line">    $conn-&gt;exec($sql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    $conn-&gt;exec("INSERT INTO MyTest</span></span><br><span class="line"><span class="comment">   (firstname, lastname, email)</span></span><br><span class="line"><span class="comment">    VALUES ('John', 'Doe', 'john<span class="doctag">@example</span>.com')")</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"新记录插入成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(PDOException $e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> $sql . <span class="string">"&lt;br&gt;"</span> . $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h3><p>mysqli_multi_query() 函数可用来执行多条SQL语句</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql = <span class="string">"INSERT INTO MyTest (firstname, lastname, email)</span></span><br><span class="line"><span class="string">VALUES ('John', 'Doe', 'john@example.com');"</span>;</span><br><span class="line">$sql .= <span class="string">"INSERT INTO MyTest (firstname, lastname, email)</span></span><br><span class="line"><span class="string">VALUES ('Mary', 'Moe', 'mary@example.com');"</span>;</span><br><span class="line">$sql .= <span class="string">"INSERT INTO MyTest (firstname, lastname, email)</span></span><br><span class="line"><span class="string">VALUES ('Julie', 'Dooley', 'julie@example.com')"</span>;</span><br><span class="line"></span><br><span class="line">$conn-&gt;multi_query($sql) === <span class="keyword">TRUE</span> <span class="comment">// 面向对象</span></span><br><span class="line">mysqli_multi_query($conn, $sql)  <span class="comment">//面向过程</span></span><br></pre></td></tr></table></figure><p>PDO需要使用事务函数执行多条并提交，执行失败后要使用回滚</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line">$dbname = <span class="string">"myDatabasePDO"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $conn = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=$servername;dbname=$dbname"</span>, $username, $password);</span><br><span class="line">    <span class="comment">// set the PDO error mode to exception</span></span><br><span class="line">    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始事务</span></span><br><span class="line">    $conn-&gt;beginTransaction();</span><br><span class="line">    <span class="comment">// SQL 语句</span></span><br><span class="line">    $conn-&gt;exec(<span class="string">"INSERT INTO MyTest</span></span><br><span class="line"><span class="string">   (firstname, lastname, email)</span></span><br><span class="line"><span class="string">    VALUES ('John', 'Doe', 'john@example.com')"</span>);</span><br><span class="line">    $conn-&gt;exec(<span class="string">"INSERT INTO MyTest</span></span><br><span class="line"><span class="string">   (firstname, lastname, email)</span></span><br><span class="line"><span class="string">    VALUES ('Mary', 'Moe', 'mary@example.com')"</span>);</span><br><span class="line">    $conn-&gt;exec(<span class="string">"INSERT INTO MyTest</span></span><br><span class="line"><span class="string">   (firstname, lastname, email)</span></span><br><span class="line"><span class="string">    VALUES ('Julie', 'Dooley', 'julie@example.com')"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    $conn-&gt;commit();</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"新记录插入成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(PDOException $e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果执行失败回滚</span></span><br><span class="line">    $conn-&gt;rollback();</span><br><span class="line">    <span class="keyword">echo</span> $sql . <span class="string">"&lt;br&gt;"</span> . $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用预处理语句优化"><a href="#使用预处理语句优化" class="headerlink" title="使用预处理语句优化"></a>使用预处理语句优化</h3><p>用于执行多个相同的 SQL 语句，也可以防止 MySQL 注入</p><p><strong>主要优势</strong></p><ol><li>预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）</li><li>绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句</li><li>预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性</li></ol><p><strong>流程</strong></p><ol><li>预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 <code>?</code> 标记，可以将其替换为整型，字符串，双精度浮点型和布尔值<br><code>INSERT INTO MyTest (firstname, lastname, email) VALUES(?, ?, ?)</code></li><li>绑定 SQL 参数并告知相关的值<br><code>$stmt-&gt;bind_param(&quot;sss&quot;, $firstname, $lastname, $email);</code></li></ol><ul><li>“sss” 参数列处理参数的数据类型，参数有以下四种类型:<br>i - integer（整型）<br>d - double（双精度浮点型）<br>s - string（字符串）<br>b - BLOB（binary large object:二进制大对象）</li><li>通过告诉数据库参数的数据类型，可以降低 SQL 注入的风险</li></ul><ol><li>数据库解析，编译，对SQL语句模板执行查询优化，并存储结果不输出</li><li>执行：最后，将应用绑定的值传递给参数（<code>?</code> 标记），数据库执行语句</li></ol><p>使用预处理语句插入多条数据</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测数据库链接状态 同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理及绑定</span></span><br><span class="line">$stmt = $conn-&gt;prepare(<span class="string">"INSERT INTO MyTest (firstname, lastname, email) VALUES (?, ?, ?)"</span>);</span><br><span class="line">$stmt-&gt;bind_param(<span class="string">"sss"</span>, $firstname, $lastname, $email);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置参数并执行</span></span><br><span class="line">$firstname = <span class="string">"John"</span>;</span><br><span class="line">$lastname = <span class="string">"Doe"</span>;</span><br><span class="line">$email = <span class="string">"john@example.com"</span>;</span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">$firstname = <span class="string">"Mary"</span>;</span><br><span class="line">$lastname = <span class="string">"Moe"</span>;</span><br><span class="line">$email = <span class="string">"mary@example.com"</span>;</span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">$firstname = <span class="string">"Julie"</span>;</span><br><span class="line">$lastname = <span class="string">"Dooley"</span>;</span><br><span class="line">$email = <span class="string">"julie@example.com"</span>;</span><br><span class="line">$stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"新记录插入成功"</span>;</span><br><span class="line"></span><br><span class="line">$stmt-&gt;close();</span><br><span class="line">$conn-&gt;close();</span><br></pre></td></tr></table></figure><p>PDO</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line">$dbname = <span class="string">"myDatabasePDO"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $conn = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=$servername;dbname=$dbname"</span>, $username, $password);</span><br><span class="line">    <span class="comment">// 设置 PDO 错误模式为异常</span></span><br><span class="line">    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理 SQL 并绑定参数</span></span><br><span class="line">    $stmt = $conn-&gt;prepare(<span class="string">"INSERT INTO MyTest</span></span><br><span class="line"><span class="string">   (firstname, lastname, email)</span></span><br><span class="line"><span class="string">    VALUES (:firstname, :lastname, :email)"</span>);</span><br><span class="line">    $stmt-&gt;bindParam(<span class="string">':firstname'</span>, $firstname);</span><br><span class="line">    $stmt-&gt;bindParam(<span class="string">':lastname'</span>, $lastname);</span><br><span class="line">    $stmt-&gt;bindParam(<span class="string">':email'</span>, $email);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入行</span></span><br><span class="line">    $firstname = <span class="string">"John"</span>;</span><br><span class="line">    $lastname = <span class="string">"Doe"</span>;</span><br><span class="line">    $email = <span class="string">"john@example.com"</span>;</span><br><span class="line">    $stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入其他行</span></span><br><span class="line">    $firstname = <span class="string">"Mary"</span>;</span><br><span class="line">    $lastname = <span class="string">"Moe"</span>;</span><br><span class="line">    $email = <span class="string">"mary@example.com"</span>;</span><br><span class="line">    $stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入其他行</span></span><br><span class="line">    $firstname = <span class="string">"Julie"</span>;</span><br><span class="line">    $lastname = <span class="string">"Dooley"</span>;</span><br><span class="line">    $email = <span class="string">"julie@example.com"</span>;</span><br><span class="line">    $stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"新记录插入成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(PDOException $e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Error: "</span> . $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line">$conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查询数据-SELECT"><a href="#查询数据-SELECT" class="headerlink" title="查询数据 SELECT"></a>查询数据 SELECT</h2><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p>SELECT 语句用于从数据表中读取数据:<br><code>SELECT column_name(s) FROM table_name</code></p><p>面向对象</p><ol><li>设置 SQL 语句从 MyTest数据表中读取 id, firstname 和 lastname 三个字段。</li><li>使用 SQL 语句从数据库中取出结果集并赋给复制给变量 $result。</li><li>函数 num_rows() 判断返回的数据。</li><li>函数 fetch_assoc() 将结合集放入到关联数组并循环输出</li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建和检测连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立索引</span></span><br><span class="line">$sql = <span class="string">"SELECT id, firstname, lastname FROM MyTest"</span>;</span><br><span class="line">$result = $conn-&gt;query($sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($result-&gt;num_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 输出数据</span></span><br><span class="line">    <span class="keyword">while</span>($row = $result-&gt;fetch_assoc()) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"id: "</span> . $row[<span class="string">"id"</span>]. <span class="string">" - Name: "</span> . $row[<span class="string">"firstname"</span>]. <span class="string">" "</span> . $row[<span class="string">"lastname"</span>]. <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"0 结果"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>面向过程</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并检测连接</span></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"SELECT id, firstname, lastname FROM MyTest"</span>;</span><br><span class="line">$result = mysqli_query($conn, $sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mysqli_num_rows($result) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 输出数据</span></span><br><span class="line">    <span class="keyword">while</span>($row = mysqli_fetch_assoc($result)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"id: "</span> . $row[<span class="string">"id"</span>]. <span class="string">" - Name: "</span> . $row[<span class="string">"firstname"</span>]. <span class="string">" "</span> . $row[<span class="string">"lastname"</span>]. <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"0 结果"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysqli_close($conn);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PDO</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"username"</span>;</span><br><span class="line">$password = <span class="string">"password"</span>;</span><br><span class="line">$dbname = <span class="string">"myDatabasePDO"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $conn = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=$servername;dbname=$dbname"</span>, $username, $password);</span><br><span class="line">    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class="line">    $stmt = $conn-&gt;prepare(<span class="string">"SELECT id, firstname, lastname FROM MyTest</span></span><br><span class="line"><span class="string">  "</span>);</span><br><span class="line">    $stmt-&gt;execute();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置结果集为关联数组</span></span><br><span class="line">    $result = $stmt-&gt;setFetchMode(PDO::FETCH_ASSOC);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">new</span> TableRows(<span class="keyword">new</span> RecursiveArrayIterator($stmt-&gt;fetchAll())) <span class="keyword">as</span> $k=&gt;$v) &#123;</span><br><span class="line">        <span class="keyword">echo</span> $v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(PDOException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Error: "</span> . $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line">$conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;/table&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用 WHERE 子句, ORDER BY 子句进行查询时，必须使用 <code>mysqli::query</code> 或 <code>mysqli_query()</code> ，用于向 MySQL 连接发送查询或命令</li></ul><h2 id="修改数据-UPDATE"><a href="#修改数据-UPDATE" class="headerlink" title="修改数据 UPDATE"></a>修改数据 UPDATE</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1=<span class="keyword">value</span>, column2=value2,...</span><br><span class="line"><span class="keyword">WHERE</span> some_column=some_value</span><br></pre></td></tr></table></figure><p>必须使用  <code>mysqli::query</code> 或 <code>mysqli_query()</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$con=mysqli_connect(<span class="string">"localhost"</span>,<span class="string">"username"</span>,<span class="string">"password"</span>,<span class="string">"database"</span>);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (mysqli_connect_errno())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"连接失败: "</span> . mysqli_connect_error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysqli_query($con,<span class="string">"UPDATE Persons SET Age=36</span></span><br><span class="line"><span class="string">WHERE FirstName='Peter' AND LastName='Griffin'"</span>);</span><br><span class="line"></span><br><span class="line">mysqli_close($con);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="删除数据-DELETE"><a href="#删除数据-DELETE" class="headerlink" title="删除数据 DELETE"></a>删除数据 DELETE</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> some_column = some_value</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$con=mysqli_connect(<span class="string">"localhost"</span>,<span class="string">"username"</span>,<span class="string">"password"</span>,<span class="string">"database"</span>);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (mysqli_connect_errno())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"连接失败: "</span> . mysqli_connect_error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysqli_query($con,<span class="string">"DELETE FROM Persons WHERE LastName='Griffin'"</span>);</span><br><span class="line"></span><br><span class="line">mysqli_close($con);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="使用的类和函数汇总"><a href="#使用的类和函数汇总" class="headerlink" title="使用的类和函数汇总"></a>使用的类和函数汇总</h2><h3 id="mysqli-PHP和Mysql数据库之间的一个连接"><a href="#mysqli-PHP和Mysql数据库之间的一个连接" class="headerlink" title="mysqli PHP和Mysql数据库之间的一个连接"></a>mysqli PHP和Mysql数据库之间的一个连接</h3><p>mysqli::init — 初始化 MySQLi 并返回一个资源类型的值，这个值可以作为 mysqli_real_connect() 函数的传入参数<br>mysqli::$info — 返回最近执行的 SQL 语句的信息<br>mysqli::stat — 获取当前系统状态信息<br>mysqli::$connect_error/mysqli_connect_error() — 返回最后连接错误描述<br>mysqli::$error/mysqli_error() — 返回最后的错误描述<br>mysqli::__construct/mysqli_connect() — 开始一个新的MySQL服务连接<br>mysqli::real_connect — 建立一个 MySQL 服务器连接<br>mysqli::select_db — 选择用于数据库查询的默认数据库<br>mysqli::query — 对数据库执行一次查询<br>mysqli::real_query — 执行一个mysql查询<br>mysqli::send_query — 发送请求并返回结果<br>mysqli::multi_query — 执行查询<br>mysqli::real_escape_string — 根据当前连接的字符集，对于 SQL 语句中的特殊字符进行转义<br>mysqli::prepare — 准备执行一个 SQL 语句<br>mysqli::stmt_init — 初始化一条语句并返回一个用于mysqli_stmt_prepare(调用)的对象<br>mysqli::rollback — 回退当前事务<br>mysqli::close/mysqli_close() — 关闭先前打开的数据库连接</p><p>mysqli::autocommit — 打开或关闭本次数据库连接的自动命令提交事务模式<br>mysqli::change_user — 改变指定数据库连接的用户<br>mysqli::character_set_name — 返回当前数据库连接的默认字符编码<br>mysqli::commit — 提交一个事务<br>mysqli::$connect_errno — 返回最后连接错误代码<br>mysqli::errno — 返回最近函数调用的错误代码<br>mysqli::$error_list — 返回最后命令行执行错误列表<br>mysqli::$field_count — Returns the number of columns for the most recent query<br>mysqli::get_charset — Returns a character set object<br>mysqli::$client_info — 获取 MySQL 客户端信息<br>mysqli_get_client_version — 作为一个整数返回MySQL客户端的版本<br>mysqli::get_connection_stats — 返回客户端连接的统计数据<br>mysqli::$host_info — 返回一个表述使用的连接类型的字符串<br>mysqli::$protocol_version — 返回MySQL使用的协议版本号<br>mysqli::$server_info — 返回MySQL服务器的版本号<br>mysqli::$server_version — 作为一个整数返回MySQL服务器的版本<br>mysqli::get_warnings — Get result of SHOW WARNINGS<br>mysqli::$insert_id — 返回最后一条插入语句产生的自增 ID<br>mysqli::kill — 让服务器杀掉一个 MySQL 线程<br>mysqli::more_results — 检查批量查询中是否还有查询结果<br>mysqli::next_result — 为读取 multi_query 执行之后的下一个结果集做准备<br>mysqli::options — 设置选项<br>mysqli::ping — ping 一个连接，或者如果连接处于断开状态，重新连接<br>mysqli::poll — 轮询连接<br>mysqli::reap_async_query — 获取异步查询的结果<br>mysqli::refresh — 刷新<br>mysqli::release_savepoint — 从当前事务的保存点中移除一个命名保存点<br>mysqli::rpl_query_type — 返回 RPL 查询类型<br>mysqli::savepoint — 在当前事务中增加一个命名保存点<br>mysqli::set_charset — 设置默认字符编码<br>mysqli::set_local_infile_default — 取消用户指定的回调函数<br>mysqli::set_local_infile_handler — 设置 LOAD DATA LOCAL INFILE 命令的回调函数<br>mysqli::$sqlstate — 返回上一次 SQL 操作的 SQLSTATE 错误信息<br>mysqli::store_result — 转移上一次查询返回的结果集<br>mysqli::$thread_id — 返回当前连接的线程 ID<br>mysqli::thread_safe — 返回是否是线程安全的</p><h3 id="mysqli-stmt-预编译-SQL-语句"><a href="#mysqli-stmt-预编译-SQL-语句" class="headerlink" title="mysqli_stmt 预编译 SQL 语句"></a>mysqli_stmt 预编译 SQL 语句</h3><p>mysqli<em>stmt :: prepare - 准备一条SQL语句以便执行<br>mysqli<em>stmt :: bind_param - 将变量作为参数绑定到预准备语句<br>mysqli_stmt :: </em></em> construct - 构造一个新的mysqli_stmt对象<br>mysqli_stmt :: $ num_rows/mysqli_num_rows() - 返回语句结果集中的行数<br>mysqli_stmt :: $ param_count - 返回给定语句的参数个数<br>mysqli_stmt :: $ errno - 返回最近语句调用的错误代码<br>mysqli_stmt :: $ error_list - 返回上一个执行语句的错误列表<br>mysqli_stmt :: $ error - 返回上一个语句错误的字符串描述<br>mysqli_stmt :: execute - 执行准备好的Query<br>mysqli_stmt :: fetch - 将预准备语句的结果提取到绑定变量中<br>mysqli_stmt :: close - 关闭准备好的语句</p><p>mysqli_stmt :: $ affected_rows - 返回上次执行的语句更改，删除或插入的总行数<br>mysqli_stmt :: attr_get - 用于获取语句属性的当前值<br>mysqli_stmt :: attr_set - 用于修改预准备语句的行为<br>mysqli_stmt :: bind_result - 将变量绑定到结果存储的预准备语句<br>mysqli_stmt :: data_seek - 寻找语句结果集中的任意行<br>mysqli_stmt :: fetch - 将预准备语句的结果提取到绑定变量中<br>mysqli_stmt :: $ field_count - 返回给定语句中的字段数<br>mysqli_stmt :: free_result - 释放给定语句句柄的存储结果内存<br>mysqli_stmt :: get_result - 从预准备语句中获取结果集<br>mysqli_stmt :: get_warnings - 获取SHOW WARNINGS的结果<br>mysqli_stmt :: $ insert_id - 获取先前INSERT操作生成的ID<br>mysqli_stmt :: more_results - 检查多个查询是否有更多查询结果<br>mysqli_stmt :: next_result - 从多个查询中读取下一个结果<br>mysqli_stmt :: reset - 重置预准备语句<br>mysqli_stmt :: result_metadata - 从预准备语句返回结果集元数据<br>mysqli_stmt :: send_long_data - 以块为单位发送数据<br>mysqli_stmt :: $ sqlstate - 从前一个语句操作返回SQLSTATE错误<br>mysqli_stmt :: store_result - 从预准备语句中传输结果集</p><h3 id="mysqli-result-从一个数据库查询中获取的结果集"><a href="#mysqli-result-从一个数据库查询中获取的结果集" class="headerlink" title="mysqli_result 从一个数据库查询中获取的结果集"></a>mysqli_result 从一个数据库查询中获取的结果集</h3><p>mysqli_result :: fetch_all - 将所有结果行提取为关联数组，数字数组或两者<br>mysqli_result :: fetch_array - 将结果行提取为关联行，数字数组或两者<br>mysqli_result :: fetch_assoc/mysqli_fetch_assoc() - 将结果行作为关联数组获取<br>mysqli_result :: $ lengths - 返回结果集中当前行的列长度<br>mysqli_result :: $ num_rows - 获取结果中的行数</p><p>mysqli_result :: $ current_field - 获取结果指针的当前字段偏移量<br>mysqli_result :: data_seek - 将结果指针调整为结果中的任意行<br>mysqli_result :: fetch_field_direct - 获取单个字段的元数据<br>mysqli_result :: fetch_field - 返回结果集中的下一个字段<br>mysqli_result :: fetch_fields - 返回表示结果集中字段的对象数组<br>mysqli_result :: fetch_object - 将结果集的当前行作为对象返回<br>mysqli_result :: fetch_row - 将结果行作为枚举数组<br>mysqli_result :: $ field_count - 获取结果中的字段数<br>mysqli_result :: field_seek - 将结果指针设置为指定的字段偏移量<br>mysqli_result :: free - 释放与结果相关的内存</p><hr><p>相关链接：<br><a href="https://hyqskevin.github.io/2019/02/15/mysql/">mysql 学习笔记</a><br><a href="https://hyqskevin.github.io/2019/01/21/php-notes2/">PHP &amp; MySQL learning notes (3)</a><br><a href="https://hyqskevin.github.io/2018/10/28/w3school-php/">PHP &amp; MySQL learning notes (1)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于PHP和MySQL版本问题，对 &lt;a href=&quot;https://hyqskevin.github.io/2018/10/28/w3school-php/#3-mySQL&quot;&gt;PHP &amp;amp; MySQL learning notes (1)&lt;/a&gt; 中曾经写过用的PHP操作MySQL数据库进行笔记更新&lt;br&gt;完善 &lt;a href=&quot;https://hyqskevin.github.io/2019/01/21/php-notes2/#MySQL&quot;&gt;PHP &amp;amp; MySQL learning notes (3)&lt;/a&gt; 中的代码&lt;br&gt;重新用 MySQLi (面向对象) MySQLi (面向过程) PDO 三种方式演示PHP操作MySQL&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="php" scheme="https://hyqskevin.github.io/tags/php/"/>
    
      <category term="mysql" scheme="https://hyqskevin.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>看论文了嘛</title>
    <link href="https://hyqskevin.github.io/2019/03/01/paper/"/>
    <id>https://hyqskevin.github.io/2019/03/01/paper/</id>
    <published>2019-03-01T15:48:06.000Z</published>
    <updated>2019-03-13T15:55:11.535Z</updated>
    
    <content type="html"><![CDATA[<p>paper page test.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;paper page test.&lt;/p&gt;

      
    
    </summary>
    
      <category term="paper" scheme="https://hyqskevin.github.io/categories/paper/"/>
    
    
  </entry>
  
  <entry>
    <title>好耶 是python -- 那些神奇的py代码</title>
    <link href="https://hyqskevin.github.io/2019/03/01/nice-python/"/>
    <id>https://hyqskevin.github.io/2019/03/01/nice-python/</id>
    <published>2019-03-01T15:46:41.000Z</published>
    <updated>2019-08-26T01:50:09.769Z</updated>
    
    <content type="html"><![CDATA[<p>nice python page test.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nice python page test.&lt;/p&gt;

      
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
  </entry>
  
  <entry>
    <title>这周上Github了吗 -- 那些有意思的项目收集</title>
    <link href="https://hyqskevin.github.io/2019/03/01/github-repo/"/>
    <id>https://hyqskevin.github.io/2019/03/01/github-repo/</id>
    <published>2019-03-01T15:33:15.000Z</published>
    <updated>2019-08-26T01:48:33.233Z</updated>
    
    <content type="html"><![CDATA[<p>gtihub repository page test.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gtihub repository page test.&lt;/p&gt;

      
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
  </entry>
  
</feed>
