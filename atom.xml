<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MonoShow</title>
  
  <subtitle>Monologue from Kevin_W</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hyqskevin.github.io/"/>
  <updated>2020-12-16T06:29:38.138Z</updated>
  <id>https://hyqskevin.github.io/</id>
  
  <author>
    <name>Kevin W</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Temer EDH combo</title>
    <link href="https://hyqskevin.github.io/2020/11/26/EDH-combo/"/>
    <id>https://hyqskevin.github.io/2020/11/26/EDH-combo/</id>
    <published>2020-11-26T06:00:00.000Z</published>
    <updated>2020-12-16T06:29:38.138Z</updated>
    
    <content type="html"><![CDATA[<p>List the useful 2-4 cards combos in my EDH decks.</p><p>Color now mostly used: RUG</p><p>Commander now mostly used</p><ul><li>Kalamax, the Stormsire 风暴君父卡拉马科斯 | combo</li><li>Xyris, the Writhing Storm 纠拧风暴灾里斯 | mid &amp; token</li><li>Haldan, Avid Arcanist 热切奥术师哈丹 / Pako, Arcane Retriever 奥术猎犬帕科 | enchantment combo</li><li>Omnath, Locus of the Roil 狂搅核欧那斯 | landfall / element aggro</li><li>Animar, Soul of Elements 元素之魂阿尼玛 | combo</li></ul><a id="more"></a><p>Commander now in testing:</p><ul><li>Brago, King Eternal 不朽国王布莱戈</li><li>Derevi, Empyrial Tactician 穹光策士德蕾薇</li><li>Golos, Tireless Pilgrim 不倦朝圣械戈罗斯</li><li>Sisay, Weatherlight Captain 晴空号船长西赛</li><li>Omnath, Locus of Creation 生机核欧那斯</li></ul><h3 id="Combos-in-Kalamax"><a href="#Combos-in-Kalamax" class="headerlink" title="Combos in Kalamax"></a>Combos in Kalamax</h3><p><strong>Kalamax, the Stormsire + Reverberate/Twincast… =&gt; Infinite large Kalamax =&gt; Soul’s fire</strong></p><ul><li>prerequisites:<br>Kalamax tapped<br>No instants played this turn<br>response the instant or sorcery from other players<br>Enough mana to cast spells</li></ul><ol><li>Cast any copy instant</li><li>Kalamax triggers (first Instant played this turn), copying instant</li><li>Have the copy and target the original</li><li>Kalamax triggers off of the copying, gaining a +1/+1 counter</li><li>The copy resolves, creating another copy</li><li>Repeat steps</li><li>In your turn you get infinite large Kalamax</li></ol><p><strong>Kalamax, the Stormsire + Chandra’s Ignition + Reverberate/Twincast =&gt; Infinite damage/large Kalamax</strong></p><ul><li>prerequisites:<br>Kalamax tapped<br>No instants played this turn<br>Enough mana to cast spells</li></ul><ol><li>Cast Chandra’s Ignition, holding priority</li><li>Cast Reverberate targeting Chandra’s Ignition</li><li>Kalamax triggers (first Instant played this turn), copying Reverberate</li><li>Have the copy of Reverberate target the original</li><li>Kalamax triggers off of the copying, gaining a +1/+1 counter</li><li>The copy of Reverberate resolves, creating another copy</li><li>Repeat steps 4-6 until Kalamax is adequately large, then copy Chandra’s Ignition with Reverberate, ending the loop and dealing an arbitrarily large amount of damage to your opponents (and each other creature)</li></ol><p><strong>Kalamax, the Stormsire + Ral, Storm Conduit + Reverberate/Twincast… =&gt; Infinite damage/large Kalamax</strong></p><ul><li>prerequisites:<br>Kalamax tapped<br>No instants played this turn<br>response the instant or sorcery from other players<br>Enough mana to cast spells</li></ul><ol><li>Cast any copy instant, triggering Ral and Kalamax, copying instant</li><li>Have the copy and target the original, triggering Ral</li><li>Kalamax triggers off of the copying, gaining a +1/+1 counter</li><li>The copy resolves, creating another copy, triggering Ral</li><li>Repeat steps until Ral trigger infinite times, then copy the first ability other player played, ending the loop and dealing an arbitrarily large amount of damage to your opponents and get infinite large Kalamax</li></ol><p><strong>Fury Storm + Ral, Storm Conduit =&gt; Infinite damage</strong></p><ul><li>prerequisites:<br>must have cast your commander at least once<br>2RR mana available</li></ul><ol><li>Cast your instant or sorcery, triggering Ral</li><li>Resolve the Ral trigger and respond to the instant or sorcery by casting Fury Storm targeting the instant or sorcery which triggers Fury Storm and Ral</li><li>Place the Ral trigger on top and the Fury Storm trigger below it and resolve the Ral trigger</li><li>Resolve the Fury Storm trigger targeting the original Fury Storm with the copy which triggers Ral</li><li>Resolve the Ral trigger and resolve the Fury Storm copy copying Fury Storm and triggering Ral</li><li>Repeat step 5</li></ol><p><a href="https://CommanderSpellbook.com/?id=5022" target="_blank" rel="noopener">https://CommanderSpellbook.com/?id=5022</a></p><p><strong>Heart Defence/Chord of Calling =&gt; Kiki-Jiki, Mirror Breaker + Aphetto Alchemist/Corridor Monitor =&gt; Infinite combat damage + blue mana =&gt; Thassa’s Oracle</strong></p><ul><li>prerequisites:<br>Kiki-Jiki, Mirror Breaker and Aphetto Alchemist on the battlefield<br>Thassa’s Oracle in hand and UU mana to cast it</li></ul><ol><li>Activate Kiki-Jiki, targeting Aphetto Alchemist to create a hasty token copy of it</li><li>Activate the token’s ability to untap Kiki-Jiki</li><li>Repeat the loop to generate an arbitrarily large number of tapped Aphetto Alchemist tokens, each of which is worth blue mana devotion</li><li>Cast Thassa’s Oracle</li><li>As your devotion to blue mana is greater than the number of cards in your library, you win the game with its ETB trigger</li></ol><p><strong>Primal Amulet + Frantic Search + Narset’s Reversal =&gt; Infinite colored mana/card draw/storm count =&gt; brain freeze</strong></p><ul><li>prerequisites:<br>primal amulet with 3 counters<br>frantic search and narset’s reversal in hand<br>access to 1UU mana from lands</li></ul><ol><li>cast frantic search for 1U mana (reduced by primal amulet)</li><li>let the trigger from primal amulet resolve to transform primal amulet in to primal wellspring</li><li>you now have an extra land, use primal wellspring to tap for blue mana and an additional blue mana from an other land to pay for narset’s reversal, creating a copy of narset’s reversal</li><li>let the copy of narset’s reversal target the original narset’s reversal to bounce it and create an other copy</li><li>the second copy of narset’s reversal targets frantic search, returning it to your hand and creating a copy of frantic search to untap 3 lands (must untap primal wellspring) and loot 2 cards</li><li>tap 3 lands for 2U mana and use the blue mana from primal wellspring + 2 mana from the other lands to cast frantic search</li><li>let the copy of frantic search resolve to untap 3 lands and loot 2</li><li>tap 3 lands for 1U mana and use the blue manaa from primal wellspring blue mana from the other lands start the loop again at step 3 by casting narset’s reversal from primal wellspring, netting you 1 mana and 2 loots each loop</li></ol><p><a href="https://commanderspellbook.com/?id=4843" target="_blank" rel="noopener">https://commanderspellbook.com/?id=4843</a></p><p><strong>Mizzix of the Izmagnus + Bonus Round + Frantic Search + Narset’s Reversal =&gt; Infinite mana/loot/storm count =&gt; brain freeze</strong></p><ul><li>prerequisites:<br>Bonus Round, Frantic Search and Narset’s Reversal in hand<br>Mizzix on the battlefield<br>You have at least 1 experience counter<br>Ability to produce a (R/U)(R/U)(R/U) mana from lands</li></ul><ol><li>Cast Bonus Round for RR</li><li>Let the Mizzix trigger and bonus round resolve, you now have 2 experience counters</li><li>Cast Frantic search for U (reduced by mizzix)</li><li>Let the copy from bonus rounds resolve to loot 2 cards, untap 3 lands that can tap for at least UU</li><li>Cast Narset’s Reversal for UU, let the copy from bonus rounds resolve, targeting the original Narset’s Reversal</li><li>This bounces the original and makes a new copy which targets the original frantic search</li><li>This bounces the original frantic search and creates a new copy</li><li>Let the frantic search copy resolve to loot 2 cards and untap 3 lands</li><li>You now have frantic search and narset’s reversal back in your hand and can start the loop again</li></ol><p><a href="https://CommanderSpellbook.com/?id=4930" target="_blank" rel="noopener">https://CommanderSpellbook.com/?id=4930</a></p><p><strong>High Tide + Archaeomancer + Snap =&gt; Infinite storm count/colored mana =&gt; brain freeze</strong></p><ul><li>prerequisites:<br>All cards in hand<br>5 untapped Islands under your control</li></ul><p>Tap 1 Island, producing U, to cast High Tide<br>Tap 2 Islands, producing 4U, to cast Archaeomancer, getting back High Tide<br>Tap 1 Island, producing 2U, to cast High Tide, floating U<br>Tap 1 Island, producing 3U to cast Snap to return Archaeomancer and untap two islands, floating 2U<br>Tap 2 Islands, procuing 6U, to cast Archaeomancer, returning Snap and floating 2U<br>Repeat steps 4-5</p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><hr><hr><p>link:<br><a href="https://scryfall.com/" target="_blank" rel="noopener">Scryfall: card search</a><br><a href="http://www.mtgtop8.com/" target="_blank" rel="noopener">MTGTop8</a><br><a href="https://tappedout.net/mtg-deck-builder/" target="_blank" rel="noopener">MTG Deck Builder</a><br><a href="https://edhrec.com/" target="_blank" rel="noopener">EDHRec</a><br><a href="https://commanderspellbook.com/" target="_blank" rel="noopener">commander Spellbook</a><br><a href="https://cedh-decklist-database.com/" target="_blank" rel="noopener">cEDH Decklist Database</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;List the useful 2-4 cards combos in my EDH decks.&lt;/p&gt;
&lt;p&gt;Color now mostly used: RUG&lt;/p&gt;
&lt;p&gt;Commander now mostly used&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kalamax, the Stormsire 风暴君父卡拉马科斯 | combo&lt;/li&gt;
&lt;li&gt;Xyris, the Writhing Storm 纠拧风暴灾里斯 | mid &amp;amp; token&lt;/li&gt;
&lt;li&gt;Haldan, Avid Arcanist 热切奥术师哈丹 / Pako, Arcane Retriever 奥术猎犬帕科 | enchantment combo&lt;/li&gt;
&lt;li&gt;Omnath, Locus of the Roil 狂搅核欧那斯 | landfall / element aggro&lt;/li&gt;
&lt;li&gt;Animar, Soul of Elements 元素之魂阿尼玛 | combo&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="notes" scheme="https://hyqskevin.github.io/categories/notes/"/>
    
    
      <category term="MTG" scheme="https://hyqskevin.github.io/tags/MTG/"/>
    
  </entry>
  
  <entry>
    <title>Vue功能实现和使用技巧</title>
    <link href="https://hyqskevin.github.io/2020/11/10/vue-notes/"/>
    <id>https://hyqskevin.github.io/2020/11/10/vue-notes/</id>
    <published>2020-11-10T02:20:03.000Z</published>
    <updated>2020-12-05T09:47:25.044Z</updated>
    
    <content type="html"><![CDATA[<p>汇总记录前端开发时，使用 Vue 框架遇到的功能实现和开发技巧。</p><a id="more"></a><h2 id="Vue-动态组件使用"><a href="#Vue-动态组件使用" class="headerlink" title="Vue 动态组件使用"></a>Vue 动态组件使用</h2><p>动态组件功能用于在不同组件之间进行动态切换，可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 is attribute 来实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `currentComponent` 改变时显示的组件同时改变</span></span><br><span class="line">&lt;component :is=<span class="string">"currentComponent"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;button @click=<span class="string">"(currentComponent === 'A') ? 'B':'A'"</span>&gt;Switch&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/引入组件A以及组件B</span></span><br><span class="line"><span class="regexp">import A from "./</span>a<span class="string">"</span></span><br><span class="line"><span class="string">import B from "</span>./b<span class="string">"</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  components: &#123;A, B&#125;,</span></span><br><span class="line"><span class="string">  data () &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      //默认显示组件A，若字符串为B则显示组件B,name为component声明</span></span><br><span class="line"><span class="string">      currentComponent: 'A'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>v-show，v-if，:is 之间的区别</li></ul><p><code>v-show</code> 会同时加载两个组件，两个组件的生命周期都会触发，会造成不必要的性能浪费，而且切换的时候不会再创造挂载一次，无法重新渲染。<br><code>v-if</code> 不会造成同时加载两个组件，但 v-if 每次切换都会创造挂载一次，如果没有重新渲染的需要，会造成性能浪费。<br><code>:is</code> 可以通过 keep-alive 标签缓存，被该标签包裹的组件会被缓存下来，每次点击都不会重新渲染，避免了重渲染导致的性能问题。<code>include</code> 和 <code>exclude</code> 属性也允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 逗号分隔字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"a,b"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (使用 v-bind) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"/a|b/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Array (use v-bind) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"['a', 'b']"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>动态路由用于把某种模式匹配到的所有路由，全都映射到同个组件，可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果。一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，可以在每个组件内使用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">routes: [</span><br><span class="line"><span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User &#125;,</span><br><span class="line">],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="页面跳转和导航"><a href="#页面跳转和导航" class="headerlink" title="页面跳转和导航"></a>页面跳转和导航</h2><h3 id="定义链接实现声明式导航"><a href="#定义链接实现声明式导航" class="headerlink" title=" 定义链接实现声明式导航"></a><router-link> 定义链接实现声明式导航</router-link></h3><p><code>&lt;router-link :to=&quot;...&quot;&gt;</code> 内部调用 <code>router.push</code> 方法实现页面导航</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name: 'detail', params: &#123;name: 1&#125;&#125;"</span>&gt;</span> xxx <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name: 'detail', query: &#123;id: 1&#125;&#125;"</span>&gt;</span> xxx <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>this.$route.params</code> 或 <code>this.$route.params</code> 获取路由参数。</li></ul><h3 id="router-实例实现编程式导航"><a href="#router-实例实现编程式导航" class="headerlink" title="router 实例实现编程式导航"></a>router 实例实现编程式导航</h3><p>在 Vue 实例内部，可以通过 <code>$router</code> 访问路由实例，可以调用 <code>this.$router.push</code> 方法，向 history 栈添加一个新的记录，点击浏览器后退按钮时也可以回到之前的 URL。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">'home'</span>)</span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;)</span><br><span class="line"><span class="comment">// 命名的路由/user/123</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">uid</span>: <span class="string">'123'</span> &#125; &#125;) <span class="comment">// 刷新后参数会被清空</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// 刷新后参数不会被清空</span></span><br><span class="line"><span class="comment">// 带查询参数，/home?uid=123</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span>, <span class="attr">query</span>: &#123; <span class="attr">uid</span>: <span class="string">'123'</span> &#125; &#125;) <span class="comment">// 刷新后不会被清空</span></span><br></pre></td></tr></table></figure><ul><li><code>router.replace(&#39;&#39;)</code> 跳转页面会替换掉原有的 history 记录</li><li><code>router.go(n)</code> 在 history 记录中前进或后退多少步</li></ul><h2 id="keep-alive-网页性能优化"><a href="#keep-alive-网页性能优化" class="headerlink" title="keep-alive 网页性能优化"></a>keep-alive 网页性能优化</h2><p>keep-alive 主要用于保留组件状态或避免重新渲染 DOM 导致性能降低，通常都会在 <code>app.vue</code> 的 <code>&lt;router-view/&gt;</code> 外面加一层 <code>&lt;keep-alive&gt;</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做也会导致一些问题，当组件的值更新后组件没有被重新渲染，做到动态显示需要使用额外生命周期函数 <code>activated</code><br>进入页面会执行 mounted 和 activated，当修改值后再次进入首页不会再执行 mounted 触发新的数据请求，但是 activated 会继续执行。可以在 activated 函数中判断新数据和前一次显示是否相同，如果不同再次触发 ajax 数据请求。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">   <span class="keyword">this</span>.lastData = <span class="keyword">this</span>.data;</span><br><span class="line">   <span class="keyword">this</span>.getNewData();</span><br><span class="line">&#125;</span><br><span class="line">activated () &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.lastData !== <span class="keyword">this</span>.data) &#123;</span><br><span class="line">      <span class="keyword">this</span>.lastData = <span class="keyword">this</span>.data;</span><br><span class="line">      <span class="keyword">this</span>.getNewData();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在路由更新后页面由于 keep-alive 的缓存不会执行 mounted 触发刷新，需要设置路由的 key 值，在每次进入页面时比较路由名称，若不相同则刷新页面。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*App.vue*/</span></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">   &lt;router-view :key=<span class="string">"key"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'App',</span></span><br><span class="line"><span class="regexp">  computed: &#123;</span></span><br><span class="line"><span class="regexp">    key () &#123;</span></span><br><span class="line"><span class="regexp">      return this.$route.name !== undefined</span></span><br><span class="line"><span class="regexp">        ? this.$route.name + +new Date()</span></span><br><span class="line"><span class="regexp">        : this.$route + +new Date()</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="Vuex-数据防刷新丢失"><a href="#Vuex-数据防刷新丢失" class="headerlink" title="Vuex 数据防刷新丢失"></a>Vuex 数据防刷新丢失</h2><p>引入 vuex-persist 插件将状态保存至 cookie 或者 localStorage 中，刷新后数据不丢失。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VuexPersistence <span class="keyword">from</span> <span class="string">'vuex-persist'</span></span><br><span class="line"><span class="keyword">const</span> vuexLocal = <span class="keyword">new</span> VuexPersistence(&#123;</span><br><span class="line">storage: <span class="built_in">window</span>.localStorage,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  plugins: [vuexLocal.plugin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="自定义指令避免误触和多次点击"><a href="#自定义指令避免误触和多次点击" class="headerlink" title="自定义指令避免误触和多次点击"></a>自定义指令避免误触和多次点击</h2><p>使用 Vue.directive 自定义防误触指令</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> preventReClick = Vue.directive(<span class="string">'preventReClick'</span>, &#123;</span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 增加监听事件</span></span><br><span class="line">el.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (!el.disabled) &#123;</span><br><span class="line">el.disabled = <span class="literal">true</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">el.disabled = <span class="literal">false</span></span><br><span class="line">&#125;, binding.value || <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; preventReClick &#125;</span><br></pre></td></tr></table></figure><h2 id="制作可复用组件"><a href="#制作可复用组件" class="headerlink" title="制作可复用组件"></a>制作可复用组件</h2><p>复用组件需要在样式和功能上做到继承和迭代，是在系统整体设计时抽象出的组件，多为布局组件，不涉及详细的功能实现。组件需要做到高内聚低耦合，组件内独立交互，功能受控于组件本身。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按钮组件抽象，样式设置为外部继承 cname，和内部自定义 button，留出按钮名称 title 和 &lt;slot&gt; 插槽作为具体内容的补充空间</span></span><br><span class="line">&lt;div :<span class="class"><span class="keyword">class</span></span>=<span class="string">"[button, cname]"</span>&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; title &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;slot /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'BigBtn',</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 通过 props 传入外部参数</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    cname: &#123;</span></span><br><span class="line"><span class="regexp">      type: String,</span></span><br><span class="line"><span class="regexp">      default: ''</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    title: &#123;</span></span><br><span class="line"><span class="regexp">      type: String,</span></span><br><span class="line"><span class="regexp">      default: 'title'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 设置内部定义的样式</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      button: 'button'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=<span class="string">"stylus"</span>&gt;</span><br><span class="line"><span class="comment">// 引入样式</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"~@/styles/button.styl"</span></span><br><span class="line">.button</span><br><span class="line">  bigBtn() <span class="comment">// 默认样式</span></span><br><span class="line">.blueBtn</span><br><span class="line">  bigBtn($btnColor: $btnBlue) <span class="comment">// cname 传入 blueBtn 设置颜色为蓝色</span></span><br><span class="line">.greenBtn</span><br><span class="line">  bigBtn($btnColor: $btnGreen) <span class="comment">// cname 传入 greenBtn 设置颜色为绿色</span></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><h2 id="上传文件功能"><a href="#上传文件功能" class="headerlink" title="上传文件功能"></a>上传文件功能</h2><p>使用 element-ui 的 upload 功能实现图片展示，上传和读取，on-change 触发文件状态改变时的钩子，调用上传照片 api 将照片数据传递到后台；on-preview 用于显示已上传的图片的缩略图；传递多个文件时文件列表存储在 file-list 中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span></span></span><br><span class="line"><span class="tag"><span class="attr">action</span>=<span class="string">"actionUrl"</span></span></span><br><span class="line"><span class="tag"><span class="attr">list-type</span>=<span class="string">"picture-card"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"upload"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:file-list</span>=<span class="string">"fileList"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:auto-upload</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:on-change</span>=<span class="string">"getFile"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:on-preview</span>=<span class="string">"handlePictureCardPreview"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">"tip"</span> <span class="attr">class</span>=<span class="string">"el-upload__tip"</span>&gt;</span>上传一张jpg/png文件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-icon</span> <span class="attr">class</span>=<span class="string">"el-icon-plus"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文件信息</span></span><br><span class="line">getFile (file) &#123;</span><br><span class="line">  <span class="keyword">let</span> uid = <span class="keyword">this</span>.$store.state.currentUid</span><br><span class="line">  <span class="comment">// 调用上传照片的api</span></span><br><span class="line">  api._updImage(uid, <span class="keyword">this</span>.aid, res).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若上传 base64 位图片需要进行转码之后调用 api 上传：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图片转base64</span></span><br><span class="line">getBase64 (file) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">    <span class="keyword">let</span> imgResult = <span class="string">''</span></span><br><span class="line">    reader.readAsDataURL(file)</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      imgResult = reader.result</span><br><span class="line">    &#125;</span><br><span class="line">    reader.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(imgResult)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vuex-监听状态变更"><a href="#Vuex-监听状态变更" class="headerlink" title="Vuex 监听状态变更"></a>Vuex 监听状态变更</h2><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">  updFlag: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 添加计算属性，依赖值改变时重新计算</span></span><br><span class="line">getters: &#123;</span><br><span class="line">  updFlag: <span class="function"><span class="params">state</span> =&gt;</span> state.updFlag</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 执行状态变更</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  updateFlag (state, update) &#123;</span><br><span class="line">    state.updFlag = update</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="element-ui-按需引入"><a href="#element-ui-按需引入" class="headerlink" title="element-ui 按需引入"></a>element-ui 按需引入</h3><p>通过借助 <code>babel-plugin-component</code> 或直接修改 <code>.babelrc</code> 文件，我们可以只引入需要的组件，以达到减小项目体积的目的。</p><p>引入插件：<code>npm install babel-plugin-component -D</code><br>修改 babel 配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"component"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line">        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>在 src 文件夹中 plugins 文件夹内新建一个 element.js 文件，导入需要的组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入自己需要的组件</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">Select,</span><br><span class="line">Option,</span><br><span class="line">OptionGroup,</span><br><span class="line">Input,</span><br><span class="line">Tree,</span><br><span class="line">Dialog,</span><br><span class="line">Row,</span><br><span class="line">Col,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">install: <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">Vue.use(Select)</span><br><span class="line">Vue.use(Option)</span><br><span class="line">Vue.use(OptionGroup)</span><br><span class="line">Vue.use(Input)</span><br><span class="line">Vue.use(Tree)</span><br><span class="line">Vue.use(Dialog)</span><br><span class="line">Vue.use(Row)</span><br><span class="line">Vue.use(Col)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> element</span><br></pre></td></tr></table></figure><p>最后在 main.js 中引入 element.js 文件 <code>import &#39;./plugins/element.js&#39;</code></p><h3 id="表单设置日期限制"><a href="#表单设置日期限制" class="headerlink" title="表单设置日期限制"></a>表单设置日期限制</h3><p>element-ui 支持在创建表单时使用规则校验，可以在校验中自定义校验规则。</p><p>在日期选择时需要实现截止日期必须大于等于开始日期，在 vue 组件中定义表单数据和校验规则并在 endDate 中自定义校验规则 <code>checkEnd</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  <span class="keyword">return</span>: &#123;</span><br><span class="line">    ruleForm: &#123;</span><br><span class="line">      startDate: <span class="string">''</span>,</span><br><span class="line">      endDate: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    rules: &#123;</span><br><span class="line">      startDate: [</span><br><span class="line">        &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'请选择开始日期'</span>, <span class="attr">trigger</span>: <span class="string">'change'</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">      endDate: [</span><br><span class="line">        &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'请选择截止日期'</span>, <span class="attr">trigger</span>: <span class="string">'change'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">validator</span>: checkEnd, <span class="attr">trigger</span>: <span class="string">'change'</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 data 中设置变量 <code>checkEnd</code> 来实现校验规则，校验错误时返回提示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  <span class="keyword">let</span> checkEnd = <span class="function">(<span class="params">rule, value, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> startDate = <span class="keyword">this</span>.ruleForm.startDate</span><br><span class="line">    <span class="keyword">if</span> (startDate === <span class="string">''</span>) &#123;</span><br><span class="line">      callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'请先选择开始日期！'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>(startDate)</span><br><span class="line">    <span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>(value)</span><br><span class="line">    <span class="keyword">if</span> ((start !== <span class="string">''</span>) &amp;&amp; (end &lt; start)) &#123;</span><br><span class="line">      callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'结束日期不能小于开始日期！'</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表单身份证校验"><a href="#表单身份证校验" class="headerlink" title="表单身份证校验"></a>表单身份证校验</h3><p>通过自定义表单校验规则进行身份证的校验，新建 idValidate.js 文件实现身份证校验算法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> checkId = <span class="function">(<span class="params">rule, value, callback</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> errorMsg = idValidate(value)</span><br><span class="line"><span class="keyword">if</span> (errorMsg !== <span class="string">''</span>) &#123;</span><br><span class="line">callback(<span class="keyword">new</span> <span class="built_in">Error</span>(errorMsg))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* idValidate.js */</span></span><br><span class="line"><span class="comment">// 身份校验的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">isIdentityId</span>(<span class="params">identityId</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> pattern = <span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span> <span class="comment">// 15或18位长度或格式校验</span></span><br><span class="line"><span class="comment">// 地区校验</span></span><br><span class="line"><span class="keyword">const</span> aCity = &#123;</span><br><span class="line"><span class="number">11</span>: <span class="string">'北京'</span>,</span><br><span class="line"><span class="number">12</span>: <span class="string">'天津'</span>,</span><br><span class="line"><span class="number">13</span>: <span class="string">'河北'</span>,</span><br><span class="line"><span class="number">14</span>: <span class="string">'山西'</span>,</span><br><span class="line"><span class="number">15</span>: <span class="string">'内蒙古'</span>,</span><br><span class="line"><span class="number">21</span>: <span class="string">'辽宁'</span>,</span><br><span class="line"><span class="number">22</span>: <span class="string">'吉林'</span>,</span><br><span class="line"><span class="number">23</span>: <span class="string">'黑龙江'</span>,</span><br><span class="line"><span class="number">31</span>: <span class="string">'上海'</span>,</span><br><span class="line"><span class="number">32</span>: <span class="string">'江苏'</span>,</span><br><span class="line"><span class="number">33</span>: <span class="string">'浙江'</span>,</span><br><span class="line"><span class="number">34</span>: <span class="string">'安徽'</span>,</span><br><span class="line"><span class="number">35</span>: <span class="string">'福建'</span>,</span><br><span class="line"><span class="number">36</span>: <span class="string">'江西'</span>,</span><br><span class="line"><span class="number">37</span>: <span class="string">'山东'</span>,</span><br><span class="line"><span class="number">41</span>: <span class="string">'河南'</span>,</span><br><span class="line"><span class="number">42</span>: <span class="string">'湖北'</span>,</span><br><span class="line"><span class="number">43</span>: <span class="string">'湖南'</span>,</span><br><span class="line"><span class="number">44</span>: <span class="string">'广东'</span>,</span><br><span class="line"><span class="number">45</span>: <span class="string">'广西'</span>,</span><br><span class="line"><span class="number">46</span>: <span class="string">'海南'</span>,</span><br><span class="line"><span class="number">50</span>: <span class="string">'重庆'</span>,</span><br><span class="line"><span class="number">51</span>: <span class="string">'四川'</span>,</span><br><span class="line"><span class="number">52</span>: <span class="string">'贵州'</span>,</span><br><span class="line"><span class="number">53</span>: <span class="string">'云南'</span>,</span><br><span class="line"><span class="number">54</span>: <span class="string">'西藏'</span>,</span><br><span class="line"><span class="number">61</span>: <span class="string">'陕西'</span>,</span><br><span class="line"><span class="number">62</span>: <span class="string">'甘肃'</span>,</span><br><span class="line"><span class="number">63</span>: <span class="string">'青海'</span>,</span><br><span class="line"><span class="number">64</span>: <span class="string">'宁夏'</span>,</span><br><span class="line"><span class="number">65</span>: <span class="string">'新疆'</span>,</span><br><span class="line"><span class="number">71</span>: <span class="string">'台湾'</span>,</span><br><span class="line"><span class="number">81</span>: <span class="string">'香港'</span>,</span><br><span class="line"><span class="number">82</span>: <span class="string">'澳门'</span>,</span><br><span class="line"><span class="number">91</span>: <span class="string">'国外'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出生日期验证</span></span><br><span class="line"><span class="keyword">const</span> sBirthday = (</span><br><span class="line">identityId.substr(<span class="number">6</span>, <span class="number">4</span>) +</span><br><span class="line"><span class="string">'-'</span> +</span><br><span class="line"><span class="built_in">Number</span>(identityId.substr(<span class="number">10</span>, <span class="number">2</span>)) +</span><br><span class="line"><span class="string">'-'</span> +</span><br><span class="line"><span class="built_in">Number</span>(identityId.substr(<span class="number">12</span>, <span class="number">2</span>))</span><br><span class="line">).replace(<span class="regexp">/-/g</span>, <span class="string">'/'</span>)</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(sBirthday)</span><br><span class="line"><span class="comment">// 身份证号码校验 最后4位  包括最后一位的数字/字母X</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> weights = [<span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> codes = <span class="string">'10X98765432'</span></span><br><span class="line"><span class="keyword">let</span> errorMsg = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; identityId.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">sum += identityId[i] * weights[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> last = codes[sum % <span class="number">11</span>] <span class="comment">// 计算出来的最后一位身份证号码</span></span><br><span class="line"><span class="keyword">if</span> (identityId === <span class="string">''</span>) &#123;</span><br><span class="line">errorMsg = <span class="string">'身份证号不能为空'</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pattern.exec(identityId)) &#123;</span><br><span class="line">errorMsg = <span class="string">'身份证长度或格式错误'</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!aCity[<span class="built_in">parseInt</span>(identityId.substr(<span class="number">0</span>, <span class="number">2</span>))]) &#123;</span><br><span class="line">errorMsg = <span class="string">'身份证地区非法'</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">sBirthday !==</span><br><span class="line">d.getFullYear() + <span class="string">'/'</span> + (d.getMonth() + <span class="number">1</span>) + <span class="string">'/'</span> + d.getDate()</span><br><span class="line">) &#123;</span><br><span class="line">errorMsg = <span class="string">'出生日期非法'</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (identityId[identityId.length - <span class="number">1</span>] !== last) &#123;</span><br><span class="line">errorMsg = <span class="string">'输入的身份证号校验码不正确'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> errorMsg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h2><ol><li><p>监听组件原生事件<br><code>@click.native=</code>可以在子组件监听根元素的原生事件，不需要通过<code>$emit</code>事件</p></li><li><p>ref 属性<br>给 DOM 元素或子组件注册引用信息，引用信息将会注册在父组件的 <code>$refs</code> 对象上，如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。<br>通过<code>this.$refs.ref</code>访问 dom 节点或组件实例(data)</p></li><li><p>回到顶部功能<br>使用 element-ui 中提供的功能实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;el-backtop</span><br><span class="line">target=<span class="string">".page-component__scroll .el-scrollbar__wrap"</span></span><br><span class="line">visibility-height=<span class="string">"200"</span></span><br><span class="line">right=<span class="string">"30"</span></span><br><span class="line">bottom=<span class="string">"30"</span></span><br><span class="line">&gt;</span><br><span class="line">up</span><br><span class="line">&lt;<span class="regexp">/el-backtop&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用 better-scroll 插件实现，通过监听下拉时 y 轴的移动距离显示上拉按钮，点击后触发返回顶部事件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回到开头</span></span><br><span class="line">toTop () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.toTop) &#123;</span><br><span class="line">    <span class="comment">// 延迟20ms后在1s内回到顶部</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    &#125;, <span class="number">20</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>render: h =&gt; h(App)</code><br>h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例。它来自单词 <code>hyperscript</code>，这个单词通常用在 virtual-dom 的实现中。hyperscript 本身指生成 HTML 结构的 script 脚本。 — Even You</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(App);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// h &lt;- createElement</span></span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h(App);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br></pre></td></tr></table></figure></li></ol><hr><p>参考资料：<br><a href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/essentials/navigation.html</a><br><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh/</a><br><a href="https://better-scroll.github.io/docs/zh-CN/" target="_blank" rel="noopener">https://better-scroll.github.io/docs/zh-CN/</a><br><a href="https://element.faas.ele.me/#/zh-CN/" target="_blank" rel="noopener">https://element.faas.ele.me/#/zh-CN/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇总记录前端开发时，使用 Vue 框架遇到的功能实现和开发技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="Vue" scheme="https://hyqskevin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Webpack程序打包学习笔记(3) —— Babel</title>
    <link href="https://hyqskevin.github.io/2020/07/13/Webpack_3/"/>
    <id>https://hyqskevin.github.io/2020/07/13/Webpack_3/</id>
    <published>2020-07-13T10:23:03.000Z</published>
    <updated>2020-12-16T07:09:03.349Z</updated>
    
    <content type="html"><![CDATA[<p>Babel 是一个 JavaScript 的静态分析编译器，在不需要执行代码的前提下对代码进行分析和处理。<br>要实现 Babel 从一个语法转换成另外一个语法，需要经过三个主要步骤：解析（Parse），转换（Transform），生成（Generate）。</p><p><a href="https://hyqskevin.github.io/2020/06/28/Webpack_1/">Webpack 程序打包学习笔记(1)</a><br><a href="https://hyqskevin.github.io/2020/07/05/Webpack_2/">Webpack 程序打包学习笔记(2)</a></p><a id="more"></a><h2 id="Babel-分析步骤"><a href="#Babel-分析步骤" class="headerlink" title="Babel 分析步骤"></a>Babel 分析步骤</h2><p>解析：指的是首先将代码经过词法解析和语法解析，最终生成一颗 AST（抽象语法树），在 Babel 中，语法解析器是 Babylon（@babel/parser）<br>转换：得到 AST 之后，可以对其进行遍历，在此过程中对节点进行添加、更新及移除等操作，Babel 中 AST 遍历工具是@babel/traverse<br>生成：经过一系列转换之后得到的一颗新树，要将树转换成代码，就是生成的过程，Babel 用到的是@babel/generator</p><p>使用@babel/parse 来生成 AST</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).default</span><br><span class="line"><span class="keyword">const</span> gen = <span class="built_in">require</span>(<span class="string">'@babel/generator'</span>).default</span><br><span class="line"><span class="comment">// 读取 source.js内容</span></span><br><span class="line"><span class="keyword">let</span> source = fs.readFileSync(<span class="string">'./source.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 babel.parse方法</span></span><br><span class="line">babel.parse(source, (err, ast) =&gt; &#123;</span><br><span class="line"><span class="comment">// ast就是树</span></span><br><span class="line"><span class="built_in">console</span>.log(ast)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用@babel/traverse，进行遍历，会得到一个类似 Html 结构的树形结构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">babel.parse(source, (err, ast) =&gt; &#123;</span><br><span class="line"><span class="comment">// console.log(ast)</span></span><br><span class="line"><span class="keyword">let</span> indent = <span class="string">''</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line"><span class="comment">// 进入节点</span></span><br><span class="line">enter(path) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(indent + <span class="string">'&lt;'</span> + path.node.type + <span class="string">'&gt;'</span>)</span><br><span class="line">indent += <span class="string">'  '</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 退出节点</span></span><br><span class="line">exit(path) &#123;</span><br><span class="line">indent = indent.slice(<span class="number">0</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(indent + <span class="string">'&lt;'</span> + <span class="string">'/'</span> + path.node.type + <span class="string">'&gt;'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用@babel/generator 进行生成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">babel.parse(source, (err, ast) =&gt; &#123;</span><br><span class="line"><span class="comment">// console.log(ast)</span></span><br><span class="line"><span class="keyword">let</span> indent = <span class="string">''</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 生成新的 ast，然后使用generator生成 code</span></span><br><span class="line">    <span class="built_in">console</span>.log(gen(ast).code);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Babel-做-ES6-语法转换"><a href="#Babel-做-ES6-语法转换" class="headerlink" title="Babel 做 ES6 语法转换"></a>Babel 做 ES6 语法转换</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>Babel 是 JavaScript 的一个编译器，能够将 ES6+ 语法转换为 ES5 语法。<br>Babel 本身自己带有 CLI（Command-Line Interface，命令行界面） 工具，可以单独安装使用：<code>npm i -D @babel/core @babel/cli</code><br>安装@babel/preset-env 进行语法转换，执行 CLI 的时候添加 —presets：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装开发依赖</span></span><br><span class="line">npm i webpack babel-loader webpack-cli @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</span><br><span class="line"><span class="comment"># 执行 CLI 添加--presets</span></span><br><span class="line">npx babel babel.js --presets=@babel/preset-env</span><br></pre></td></tr></table></figure><h3 id="babelrc"><a href="#babelrc" class="headerlink" title="babelrc"></a>babelrc</h3><p>除了使用命令行配置 flag 之外，Babel 还支持配置文件，比如这里做的 ES6 语法转换，用到的是 babel-loader，这个 Loader 依赖@babel/core 和@babel/preset-env。<br>然后在项目的根目录下，创建一个 babel 的配置文件.babelrc，内容如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Babel 会在正在被转义的文件当前目录中查找一个 .babelrc 文件。 如果不存在，它会向外层目录遍历目录树，直到找到一个 .babelrc 文件，或一个 package.json 文件中有 <code>&quot;babel&quot;: {}</code><br>有了 babel-loader，可以使用 webpack 命令的—module-bind 来指定对应的文件需要经过怎样的 Loader 处理：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack --mode development ./src/index.js --module-bind js=babel-loader"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack --mode production ./src/index.js --module-bind js=babel-loader"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p>如果希望在不同的环境中使用不同的 Babel 配置，那么可以在配置文件中添加 env 选项，env 选项的值将从 process.env.BABEL_ENV 获取，如果没有的话，则获取 process.env.NODE_ENV 的值，它也无法获取时会设置为 “development”。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"production"</span>: &#123;</span><br><span class="line">      <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>Babel 的插件分为两类：转换插件和语法解析插件。转换插件主要职责是进行语法转换，而解析插件则是扩展语法。</p><ol><li>如果不想一个个的添加插件，那么可以使用插件组合 preset（插件预设，插件组合更加好理解一些），最常见的 preset 是@babel/preset-env。<br>@babel/preset-env 是 Babel 官方推出的插件预设，它可以根据开发者的配置按需加载对应的插件。</li><li>如果在 ES5 中，有些对象、方法实际在浏览器中可能是不支持的，例如：Promise、Array.prototype.includes，这时候就需要用 @babel/polyfill 来做模拟处理。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polyfill需要在文件内引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'@babel/polyfill'</span></span><br></pre></td></tr></table></figure><p>s 3. @babel/polyfill 会直接修改内置的原型，且无法按需引入，可以使用@babel/runtime 的方案。 4. @babel/polyfill 和@babel/runtime 两种方式都比较繁琐，可以使用 @babel/preset-env 的 useBuildIns 选项做 polyfill，useBuiltIns 默认为 false，可以使用的值有 usage 和 entry</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [<span class="string">"@babel/preset-env"</span>, &#123;</span><br><span class="line"><span class="string">"useBuiltIns"</span>: <span class="string">"usage|entry|false"</span>,</span><br><span class="line"><span class="string">"corejs"</span>: <span class="number">3</span>,</span><br><span class="line"><span class="string">"targets"</span>: &#123;</span><br><span class="line">        <span class="string">"browsers"</span>: <span class="string">"IE 10"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>usage 表示明确使用到的 Polyfill 引用，一般情况下 usage 就能满足日常开发。<br>polyfill 用到的 core-js 是可以指定版本的，比如使用 core-js@3，则首先安装依赖 <code>npm i -S core-js@3</code>，然后在 Babel 配置文件.babelrc 中写上版本。<br>使用 target 可以指定目标浏览器。</p><h3 id="webpack-中使用-Babel"><a href="#webpack-中使用-Babel" class="headerlink" title="webpack 中使用 Babel"></a>webpack 中使用 Babel</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'./babel.js'</span>,</span><br><span class="line">mode: <span class="string">'development'</span>,</span><br><span class="line">devtool: <span class="literal">false</span>,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">use: [</span><br><span class="line">&#123;</span><br><span class="line">loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">options: &#123;</span><br><span class="line">presets: [</span><br><span class="line">[</span><br><span class="line"><span class="string">'@babel/preset-env'</span>,</span><br><span class="line">&#123;</span><br><span class="line">useBuiltIns: <span class="string">'usage'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Browserslist"><a href="#Browserslist" class="headerlink" title="Browserslist"></a>Browserslist</h3><p>Browserslist 用于设置目标浏览器的工具，声明一段浏览器的集合，工具可以根据这段集合描述，针对性的输出兼容性代码。<br>Browserslist 的配置可以放在 package.json 中，也可以单独放在配置文件.browserslistrc 中。所有的工具都会主动查找 browserslist 的配置文件，根据 browserslist 配置找出对应的目标浏览器集合。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"browserslist"</span>: [<span class="string">"last 2 version"</span>, <span class="string">"&gt; 1%"</span>, <span class="string">"maintained node versions"</span>, <span class="string">"not ie &lt; 11"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .browerslistrc</span><br><span class="line"># 每行一个浏览器集合描述</span><br><span class="line">last 2 version</span><br><span class="line">&gt; 1%</span><br><span class="line">maintained node versions</span><br><span class="line">not ie &lt; 11</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>范围</th><th>说明</th></tr></thead><tbody><tr><td>last 2 versions</td><td>最新两个版本</td></tr><tr><td>&gt; 1%</td><td>全球超过 1%人使用的浏览器，类似&gt; 5% in US 则指代美国 5%以上用户</td></tr><tr><td>cover 99.5%</td><td>覆盖 99.5%主流浏览器</td></tr><tr><td>chrome &gt; 50 ie 6-8</td><td>指定某个浏览器版本范围 Android/Chrome/Firefox/Baidu/Edge/Electron…</td></tr><tr><td>unreleased versions</td><td>说有浏览器的 beta 版本</td></tr><tr><td>not ie &lt; 11</td><td>排除 ie11 以下版本不兼容</td></tr><tr><td>since 2013 last 2 years</td><td>某时间范围发布的所有浏览器版本</td></tr><tr><td>maintained node versions</td><td>所有被 node 基金会维护的 node 版本</td></tr><tr><td>current node</td><td>当前环境的 node 版本</td></tr><tr><td>dead</td><td>全球使用率低于 0.5%且官方声明不在维护或者事实上已经两年没有再更新的版本</td></tr><tr><td>defaults</td><td>默认配置，&gt; 0.5% last 2 versions Firefox ESR not dead</td></tr></tbody></table></div><p>可以为不同的环境配置不同的目标浏览器。通过设置 BROWSERSLIST_ENV 或者 NODE_ENV 可以配置不同的环境变量。默认情况下会优先从 production 对应的配置项加载。在配置文件中，可以通过设置对应的环境目标浏览器：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json 写法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"browserslist"</span>: &#123;</span><br><span class="line"><span class="string">"production"</span>: [<span class="string">"&gt; 1%"</span>, <span class="string">"ie 10"</span>],</span><br><span class="line"><span class="string">"development"</span>: [<span class="string">"last 1 chrome version"</span>, <span class="string">"last 1 firefox version"</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#.browserslistrc：</span><br><span class="line"></span><br><span class="line">[production staging]</span><br><span class="line"></span><br><span class="line">&gt; 1%</span><br><span class="line">&gt; ie 10</span><br><span class="line"></span><br><span class="line">[development]</span><br><span class="line">last 1 chrome version</span><br><span class="line">last 1 firefox version</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Babel 是一个 JavaScript 的静态分析编译器，在不需要执行代码的前提下对代码进行分析和处理。&lt;br&gt;要实现 Babel 从一个语法转换成另外一个语法，需要经过三个主要步骤：解析（Parse），转换（Transform），生成（Generate）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hyqskevin.github.io/2020/06/28/Webpack_1/&quot;&gt;Webpack 程序打包学习笔记(1)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://hyqskevin.github.io/2020/07/05/Webpack_2/&quot;&gt;Webpack 程序打包学习笔记(2)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="Babel" scheme="https://hyqskevin.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Webpack程序打包学习笔记(2)</title>
    <link href="https://hyqskevin.github.io/2020/07/05/Webpack_2/"/>
    <id>https://hyqskevin.github.io/2020/07/05/Webpack_2/</id>
    <published>2020-07-05T11:10:37.000Z</published>
    <updated>2020-12-16T07:09:03.242Z</updated>
    
    <content type="html"><![CDATA[<p>Webpack externals，target，resolve，module，plugin，devtool 的配置。</p><p><a href="https://hyqskevin.github.io/2020/06/28/Webpack_1/">Webpack 程序打包学习笔记(1)</a><br><a href="https://hyqskevin.github.io/2020/07/05/Webpack_2/">Webpack 程序打包学习笔记(2)</a><br><a href="https://hyqskevin.github.io/2020/07/13/Webpack_3/">Webpack 程序打包学习笔记(3)</a></p><a id="more"></a><h3 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h3><p>externals 配置项用于去除输出的打包文件中依赖的某些第三方 js 模块（例如 jquery，vue 等等），减小打包文件的体积。该功能通常在开发自定义 js 库（library）的时候用到，这些被依赖的模块应该由使用者提供，而不应该包含在 js 库文件中。</p><p>使用者依据 js 库的导出方式来提供依赖模块，如果没有设置 output.library, output.libraryTarget 等配置信息，那么以 <code>&lt;script&gt;</code> 标签的方式在页面中引入，被去除的依赖模块以全局变量的方式引入。导出方式为 commonjs/amd/umd 则被依赖模块以各自规范引入。</p><h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p>webpack 中可以通过设置 target 来指定应用构建的目标（web/nodejs 服务/electron 应用…）；target 的值有两种类型：string 和 function。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">target: <span class="string">'web'</span>, <span class="comment">// 默认是 web，可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line"><span class="comment">// function 类型，接收compiler作为参数</span></span><br><span class="line">target: <span class="function">(<span class="params">compiler</span>) =&gt;</span> &#123;</span><br><span class="line">compiler.apply(</span><br><span class="line"><span class="keyword">new</span> webpack.JsonpTemplatePlugin(options.output),</span><br><span class="line"><span class="keyword">new</span> webpack.LoaderTargetPlugin(<span class="string">'web'</span>)</span><br><span class="line">)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string 类型支持下面的七种：</p><ul><li>web：默认，编译为类浏览器环境里可用；</li><li>node：编译为类 Node.js 环境可用（使用 Node.js require 加载 chunk）；</li><li>async-node：编译为类 Node.js 环境可用（使用 fs 和 vm 异步加载分块）；</li><li>electron-main：编译为 Electron 主进程；</li><li>electron-renderer：编译为 Electron 渲染进程；</li><li>node-webkit：编译为 Webkit 可用，并且使用 jsonp 去加载分块。支持 Node.js 内置模块和 nw.gui 导入（实验性质）；</li><li>webworker：编译成一个 WebWorker。</li></ul><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><p>resolve 配置是帮助 Webpack 查找依赖模块，也可以替换对应的依赖。</p><p>常用的 resolve 配置：</p><ul><li>resolve.extensions：帮助 Webpack 解析扩展名的配置，默认值：[‘.wasm’, ‘.mjs’, ‘.js’, ‘.json’]，所以我们引入 js 和 json 文件，可以不写它们的扩展名，通常我们可以加上 .css、.less 等，但是要确保同一个目录下面没有重名的 css 或者 js 文件。</li><li>resolve.alias：最常用的配置，通过设置 alias 可以缩短目录写法，帮助 webpack 更快查找模块依赖，也能使我们编写代码更加方便。设置了 alias，我们可以在任意文件中，不用理会目录结构，直接使用 require(‘@lib/utils’)或者 require(‘src/lib/utils’)来帮助 Webpack 定位模块。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">resolve: &#123;</span><br><span class="line">extensions: [<span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.css'</span>],</span><br><span class="line">alias: &#123;</span><br><span class="line">src: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line"><span class="string">'@lib'</span>: path.resolve(__dirname, <span class="string">'src/lib'</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>设置 alias 会导致我们检测不到目录中的内容，不能帮我们快速编写代码，可以通过在项目根目录创建 jsconfig.json 来帮助我们定位</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line"><span class="string">"baseUrl"</span>: <span class="string">"./src"</span>,</span><br><span class="line"><span class="string">"paths"</span>: &#123;</span><br><span class="line"><span class="string">"@lib/"</span>: [<span class="string">"src/lib"</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>alias 还常被用于给生产环境和开发环境配置不同的 lib 库</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">resolve: &#123;</span><br><span class="line">alias: &#123;</span><br><span class="line">san:</span><br><span class="line">process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line">? <span class="string">'san/dist/san.min.js'</span></span><br><span class="line">: <span class="string">'san/dist/san.dev.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>alias 还支持在名称末尾添加$符号来缩小范围只命中以关键字结尾的导入语句，这样可以做精准匹配：</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">// 对 react 进行精确匹配</span></span><br><span class="line">resolve: &#123;</span><br><span class="line">alias: &#123;</span><br><span class="line">react$: <span class="string">'/path/to/react.min.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resolve.mainFields：针对不同宿主环境提供几份代码，例如提供 ES5 和 ES6 的两份代码，或者提供浏览器环境和 nodejs 环境两份代码</li><li>resolve.modules：查找模块依赖时，默认是 node_modules</li><li>resolve.symlinks：是否解析符合链接（软连接，symlink）</li><li>resolve.plugins：添加解析插件，数组格式</li><li>resolve.cachePredicate：是否缓存，支持 boolean 和 function，function 传入一个带有 path 和 require 的对象，必须返回 boolean 值</li></ul><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>在 webpack 解析模块的同时，不同的模块需要使用不同类型的模块处理器来处理，这部分的设置就在 module 配置中。<br>module 有两个配置：module.noParse 和 module.rules</p><ul><li>module.rules 是在处理模块时，将符合规则条件的模块，提交给对应的处理器来处理，通常用来配置 loader，其类型是一个数组，数组里每一项都描述了如何去处理部分文件。<br>每一项 rule 大致可以由以下三部分组成：</li></ul><ol><li><p>条件匹配：通过 test、include、exclude 配置命中可以应用规则的模块文件，匹配的对象包括三类：</p><ul><li>resource：请求文件的绝对路径</li><li>resourceQuery： ?之后的条件</li><li>issuer: 被请求资源的绝对路径，即导入时的位置</li></ul></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 来自src和test文件夹，不包含node_modules和bower_modules子目录，模块的文件路径为.tsx和.jsx结尾的文件</span></span><br><span class="line">rules: [</span><br><span class="line">test: [<span class="regexp">/\.jsx?$/</span>, /\.tsx?$/],</span><br><span class="line">include: [</span><br><span class="line">path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">path.resolve(__dirname, <span class="string">'test'</span>)</span><br><span class="line">],</span><br><span class="line">exclude: [</span><br><span class="line">path.resolve(__dirname, <span class="string">'node_modules'</span>),</span><br><span class="line">path.resolve(__dirname, <span class="string">'bower_modules'</span>)</span><br><span class="line">]</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>应用规则：对匹配条件通过后的模块，使用 use 配置项来应用 loader，loader 是解析处理器，使用对应的 loader 之前，需要先安装它</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定*.less文件都是用less-loader</span></span><br><span class="line">rules:[</span><br><span class="line">test: <span class="regexp">/\.less$/</span>, <span class="attr">use</span>:<span class="string">'less-loader'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给 loader 传参的方式有两种：通过 options 传入和通过 query 的方式传入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config内写法，通过 options 传入</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">use: [</span><br><span class="line">&#123;</span><br><span class="line">loader: <span class="string">'html-loader'</span>,</span><br><span class="line">options: &#123;</span><br><span class="line">minimize: <span class="literal">true</span>,</span><br><span class="line">removeComments: <span class="literal">false</span>,</span><br><span class="line">collapseWhitespace: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// config内写法，通过 query 传入</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">use: [</span><br><span class="line">&#123;</span><br><span class="line">loader:</span><br><span class="line"><span class="string">'html-loader?minimize=true&amp;removeComments=false&amp;collapseWhitespace=false'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>执行顺序：一组 loader 的执行顺序默认是<strong>从后到前（或者从右到左）</strong>执行，通过 enforce 选项可以让其中一个 loader 的执行顺序放到最前（pre）或者是最后（post）。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// query 写法从右到左，使用!隔开</span></span><br><span class="line"><span class="keyword">const</span> styles = <span class="built_in">require</span>(<span class="string">'css-loader!less-loader!./src/index.less'</span>)</span><br><span class="line"><span class="comment">// 数组写法，从后到前</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">use: [</span><br><span class="line">&#123;</span><br><span class="line">loader: <span class="string">'style-loader'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">loader: <span class="string">'css-loader'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">loader: <span class="string">'less-loader'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要调整 Loader 的执行顺序，可以使用 enforce，enforce 取值是 pre|post，pre 表示把放到最前，post 是放到最后：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">use: [</span><br><span class="line">&#123;</span><br><span class="line">loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">options: &#123;</span><br><span class="line">cacheDirectory: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// enforce:'post' 的含义是把该 loader 的执行顺序放到最后</span></span><br><span class="line"><span class="comment">// enforce 的值还可以是 pre，代表把 loader 的执行顺序放到最前</span></span><br><span class="line">enforce: <span class="string">'post'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>oneOf 表示对该资源只应用第一个匹配的规则，一般结合 resourceQuery，具体代码来解释：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">oneOf: [</span><br><span class="line">&#123;</span><br><span class="line">resourceQuery: <span class="regexp">/inline/</span>, <span class="comment">// foo.css?inline</span></span><br><span class="line">use: <span class="string">'url-loader'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">resourceQuery: <span class="regexp">/external/</span>, <span class="comment">// foo.css?external</span></span><br><span class="line">use: <span class="string">'file-loader'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>module.noParse 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析和处理，这样做的好处是能提高构建性能，接收的类型为正则表达式，或者正则表达式数组或者接收模块路径参数的一个函数。<br>一定要确定被排除出去的模块代码中不能包含 import、require、define 等内容，以保证 webpack 的打包包含了所有的模块，不然会导致打包出来的 js 因为缺少模块而报错。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line"><span class="comment">// 使用正则表达式</span></span><br><span class="line">noParse: <span class="regexp">/jquery|lodash/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数，从 Webpack 3.0.0 开始支持</span></span><br><span class="line">noParse: <span class="function">(<span class="params">content</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// content 代表一个模块的文件路径</span></span><br><span class="line"><span class="comment">// 返回 true or false</span></span><br><span class="line"><span class="keyword">return</span> <span class="regexp">/jquery|lodash/</span>.test(content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>plugin 是 Webpack 的重要组成部分，可以直接通过 webpack 对象的属性来直接使用。loader 面向的是解决某个或者某类模块的问题，而 plugin 面向的是项目整体，解决的是 loader 解决不了的问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 压缩js</span></span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin();</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了内置的插件，我们也可以通过 NPM 包的方式来使用插件：</span></span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 导出css文件到单独的内容</span></span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'style.css'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h3><p>devtool 是来控制怎么显示 sourcemap，通过 sourcemap 我们可以快速还原代码的错误位置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Webpack externals，target，resolve，module，plugin，devtool 的配置。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hyqskevin.github.io/2020/06/28/Webpack_1/&quot;&gt;Webpack 程序打包学习笔记(1)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://hyqskevin.github.io/2020/07/05/Webpack_2/&quot;&gt;Webpack 程序打包学习笔记(2)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://hyqskevin.github.io/2020/07/13/Webpack_3/&quot;&gt;Webpack 程序打包学习笔记(3)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="Webpack" scheme="https://hyqskevin.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack程序打包学习笔记(1)</title>
    <link href="https://hyqskevin.github.io/2020/06/28/Webpack_1/"/>
    <id>https://hyqskevin.github.io/2020/06/28/Webpack_1/</id>
    <published>2020-06-28T12:48:33.000Z</published>
    <updated>2020-12-16T07:09:04.174Z</updated>
    
    <content type="html"><![CDATA[<p>像 Grunt、Gulp 这类构建工具，打包的思路是：遍历源文件 → 匹配规则 → 打包，这个过程中做不到按需加载，即对于打包起来的资源，到底页面用不用，打包过程中是不关心的。</p><p>webpack 跟其他构建工具本质上不同之处在于：webpack 是从入口文件开始，经过模块依赖加载、分析和打包三个流程完成项目的构建。在加载、分析和打包的三个过程中，可以针对性的做一些解决方案，还可以轻松的解决传统构建工具解决的问题：</p><p>模块化打包，一切皆模块，JS 是模块，CSS 等也是模块；<br>语法糖转换：比如 ES6 转 ES5、TypeScript；<br>预处理器编译：比如 Less、Sass 等；<br>项目优化：比如压缩、CDN；<br>解决方案封装：通过强大的 Loader 和插件机制，可以完成解决方案的封装，比如 PWA；<br>流程对接：比如测试流程、语法检测等。</p><a id="more"></a><h2 id="webpack-cli"><a href="#webpack-cli" class="headerlink" title="webpack-cli"></a>webpack-cli</h2><p>Webpack-cli 是 Webpack 的 CLI （Command-line interface）工具，如果在项目中，可以使用下面的方式安装：</p><p>npm install webpack-cli —save-dev<br>如果想全局使用 webpack 的命令，可以使用 npm install -g webpack-cli 安装。<br>Webpack 的打包环境有 production 和 development 两种，分别对应生产环境和开发环境，生产环境默认配置包括压缩等常用的配置。<br>Webpack 默认的入口文件是 src/index.js；<br>Webpack 的默认输出目录是 dist/main.js。</p><ul><li>Tips：这里建议在项目中安装 webpack-cli 并且使用 —save-dev 的配置将 webpack-cli 放到开发依赖中。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack --mode development"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --mode production"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如果要修改 Webpack 的默认输出目录，需要用到 Webpack 命令的—output，我们将上面的 npm scripts 做下修改：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack --mode development --output ./output/main.js"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --mode production --output ./output/main.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack-cli 技巧：</p><ol><li>当项目逐渐变大或者使用生产环境打包的时候，Webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色： webpack —progress —colors；</li><li>Webpack 的配置比较复杂，很容出现错误，如果出问题，会打印一些简单的错误信息，我们还可以通过参数 —display-error-details 来打印错误详情：webpack —display-error-details；</li><li>如果不想每次修改模块后都重新编译，那么可以启动监听模式，开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的：webpack —watch；</li><li>webpack-cli 支持两个快捷选项：-d 和 -p ，分别代表一些常用的开发环境和生产环境的打包。</li><li>常用 webpack 配置选项：<br>–config：指定一个 Webpack 配置文件的路径；<br>–mode：指定打包环境的 mode，取值为 development 和 production，分别对应着开发环境和生产环境；<br>–json：输 mode 出 Webpack 打包的结果，可以使用 webpack —json &gt; stats.json 方式将打包结果输出到指定的文件；<br>–progress：显示 Webpack 打包进度；<br>–watch, -w：watch 模式打包，监控文件变化之后重新开始打包；<br>–color, —colors/–no-color, —no-colors：控制台输出的内容是否开启颜色；<br>–hot：开启 Hot Module Replacement 模式，后面会详细介绍；<br>–profile：会详细的输出每个环节的用时（时间），方便排查打包速度瓶颈。</li></ol><h2 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack.config.js"></a>配置 webpack.config.js</h2><p>可以通过修改 Webpack 的配置文件（webpack.config.js）来对 Webpack 进行配置，Webpack 的配置文件遵循 Node.js 的 CommonJS 模块规范<br>Webpack 配置文件语法和类型多样，不仅支持 js 配置，还支持 ts（TypeScript）、CoffeeScript 甚至 JSX 语法的配置；除了使用对象类型，Webpack 还支持函数、Promise 和多配置数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本配置</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">mode: <span class="string">'development'</span>,</span><br><span class="line">entry: <span class="string">'./index.js'</span>,</span><br><span class="line">output: &#123;</span><br><span class="line">path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">filename: <span class="string">'index.bundle.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只使用一个配置文件来区分生产环境（production）和开发环境（development），则可以使用函数类型的 Webpack 配置，函数类型的配置必须返回一个配置对象</p><p>Webpack 配置函数接受两个参数 env 和 argv：分别对应着环境对象和 Webpack-CLI 的命令行选项</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">mode: env.production ? <span class="string">'production'</span> : <span class="string">'development'</span>,</span><br><span class="line">devtool: env.production ? <span class="string">'source-maps'</span> : <span class="string">'eval'</span>,</span><br><span class="line">plugins: [</span><br><span class="line"><span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">terserOptions: &#123;</span><br><span class="line">compress: argv[<span class="string">'optimize-minimize'</span>], <span class="comment">// 只有传入 -p 或 --optimize-minimize</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;),</span><br><span class="line">],</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要异步加载一些 Webpack 配置需要做的变量，那么可以使用 Promise 的方式来做 Webpack 的配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">resolve(&#123;</span><br><span class="line">entry: <span class="string">'./app.js'</span>,</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些特定的场景可能需要一次打包多次，而多次打包中有一些通用的配置，这时候可以使用配置数组的方式，将两次以上的 Webpack 配置以数组的形式导出</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">&#123;</span><br><span class="line">mode: <span class="string">'production'</span>,</span><br><span class="line"><span class="comment">// 配置1</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 配置2</span></span><br><span class="line">&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Webpack 配置 常见名词</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">entry</td><td>项目入口，包括字符串、对象、数组</td></tr><tr><td style="text-align:left">module</td><td>开发中每一个文件都可以看做 module，模块不局限于 js，也包含 css、图片等</td></tr><tr><td style="text-align:left">chunk</td><td>代码块，一个 chunk 可以由多个模块组成</td></tr><tr><td style="text-align:left">loader</td><td>模块转化器，模块的处理器，对模块进行转换处理</td></tr><tr><td style="text-align:left">plugin</td><td>扩展插件，插件可以处理 chunk，也可以对最后的打包结果进行处理，可以完成 loader 完不成的任务</td></tr><tr><td style="text-align:left">bundle</td><td>最终打包完成的文件，一般就是和 chunk 一一对应的关系，bundle 就是对 chunk 进行便意压缩打包等处理后的产出</td></tr><tr><td style="text-align:left">mode</td><td>指定开发环境打包</td></tr><tr><td style="text-align:left">context</td><td>项目打包的相对路径，指定之后设置的 entry 和 output 的相对路径都是相对于 context；在实际开发中一般不需要配置</td></tr></tbody></table></div><p>默认情况下，Webpack 会查找执行目录下面的 webpack.config.js 作为配置，如果需要指定某个配置文件，可以使用命令：<code>webpack --config webpack.config.js</code><br>Webpack4.0 开始引入了 mode 配置，通过配置 mode=development 或者 mode=production 来制定是开发环境打包，还是生产环境打包<br>除了在配置文件中设置 mode：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">mode: <span class="string">'development'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以在命令行中设置 mode：<code>npm webpack --config webpack.config.entry.js --mode development</code></p><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>entry 包括了单文件入口和多文件入口两种方式。单文件入口可以快速创建一个只有单一文件入口的情况，多文件入口是使用对象语法来通过支持多个 entry，具有较高的灵活性，可用于多页应用、页面模块分离优化。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单文件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: <span class="string">'index.js'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用对象方式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">main: <span class="string">'index.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">mode: <span class="string">'development'</span>,</span><br><span class="line">entry: [<span class="string">'./src/app.js'</span>, <span class="string">'./src/home.js'</span>],</span><br><span class="line">output: &#123;</span><br><span class="line">filename: <span class="string">'array.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果直接是 string 的形式，那么 webpack 就会直接把该 string 指定的模块（文件）作为入口模块</li><li>如果是数组 [string] 的形式，那么 webpack 会自动生成另外一个入口模块，并将数组中每个元素指定的模块（文件）加载进来，并将最后一个模块的 module.exports 作为入口模块的 module.exports 导出。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多文件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">home: <span class="string">'home.js'</span>,</span><br><span class="line">search: <span class="string">'search.js'</span>,</span><br><span class="line">list: <span class="string">'list.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>output 的每一个 bundle 对应了 entry 的文件编译打包后的结果，output 的常用属性有：</p><ul><li>path<br>此选项制定了输出的 bundle 存放的路径，比如 dist、output 等，不指定 output 时输出到 dist</li><li>filename<br>这个是 bundle 的名称，不指定 output 时输出为 dist/main.js</li><li>publicPath<br>指定了一个在浏览器中被引用的 URL 地址，当文件路径不同于他们的本地磁盘路径（由 output.path 指定）时，output.publicPath 被用来作为 src 或者 link 指向该文件。这种做法在需要将静态文件放在不同的域名或者 CDN 上面的时候是很有用的。</li><li>library<br>如果打包生成一个供别人使用的库，那么可以使用 output.library 来指定库的名称，库的名称支持占位符和普通字符串：<code>library: &#39;myLib&#39;</code></li><li>libraryTarget<br>使用 output.libraryTarget 指定库打包出来的规范，取值范围为：var、assign、this、window、global、commonjs、commonjs2、commonjs-module、amd、umd、umd2、jsonp</li></ul><p>一个 webpack 的配置，可以包含多个 entry，但是只能有一个 output，对于不同的 entry 可以通过 output.filename 占位符语法来区分。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">home: <span class="string">'home.js'</span>,</span><br><span class="line">search: <span class="string">'search.js'</span>,</span><br><span class="line">list: <span class="string">'list.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">filename: <span class="string">'[name].js'</span>, <span class="comment">// [name]为占位符，对应entry的key（home. search, list）</span></span><br><span class="line">path: __dirname + <span class="string">'/dist'</span>,</span><br><span class="line">publicPath: <span class="string">'/assets/'</span>, <span class="comment">// CDN：publicPath: 'http://cdn.example.com/assets/'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webpack 目前支持的占位符：</p><div class="table-container"><table><thead><tr><th>占位符</th><th>含义</th></tr></thead><tbody><tr><td>[hash]</td><td>模块标识符的 hash</td></tr><tr><td>[chunkhash]</td><td>chunk 内容的 hash</td></tr><tr><td>[name]</td><td>模块名称</td></tr><tr><td>[id]</td><td>模块标识符</td></tr><tr><td>[query]</td><td>模块的 query，例如，文件名 ? 后面的字符串</td></tr><tr><td>[function]</td><td>一个 return 出一个 string 作为 filename 的函数</td></tr></tbody></table></div><p>[name]：对应的是 entry 的 key（home、search、list…）<br>[hash]：是整个项目的 hash 值，其根据每次编译内容计算得到，每次编译之后都会生成新的 hash，即修改任何文件都会导致所有文件的 hash 发生改变；在一个项目中虽然入口不同，但是 hash 是相同的；hash 无法实现前端静态资源在浏览器上长缓存，这时候应该使用 chunkhash<br>[chunkhash]：根据不同的入口文件（entry）进行依赖文件解析，构建对应的 chunk，生成相应的 hash；只要组成 entry 的模块文件没有变化，则对应的 hash 也是不变的，所以一般项目优化时，会将公共库代码拆分到一起，因为公共库代码变动较少的，使用 chunkhash 可以发挥最长缓存的作用<br>[hash] 和 [chunkhash] 的长度可以使用 [hash:16]（默认为 20）来指定。或者，通过指定 output.hashDigestLength 在全局配置长度<br>占位符是可以组合使用的，例如[name]-[hash:8]</p><hr><p><a href="https://hyqskevin.github.io/2020/07/05/Webpack_2/">Webpack 程序打包学习笔记(2)</a><br><a href="https://hyqskevin.github.io/2020/07/13/Webpack_3/">Webpack 程序打包学习笔记(3)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;像 Grunt、Gulp 这类构建工具，打包的思路是：遍历源文件 → 匹配规则 → 打包，这个过程中做不到按需加载，即对于打包起来的资源，到底页面用不用，打包过程中是不关心的。&lt;/p&gt;
&lt;p&gt;webpack 跟其他构建工具本质上不同之处在于：webpack 是从入口文件开始，经过模块依赖加载、分析和打包三个流程完成项目的构建。在加载、分析和打包的三个过程中，可以针对性的做一些解决方案，还可以轻松的解决传统构建工具解决的问题：&lt;/p&gt;
&lt;p&gt;模块化打包，一切皆模块，JS 是模块，CSS 等也是模块；&lt;br&gt;语法糖转换：比如 ES6 转 ES5、TypeScript；&lt;br&gt;预处理器编译：比如 Less、Sass 等；&lt;br&gt;项目优化：比如压缩、CDN；&lt;br&gt;解决方案封装：通过强大的 Loader 和插件机制，可以完成解决方案的封装，比如 PWA；&lt;br&gt;流程对接：比如测试流程、语法检测等。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="Webpack" scheme="https://hyqskevin.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>BetterScroll插件实现页面滚动效果</title>
    <link href="https://hyqskevin.github.io/2020/05/28/better-scroll/"/>
    <id>https://hyqskevin.github.io/2020/05/28/better-scroll/</id>
    <published>2020-05-28T03:08:18.000Z</published>
    <updated>2020-11-19T09:17:47.822Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;BetterScoll 用于解决列表的动态滚动，实现移动端列表上拉加载，下拉刷新，水平/垂直滚动，滚动至指定高度等功能。BetterScroll 支持大量参数配置，提供很多灵活的 api 实现指定功能。<br>&emsp;&emsp;实现 BetterScroll 滚动时父元素的高度或宽度需要进行固定，同时确保父元素和子元素内容正确渲染；在 DOM 结构发生改变时需要重新调用 <code>scroll.refresh()</code> 方法重新计算来确保滚动效果正常。</p><a id="more"></a><ul><li><p>安装：<code>npm install better-scroll --save</code></p></li><li><p>基本结构：</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其它的 DOM --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">'better-scroll'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> scroll = <span class="keyword">new</span> BScroll(<span class="string">'.wrapper'</span>, &#123;</span></span><br><span class="line"><span class="javascript">pullUpLoad: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">scrollbar: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Scroll-配置项"><a href="#Scroll-配置项" class="headerlink" title="Scroll 配置项"></a>Scroll 配置项</h2><h2 id="Scroll-常用方法"><a href="#Scroll-常用方法" class="headerlink" title="Scroll 常用方法"></a>Scroll 常用方法</h2><h2 id="Scroll-事件监听"><a href="#Scroll-事件监听" class="headerlink" title="Scroll 事件监听"></a>Scroll 事件监听</h2><h2 id="Vue-中实现-BetterScroll"><a href="#Vue-中实现-BetterScroll" class="headerlink" title="Vue 中实现 BetterScroll"></a>Vue 中实现 BetterScroll</h2><p>&emsp;&emsp;Vue.js 提供了我们一个获取 DOM 对象的接口 <code>vm.$refs</code>，可以通过 <code>this.$refs.wrapper</code> 访问 DOM 对象。在 mounted 钩子函数里，使用回调函数保证初始化时 wrapper 的 DOM 已经渲染，可以正确计算它以及它内层 content 的高度以确保滚动正常。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span> <span class="attr">ref</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">'better-scroll'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">mounted() &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">this</span>.scroll = <span class="keyword">new</span> Bscroll(<span class="keyword">this</span>.$refs.wrapper, &#123;&#125;)</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined">&#125;,</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h2><p>Scroll 组件的 DOM 结构包括顶部和底部的提示信息以及中间部分的列表组件，使用插槽 <code>&lt;slot&gt;</code> 进行占位。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"wrapper"</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"scroll-content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 刷新提示信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top-tip"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"refresh-hook"</span>&gt;</span>&#123;&#123;pullDownMsg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内容列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 底部提示信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom-tip"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"loading-hook"</span>&gt;</span>'-到底了-'<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件的 js 部分对 Scroll 做 Vue 的封装，在 prop 里重写 Scroll 配置项，将控制权交给调用 Scroll.vue 的父组件；通过 methods 暴露的一些方法对 better-scroll 的方法做一层代理；watch 监听 data 的改变，及时调用 refresh 方法重新计算 better-scroll 确保滚动效果正常。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">'better-scroll'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// 常用配置和自定义配置</span></span><br><span class="line">props: &#123;</span><br><span class="line">probeType: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">1</span> &#125;, <span class="comment">// 何时派发滚动事件</span></span><br><span class="line">click: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">true</span> &#125;, <span class="comment">// 点击时是否派发click事件</span></span><br><span class="line">scrollX: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 横向滚动</span></span><br><span class="line">scrollY: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 纵向滚动</span></span><br><span class="line">bounce: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 边缘弹回动画</span></span><br><span class="line">    autoBlur: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 滚动之前激活元素失去焦点</span></span><br><span class="line">    <span class="comment">// 自定义事件</span></span><br><span class="line">pullup: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 上拉动作触发事件</span></span><br><span class="line">    pulldown: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 下拉动作出发事件</span></span><br><span class="line">listenScroll: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 监听滚动距离触发滚动事件</span></span><br><span class="line">data: &#123; <span class="attr">type</span>: <span class="built_in">Array</span>, <span class="attr">default</span>: <span class="literal">null</span> &#125;, <span class="comment">// 父组件的列表数据</span></span><br><span class="line">beforeScroll: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;, <span class="comment">// 列表滚动开始事件</span></span><br><span class="line">    refreshDelay: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">20</span> &#125;, <span class="comment">// 数据更新后刷新Scroll延时</span></span><br><span class="line">    showIcon: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">true</span> &#125;, <span class="comment">// 下拉后显示返回按钮事件</span></span><br><span class="line">    toTop: &#123; <span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125; <span class="comment">// 返回顶部事件</span></span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">_initScroll() &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.$refs.wrapper) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// better-scroll的初始化</span></span><br><span class="line"><span class="keyword">this</span>.scroll = <span class="keyword">new</span> BScroll(<span class="keyword">this</span>.$refs.wrapper, &#123;</span><br><span class="line">probeType: <span class="keyword">this</span>.probeType,</span><br><span class="line">click: <span class="keyword">this</span>.click,up</span><br><span class="line">        scrollX: <span class="keyword">this</span>.scrollX,</span><br><span class="line">        pullup: <span class="keyword">this</span>.pullup,</span><br><span class="line">        pulldown: <span class="keyword">this</span>.pulldown</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派发滚动事件，下拉一定距离后提示可刷新</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.listenScroll) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scroll.on(<span class="string">'scroll'</span>, (pos) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (pos.y &gt; <span class="number">120</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pullDownMsg = <span class="string">'释放后进行刷新'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行下拉刷新操作</span></span><br><span class="line">      <span class="keyword">this</span>.scroll.on(<span class="string">'pullingDown'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'pulldown'</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.scroll.finishPullDown()</span><br><span class="line">          <span class="keyword">this</span>.scroll.refresh()</span><br><span class="line">          <span class="keyword">this</span>.pullDownMsg = <span class="string">'-下拉刷新-'</span></span><br><span class="line">        &#125;, <span class="number">600</span>)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派发列表滚动开始的事件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beforeScroll) &#123;</span><br><span class="line"><span class="keyword">this</span>.scroll.on(<span class="string">'beforeScrollStart'</span>, () =&gt; &#123;</span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'beforeScroll'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">disable() &#123;</span><br><span class="line"><span class="comment">// 代理better-scroll的disable方法</span></span><br><span class="line"><span class="keyword">this</span>.scroll &amp;&amp; <span class="keyword">this</span>.scroll.disable()</span><br><span class="line">&#125;,</span><br><span class="line">enable() &#123;</span><br><span class="line"><span class="comment">// 代理better-scroll的enable方法</span></span><br><span class="line"><span class="keyword">this</span>.scroll &amp;&amp; <span class="keyword">this</span>.scroll.enable()</span><br><span class="line">&#125;,</span><br><span class="line">refresh() &#123;</span><br><span class="line"><span class="comment">// 代理better-scroll的refresh方法</span></span><br><span class="line"><span class="keyword">this</span>.scroll &amp;&amp; <span class="keyword">this</span>.scroll.refresh()</span><br><span class="line">&#125;,</span><br><span class="line">scrollTo() &#123;</span><br><span class="line"><span class="comment">// 代理better-scroll的scrollTo方法</span></span><br><span class="line"><span class="keyword">this</span>.scroll &amp;&amp; <span class="keyword">this</span>.scroll.scrollTo.apply(<span class="keyword">this</span>.scroll, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;,</span><br><span class="line">scrollToElement() &#123;</span><br><span class="line"><span class="comment">// 代理better-scroll的scrollToElement方法</span></span><br><span class="line"><span class="keyword">this</span>.scroll &amp;&amp; <span class="keyword">this</span>.scroll.scrollToElement.apply(<span class="keyword">this</span>.scroll, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line"><span class="comment">// DOM渲染完毕后初始化better-scroll</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>._initScroll()</span><br><span class="line">&#125;, <span class="keyword">this</span>.refreshDelay)</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line"><span class="comment">// 监听数据的变化，延时refreshDelay时间后调用refresh方法重新计算，保证滚动效果正常</span></span><br><span class="line">data() &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.refresh()</span><br><span class="line">&#125;, <span class="keyword">this</span>.refreshDelay)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://github.com/ustbhuangyi/better-scroll" target="_blank" rel="noopener">https://github.com/ustbhuangyi/better-scroll</a><br><a href="https://better-scroll.github.io/docs/zh-CN/" target="_blank" rel="noopener">https://better-scroll.github.io/docs/zh-CN/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;BetterScoll 用于解决列表的动态滚动，实现移动端列表上拉加载，下拉刷新，水平/垂直滚动，滚动至指定高度等功能。BetterScroll 支持大量参数配置，提供很多灵活的 api 实现指定功能。&lt;br&gt;&amp;emsp;&amp;emsp;实现 BetterScroll 滚动时父元素的高度或宽度需要进行固定，同时确保父元素和子元素内容正确渲染；在 DOM 结构发生改变时需要重新调用 &lt;code&gt;scroll.refresh()&lt;/code&gt; 方法重新计算来确保滚动效果正常。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="Vue" scheme="https://hyqskevin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>swiper滑动插件</title>
    <link href="https://hyqskevin.github.io/2020/05/12/swiper/"/>
    <id>https://hyqskevin.github.io/2020/05/12/swiper/</id>
    <published>2020-05-12T06:27:12.000Z</published>
    <updated>2020-11-19T06:55:28.435Z</updated>
    
    <content type="html"><![CDATA[<p>Swiper 和 vue-awesome-swiper 插件用于页面内容的触摸滑动，每个展示块为一个 slide，全部 slide 包含在包装器 wrapper 中，外部的总容器 container 又包裹着 wrapper 和箭头按钮控件 navigation 以及分页器控件 pagination。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-wrapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span>Slide 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span>Slide 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span>Slide 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--分页器。如果放置在swiper-container外面，需要自定义样式。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--左箭头。如果放置在swiper-container外面，需要自定义样式。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-button-prev"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--右箭头。如果放置在swiper-container外面，需要自定义样式。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-button-next"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果需要滚动条 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-scrollbar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="swiper"><a href="#swiper" class="headerlink" title="swiper"></a>swiper</h2><h3 id="初始结构"><a href="#初始结构" class="headerlink" title="初始结构"></a>初始结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Swiper <span class="keyword">from</span> <span class="string">'swiper'</span></span><br><span class="line"><span class="keyword">var</span> mySwiper = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line">direction: <span class="string">'vertical'</span>, <span class="comment">// 垂直切换选项</span></span><br><span class="line">  loop: <span class="literal">true</span>, <span class="comment">// 循环模式选项</span></span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// 如果需要分页器</span></span><br><span class="line">pagination: &#123;</span><br><span class="line">el: <span class="string">'.swiper-pagination'</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要前进后退按钮</span></span><br><span class="line">navigation: &#123;</span><br><span class="line">nextEl: <span class="string">'.swiper-button-next'</span>,</span><br><span class="line">prevEl: <span class="string">'.swiper-button-prev'</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要滚动条</span></span><br><span class="line">scrollbar: &#123;</span><br><span class="line">el: <span class="string">'.swiper-scrollbar'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="container-常用选项"><a href="#container-常用选项" class="headerlink" title="container 常用选项"></a>container 常用选项</h3><ul><li>initialSlide：初始化时显示的 slide，默认为第一个 slide</li><li>direction：slide 滑动方向，默认为水平方向</li><li>speed：切换速度，单位 ms</li><li>slidesPerView：设置同时显示的 slides 数量</li><li>slidesPerGroup：定义滑动时几个 slide 为一组</li><li>spaceBetween：在 slide 之间设置距离</li><li>loop：会在原本 slide 前后复制若干个 slide 并在合适的时候切换</li><li>preventClicks：防止滑动时执行链接跳转</li><li>touchRatio：设置触摸距离与 slide 滑动距离的比率</li><li>threshold：设置拖动临界值</li><li>touchAngle：设置触发拖动的角度值。默认 45 度，即使触摸方向不是完全水平也能拖动 slide</li><li>autoplay：设置为 true 启动自动切换，可设置延迟 delay 参数</li><li>effect：设置切换效果，’slide’（普通切换、默认）,”fade”（淡入）”cube”（方块）”coverflow”（3d 流）”flip”（3d 翻转）</li></ul><h3 id="组件功能"><a href="#组件功能" class="headerlink" title="组件功能"></a>组件功能</h3><ul><li>lazy：设为 true 开启图片延迟加载默认值</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 延迟加载图片的结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">"path/to/picture-1.jpg"</span> <span class="attr">class</span>=<span class="string">"swiper-lazy"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-lazy-preloader"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> mySwiper = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</span></span><br><span class="line"><span class="undefined">lazy: &#123;</span></span><br><span class="line"><span class="javascript">loadPrevNext: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">&#125;,</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>zoom：开启焦距功能：双击 slide 会放大/缩小，并且在手机端可双指触摸缩放</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-zoom-container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"path/to/image"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>thumbs：专门用于制作带缩略图的 swiper</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> thumbsSwiper = <span class="keyword">new</span> Swiper(<span class="string">'#thumbs'</span>, &#123;</span><br><span class="line">spaceBetween: <span class="number">10</span>,</span><br><span class="line">slidesPerView: <span class="number">4</span>,</span><br><span class="line">watchSlidesVisibility: <span class="literal">true</span>, <span class="comment">//防止不可点击</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> gallerySwiper = <span class="keyword">new</span> Swiper(<span class="string">'#gallery'</span>, &#123;</span><br><span class="line">spaceBetween: <span class="number">10</span>,</span><br><span class="line">thumbs: &#123;</span><br><span class="line">swiper: thumbsSwiper,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>mySwiper.slideNext(speed, runCallbacks)</code> 滑动到下一个滑块</li><li><code>mySwiper.slidePrev(speed,runCallbacks)</code> 滑动到前一个滑块</li><li><code>mySwiper.slideTo(index, speed, runCallbacks)</code> 切换到指定 slide</li><li><code>mySwiper.on(event,handler)</code> 添加回调函数或者事件</li></ul><h2 id="vue-awesome-swiper"><a href="#vue-awesome-swiper" class="headerlink" title="vue-awesome-swiper"></a>vue-awesome-swiper</h2><p>vue-awesome-swiper 是 vue 的 swiper 插件，<code>npm install swiper vue-awesome-swiper --save</code>安装导入后即可在组件中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*main.js 全局安装*/</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueAwesomeSwiper <span class="keyword">from</span> <span class="string">'vue-awesome-swiper'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import style (&gt;= Swiper 6.x)</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'swiper/swiper-bundle.css'</span></span><br><span class="line"><span class="comment">// import style (&lt;= Swiper 5.x)</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'swiper/css/swiper.css'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueAwesomeSwiper <span class="comment">/* &#123; default options with global component &#125; */</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*.vue 组件内*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; Swiper, SwiperSlide, directive &#125; <span class="keyword">from</span> <span class="string">'vue-awesome-swiper'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import style (&gt;= Swiper 6.x)</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'swiper/swiper-bundle.css'</span></span><br><span class="line"><span class="comment">// import style (&lt;= Swiper 5.x)</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'swiper/css/swiper.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">components: &#123;</span><br><span class="line">Swiper,</span><br><span class="line">SwiperSlide,</span><br><span class="line">&#125;,</span><br><span class="line">directives: &#123;</span><br><span class="line">swiper: directive,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始结构-1"><a href="#初始结构-1" class="headerlink" title="初始结构"></a>初始结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;swiper ref=<span class="string">"mySwiper"</span> :options=<span class="string">"swiperOptions"</span>&gt;</span><br><span class="line">    &lt;swiper-slide&gt;Slide <span class="number">1</span>&lt;<span class="regexp">/swiper-slide&gt;</span></span><br><span class="line"><span class="regexp">    &lt;swiper-slide&gt;Slide 2&lt;/</span>swiper-slide&gt;</span><br><span class="line">    &lt;swiper-slide&gt;Slide <span class="number">3</span>&lt;<span class="regexp">/swiper-slide&gt;</span></span><br><span class="line"><span class="regexp">    &lt;swiper-slide&gt;Slide 4&lt;/</span>swiper-slide&gt;</span><br><span class="line">    &lt;swiper-slide&gt;Slide <span class="number">5</span>&lt;<span class="regexp">/swiper-slide&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="swiper-pagination" slot="pagination"&gt;&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/swiper&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'carrousel'</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      swiperOptions: &#123;</span><br><span class="line">        pagination: &#123;</span><br><span class="line">          el: <span class="string">'.swiper-pagination'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// Some Swiper option/callback...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    swiper() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$refs.mySwiper.$swiper</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://www.swiper.com.cn/" target="_blank" rel="noopener">https://www.swiper.com.cn/</a><br><a href="https://github.com/surmon-china/vue-awesome-swiper" target="_blank" rel="noopener">https://github.com/surmon-china/vue-awesome-swiper</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swiper 和 vue-awesome-swiper 插件用于页面内容的触摸滑动，每个展示块为一个 slide，全部 slide 包含在包装器 wrapper 中，外部的总容器 container 又包裹着 wrapper 和箭头按钮控件 navigation 以及分页器控件 pagination。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-wrapper&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-slide&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Slide 1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-slide&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Slide 2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-slide&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Slide 3&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--分页器。如果放置在swiper-container外面，需要自定义样式。--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-pagination&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--左箭头。如果放置在swiper-container外面，需要自定义样式。--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-button-prev&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--右箭头。如果放置在swiper-container外面，需要自定义样式。--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-button-next&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 如果需要滚动条 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;swiper-scrollbar&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="Vue" scheme="https://hyqskevin.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>javascript异步，消息队列和事件循环</title>
    <link href="https://hyqskevin.github.io/2020/05/10/js%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/"/>
    <id>https://hyqskevin.github.io/2020/05/10/js同步和异步/</id>
    <published>2020-05-10T01:33:58.000Z</published>
    <updated>2020-11-19T08:17:13.838Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;JavaScript 是单线程的，在 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，而异步容易实现非阻塞，所以在 JavaScript 中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。</p><a id="more"></a><h2 id="1-异步过程"><a href="#1-异步过程" class="headerlink" title="1. 异步过程"></a>1. 异步过程</h2><p>异步过程：主线程发起一个异步请求 -&gt; 工作线程接收请求(异步函数返回) -&gt; 主线程继续执行后面的代码，同时工作线程执行异步任务 -&gt; 工作线程完成工作后，通知主线程 -&gt; 主线程收到通知后，执行一定的动作(调用回调函数)。</p><p>实现异步过程包括发起函数和回调函数，发起函数用于发起异步过程，回调函数用来处理调用的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发起函数</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 回调函数内容</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h2 id="2-消息队列和事件循环"><a href="#2-消息队列和事件循环" class="headerlink" title="2. 消息队列和事件循环"></a>2. 消息队列和事件循环</h2><p>异步过程中，工作线程在异步操作完成后需要通知主线程。这个通知机制需要通过消息队列和事件循环完成。</p><p>消息队列是一个先进先出的队列，它里面存放着各种消息。JS 引擎线程执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中执行新的同步任务。</p><p>每次栈被清空后，JS 引擎线程都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务。</p><p><img src="https://hyqskevin.github.io/pic/yibu.webp" alt="消息队列和事件循环"></p><h2 id="3-异步编程方法"><a href="#3-异步编程方法" class="headerlink" title="3. 异步编程方法"></a>3. 异步编程方法</h2><ol><li>回调函数</li></ol><p>将后者的执行改写为前者的回调函数。回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="comment">//f1方法</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">callback(f2) <span class="comment">// f2执行改写为f1的回调函数</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//f2方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的回调函数有 setTimeout，setInterval 和 nextTick</p><ul><li><code>setTimeout</code> 设定为一段时间后执行异步任务，且在主线程执行完成后才被调用。</li><li><code>setInterval</code> 是一个定时器函数，按照指定周期不断调用函数，在每次主线程完成后执行。常用于获取数据量过大的列表，先获取一部分用于 DOM 挂载和页面展示，之后再不断从后台获取全部数据。</li><li><code>process.nextTick()</code> 是 Node.js 提供的异步执行函数，执行顺序会早于 setTimeout 和 setTimeInterval，在主线程完成后，任务队列调用之前执行，即在当前”执行栈”的尾部 -&gt; 下一次 Event Loop（主线程读取”任务队列”）之前 -&gt; 触发 process 指定的回调函数。</li></ul><ol><li>Promise 对象</li></ol><p>ECMAscript 6 原生提供了 Promise 对象，代表了未来将要发生的事件，用来传递异步操作的消息，调用 resolve 或 reject 方法返回。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Promise</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步处理</span></span><br><span class="line">  <span class="keyword">if</span> () &#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(); <span class="comment">// 异步调用失败</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调再判断结果，也可以调用 promise.catch()方法捕捉错误的回调函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">(res) =&gt; &#123;</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line">&#125;,</span><br><span class="line">(err) =&gt; &#123;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// catch error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p><ol><li>async/await</li></ol><p>async/await 基于 Promise 实现，它不能用于普通的回调函数。使用 await，函数必须用 async 标识，await 后面跟的是一个 Promise 实例。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> f1();</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> f2();</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// 处理报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// f1方法</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// f2方法</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://github.com/ljianshu/Blog/issues/53" target="_blank" rel="noopener">https://github.com/ljianshu/Blog/issues/53</a><br><a href="https://www.runoob.com/w3cnote/javascript-promise-object.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/javascript-promise-object.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;JavaScript 是单线程的，在 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，而异步容易实现非阻塞，所以在 JavaScript 中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="JavaScript" scheme="https://hyqskevin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>json数据模拟</title>
    <link href="https://hyqskevin.github.io/2019/11/10/json-server/"/>
    <id>https://hyqskevin.github.io/2019/11/10/json-server/</id>
    <published>2019-11-10T11:33:58.000Z</published>
    <updated>2020-11-19T06:55:49.557Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;进行 web 网站开发时，前后端分离导致开发进度不同，前端经常需要等待后端的接口数据完成开发才可以继续调试。且开发环境，测试环境和线上环境分离，本地开发时无法运用测试环境的接口，开发时的接口和最终部署的接口也并不相同，每次测试时来回部署代码要耗费很多时间。<br>&emsp;&emsp;使用 json-server + mockjs 编写 json 格式的模拟数据接口，在等待后端准备接口期间，前端可以使用假数据进行模拟。</p><a id="more"></a><h2 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h2><p>json-server 是可以在本地运行，存储 json 数据的服务端。通过<code>npm install -g json-server</code>安装。</p><p>database.json 文件格式：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data1"</span>: &#123;</span><br><span class="line">    <span class="attr">"subdata1"</span>: <span class="string">"value1"</span>,</span><br><span class="line">    <span class="attr">"subdata2"</span>: <span class="string">"value2"</span>,</span><br><span class="line">    <span class="attr">"subdata3"</span>: <span class="string">"value3"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"data2"</span>: &#123;<span class="attr">"subdata1"</span>: , <span class="attr">"subdata2"</span>: , <span class="attr">"subdata3"</span>: &#125;,</span><br><span class="line">  <span class="attr">"data3"</span>: &#123;<span class="attr">"subdata1"</span>: , <span class="attr">"subdata2"</span>: , <span class="attr">"subdata3"</span>: &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置完 json 文件后，使用<code>json-server --watch --port 3001 database.json</code> 命令，启动服务 database.json。访问<code>localhost:3001</code>可以查看 json 数据。</p><h3 id="实现各类数据请求"><a href="#实现各类数据请求" class="headerlink" title="实现各类数据请求"></a>实现各类数据请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /</span><br><span class="line">GET|POST /post</span><br><span class="line">GET|POST /post/<span class="number">1</span></span><br><span class="line">GET /post?param1=&amp;param2=</span><br><span class="line">GET /post/post?_page=<span class="number">1</span></span><br><span class="line">GET /posts?_sort=views&amp;_order=asc</span><br><span class="line">GET /posts?_start=<span class="number">20</span>&amp;_end=<span class="number">30</span></span><br><span class="line">GET /posts?q=xxx <span class="comment">// 搜索功能</span></span><br></pre></td></tr></table></figure><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>json-server 可以自定义路由，检验条件或输出格式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonServer = <span class="built_in">require</span>(<span class="string">'json-server'</span>) <span class="comment">// 创建json-server服务</span></span><br><span class="line"><span class="keyword">const</span> server = jsonServer.create() <span class="comment">// 创建http服务</span></span><br><span class="line"><span class="keyword">const</span> router = jsonServer.router(<span class="string">'db.js'</span>) <span class="comment">// 路由匹配的js数据</span></span><br><span class="line"><span class="keyword">const</span> middleWares = jsonServer.defaults() <span class="comment">// 使用默认中间件</span></span><br><span class="line"></span><br><span class="line">server.use(jsonServer.bodyParser) <span class="comment">// 安装json-server自带的body-parser，用于获取非地址栏传递的数据</span></span><br><span class="line">server.use(middleWares)</span><br><span class="line">server.use(router)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听自定义路由</span></span><br><span class="line">server.listen(&#123; <span class="attr">host</span>: <span class="string">'192.168.137.1'</span>, <span class="attr">post</span>: <span class="number">3000</span> &#125;, () =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'JSON Server is running'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其它功能：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义js数据地址</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> router = jsonServer.router(path.join(__dirname, <span class="string">'db.json'</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义注册操作</span></span><br><span class="line"><span class="comment">// 注意： 自定义路由响应需要在安装json-server的router之前</span></span><br><span class="line">server.post(</span><br><span class="line"><span class="string">'/mock/register'</span>,</span><br><span class="line">(&#123; <span class="attr">body</span>: &#123; username = <span class="string">''</span>, password = <span class="string">''</span> &#125; &#125;, res) =&gt; &#123;</span><br><span class="line"><span class="comment">// console.log(username,password);</span></span><br><span class="line">username !== <span class="string">'admin'</span> &amp;&amp; password</span><br><span class="line">? res.jsonp(&#123;</span><br><span class="line">err: <span class="number">0</span>,</span><br><span class="line">msg: <span class="string">'注册成功'</span>,</span><br><span class="line">data: &#123;</span><br><span class="line">username,</span><br><span class="line">password,</span><br><span class="line">&#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">: res.jsonp(&#123;</span><br><span class="line">err: <span class="number">1</span>,</span><br><span class="line">msg: <span class="string">'注册失败'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  增加检验条件 isAuthorized</span></span><br><span class="line">server.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isAuthorized(req)) &#123;</span><br><span class="line"><span class="comment">// add your authorization logic here</span></span><br><span class="line">next() <span class="comment">// continue to JSON Server router</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.sendStatus(<span class="number">401</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义返回内容</span></span><br><span class="line">router.render = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> status</span><br><span class="line"><span class="keyword">let</span> len = <span class="built_in">Object</span>.keys(res.locals.data).length <span class="comment">// 判断是否获取到mockJS模拟的数据</span></span><br><span class="line"><span class="keyword">if</span> (res.req.originalMethod === <span class="string">'DELETE'</span>) &#123;</span><br><span class="line">status = len === <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">status = !!len</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 由于本地请求速度较快，不方便loading动效显示利用延时器，模拟真实服务器请求速度</span></span><br><span class="line">res.jsonp(&#123;</span><br><span class="line"><span class="comment">// 使用res.jsonp()方法将mockJS模拟生成的数据进行自定义包装后输出</span></span><br><span class="line">err: status ? <span class="number">0</span> : <span class="number">1</span>,</span><br><span class="line">msg: <span class="string">'操作'</span> + (status ? <span class="string">'成功'</span> : <span class="string">'失败'</span>),</span><br><span class="line">data: res.locals.data,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mockjs"><a href="#mockjs" class="headerlink" title="mockjs"></a>mockjs</h2><p>Mock.js 是一款模拟数据生成器，可以根据数据模板生成模拟数据，模拟 Ajax 请求，基于 HTML 模板生成模拟数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install mockjs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> Mock = <span class="built_in">require</span>(<span class="string">'mockjs'</span>);</span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Mock.js 使用数据模板定义生成模拟数据，数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：<code>&#39;name|rule&#39;: value</code>。也可以使用<code>Mock.Random</code> 工具类生成各种随机数据。具体语法在<a href="http://mockjs.com/0.1/#" target="_blank" rel="noopener">Mock.js 官网</a>中有详细说明。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Mock = <span class="built_in">require</span>(<span class="string">"mockjs"</span>); <span class="comment">// 引入mockJS</span></span><br><span class="line"><span class="keyword">const</span> MR = Mock.Random; <span class="comment">// 提mock的随机对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">"home|5"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"id|+1"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"@cname"</span>,</span><br><span class="line">        <span class="string">"imgURL"</span>: MR.image(<span class="string">'750X200'</span>,MR.color(),MR.cword(<span class="number">4</span>,<span class="number">10</span>))</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-配置数据地址"><a href="#webpack-配置数据地址" class="headerlink" title="webpack 配置数据地址"></a>webpack 配置数据地址</h2><hr><p><a href="https://blog.csdn.net/qq_41629150/article/details/99645632" target="_blank" rel="noopener">https://blog.csdn.net/qq_41629150/article/details/99645632</a><br><a href="https://github.com/typicode/json-server#getting-started" target="_blank" rel="noopener">https://github.com/typicode/json-server#getting-started</a></p><p><a href="http://mockjs.com/0.1/#" target="_blank" rel="noopener">Mock.js 官网</a><br><a href="https://github.com/typicode/json-server#getting-started" target="_blank" rel="noopener">json-server</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;进行 web 网站开发时，前后端分离导致开发进度不同，前端经常需要等待后端的接口数据完成开发才可以继续调试。且开发环境，测试环境和线上环境分离，本地开发时无法运用测试环境的接口，开发时的接口和最终部署的接口也并不相同，每次测试时来回部署代码要耗费很多时间。&lt;br&gt;&amp;emsp;&amp;emsp;使用 json-server + mockjs 编写 json 格式的模拟数据接口，在等待后端准备接口期间，前端可以使用假数据进行模拟。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="JavaScript" scheme="https://hyqskevin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>imblearn API</title>
    <link href="https://hyqskevin.github.io/2019/08/20/imbalanced_data_analysis/"/>
    <id>https://hyqskevin.github.io/2019/08/20/imbalanced_data_analysis/</id>
    <published>2019-08-20T01:31:47.000Z</published>
    <updated>2020-11-19T06:55:50.457Z</updated>
    
    <content type="html"><![CDATA[<p>imblearn 是 python 的第三方库，用于处理不平衡数据(imbalanced data)的分类，一般分为降采样，过采样和综合采样</p><a id="more"></a><h2 id="imblearn-under-sampling-降采样"><a href="#imblearn-under-sampling-降采样" class="headerlink" title="imblearn.under_sampling 降采样"></a>imblearn.under_sampling 降采样</h2><p>使用<code>imblearn.under_sampling.prototype_generation</code>来生成新样本</p><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p>sampling_strategy<br>return_indices<br>random_state<br>n_neighbors<br>n_seeds_S<br>kind_sel<br>n_jobs<br>ratio</p><h3 id="原型选择"><a href="#原型选择" class="headerlink" title="原型选择"></a>原型选择</h3><p><code>CondensedNearestNeighbour(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=None, n_seeds_S=1, n_jobs=1, ratio=None)</code><br>基于压缩最近邻方法执行欠采样<br><code>EditedNearestNeighbours(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=3, kind_sel=&#39;all&#39;, n_jobs=1, ratio=None)</code><br>基于编辑的最近邻居方法执行欠采样<br><code>RepeatedEditedNearestNeighbours(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=3, max_iter=100, kind_sel=&#39;all&#39;, n_jobs=1, ratio=None)</code><br>基于重复编辑的最近邻居方法执行欠采样<br><code>AllKNN(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=3, kind_sel=&#39;all&#39;, allow_minority=False, n_jobs=1, ratio=None)</code><br>基于 AllKNN 方法执行欠采样<br><code>InstanceHardnessThreshold(estimator=None, sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, cv=5, n_jobs=1, ratio=None)</code><br>根据实例硬度阈值执行欠采样<br><code>NearMiss(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, version=1, n_neighbors=3, n_neighbors_ver3=3, n_jobs=1, ratio=None)</code><br>基于 NearMiss 方法执行欠采样<br><code>NeighbourhoodCleaningRule(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=3, kind_sel=&#39;all&#39;, threshold_cleaning=0.5, n_jobs=1, ratio=None)</code><br>根据邻居清洁规则进行欠采样<br><code>OneSidedSelection(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_neighbors=None, n_seeds_S=1, n_jobs=1, ratio=None)</code><br>基于单侧选择方法执行欠采样<br><code>RandomUnderSampler(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, replacement=False, ratio=None)[source]</code><br>用于执行随机欠采样<br><code>TomekLinks(sampling_strategy=&#39;auto&#39;, return_indices=False, random_state=None, n_jobs=1, ratio=None)</code><br>通过删除 Tomek 的链接来执行欠采样 s</p><h2 id="imblearn-over-sampling-过采样"><a href="#imblearn-over-sampling-过采样" class="headerlink" title="imblearn.over_sampling 过采样"></a>imblearn.over_sampling 过采样</h2><p>ADASYN（[sampling_strategy，…]） 使用自适应合成（ADASYN）采样方法对不平衡数据集执行过采样。<br>BorderlineSMOTE（[…]） 使用 Borderline SMOTE 进行过采样。<br>KMeansSMOTE（[…]） 在使用 SMOTE 进行过采样之前应用 KMeans 聚类。<br>RandomOverSampler（[…]） 用于执行随机过采样的类。<br>SMOTE（[sampling_strategy，…]） 使用 SMOTE 执行过采样的类。<br>SMOTENC（categorical_features） 标称和连续的合成少数过采样技术（SMOTE-NC）。<br>SVMSMOTE（[sampling_strategy，…]） 使用 SVM-SMOTE 进行过采样。</p><h2 id="imblearn-combine-组合采样"><a href="#imblearn-combine-组合采样" class="headerlink" title="imblearn.combine 组合采样"></a>imblearn.combine 组合采样</h2><p>SMOTEENN（[sampling_strategy，…]） 使用 SMOTE 执行过采样并使用 ENN 进行清洁的类。<br>SMOTETomek（[sampling_strategy，…]） 使用 SMOTE 执行过采样并使用 Tomek 链接进行清洁的类。</p><h2 id="imblearn-ensemble-方法整合"><a href="#imblearn-ensemble-方法整合" class="headerlink" title="imblearn.ensemble 方法整合"></a>imblearn.ensemble 方法整合</h2><p>BalancedBaggingClassifier（[…]） Bagging 分级机，具 ​​ 有额外的平衡功能。<br>BalancedRandomForestClassifier（[…]） 平衡的随机森林分类器。<br>EasyEnsemble（** kwargs） 通过迭代应用随机欠采样来创建集合集。<br>EasyEnsembleClassifier（[…]） 一袋平衡的提升学习者也被称为 EasyEnsemble。<br>RUSBoostClassifier（[…]） 随机欠采样集成在 AdaBoost 分类器的学习中。</p><hr><p>参考资料：<br><a href="https://imbalanced-learn.org/en/stable/index.html" target="_blank" rel="noopener">https://imbalanced-learn.org/en/stable/index.html</a><br><a href="https://github.com/scikit-learn-contrib/imbalanced-learn" target="_blank" rel="noopener">https://github.com/scikit-learn-contrib/imbalanced-learn</a><br><a href="https://blog.csdn.net/qq_31813549/article/details/79964973" target="_blank" rel="noopener">https://blog.csdn.net/qq_31813549/article/details/79964973</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;imblearn 是 python 的第三方库，用于处理不平衡数据(imbalanced data)的分类，一般分为降采样，过采样和综合采样&lt;/p&gt;
    
    </summary>
    
      <category term="repo" scheme="https://hyqskevin.github.io/categories/repo/"/>
    
    
      <category term="python" scheme="https://hyqskevin.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>tip:决策树、随机森林结果可视化</title>
    <link href="https://hyqskevin.github.io/2019/08/10/decision-tree-visualization/"/>
    <id>https://hyqskevin.github.io/2019/08/10/decision-tree-visualization/</id>
    <published>2019-08-10T08:56:30.000Z</published>
    <updated>2020-11-19T06:55:59.831Z</updated>
    
    <content type="html"><![CDATA[<p>scikit-learn 决策树结果的可视化,方便观察模型，以及发现模型中的问题。<br>需要安装 <code>graphviz</code></p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装-graphviz"><a href="#安装-graphviz" class="headerlink" title="安装 graphviz"></a>安装 graphviz</h3><p>linux：<code>sudo apt install graphviz</code><br>windows: 去官网下载 <a href="http://www.graphviz.org/" target="_blank" rel="noopener">http://www.graphviz.org/</a></p><p>设置环境变量：将 graphviz 的 bin 目录加到 PATH</p><p>安装 python 库 graphviz，pydotplus：<br><code>pip install graphviz, pydotplus</code></p><h2 id="可视化模型"><a href="#可视化模型" class="headerlink" title="可视化模型"></a>可视化模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = DecisionTreeClassifier(max_depth=max_depth_val)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用graphviz提取出节点数据</span></span><br><span class="line">dot_data = tree.export_graphviz(clf, out_file=<span class="keyword">None</span>, feature_names=feature_names, class_names=target_names, filled=<span class="keyword">True</span>, rounded=<span class="keyword">True</span>, special_characters=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h2 id="生成可视化文件"><a href="#生成可视化文件" class="headerlink" title="生成可视化文件"></a>生成可视化文件</h2><p>可利用 pydotplus 生成 pdf 文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = pydotplus.graph_from_dot_data(dot_data)</span><br><span class="line">graph.write_pdf(<span class="string">"dataset.pdf"</span>)</span><br></pre></td></tr></table></figure><p>也可以利用 Ipython 的图片显示功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</span><br><span class="line">graph = pydotplus.graph_from_dot_data(dot_data)</span><br><span class="line">Image(graph.create_png())</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://blog.csdn.net/ydyang1126/article/details/78842952" target="_blank" rel="noopener">https://blog.csdn.net/ydyang1126/article/details/78842952</a><br><a href="https://github.com/ljpzzz/machinelearning/blob/master/classic-machine-learning/decision_tree_classifier.ipynb" target="_blank" rel="noopener">https://github.com/ljpzzz/machinelearning/blob/master/classic-machine-learning/decision_tree_classifier.ipynb</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;scikit-learn 决策树结果的可视化,方便观察模型，以及发现模型中的问题。&lt;br&gt;需要安装 &lt;code&gt;graphviz&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="notes" scheme="https://hyqskevin.github.io/categories/notes/"/>
    
    
      <category term="sklearn" scheme="https://hyqskevin.github.io/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>如何写日志</title>
    <link href="https://hyqskevin.github.io/2019/08/04/write_log/"/>
    <id>https://hyqskevin.github.io/2019/08/04/write_log/</id>
    <published>2019-08-04T08:56:30.000Z</published>
    <updated>2020-11-19T06:55:20.217Z</updated>
    
    <content type="html"><![CDATA[<p>在开发时学习书写日志的方法，方便做测试。<br>例举使用 python 和 java 上的日志记录<br>—loading…—</p><a id="more"></a><h2 id="常用日志框架"><a href="#常用日志框架" class="headerlink" title="常用日志框架"></a>常用日志框架</h2><p>log4j、Logging、commons-logging、slf4j、logback</p><p>Logging：Java 自带的日志工具类<br>Log4j：Apache 的一个开源日志框架，log4j 在 2015/08/05 这一天被 Apache 宣布停止维护了，用户需要切换到 Log4j2 上面去<br>commons-logging：日志的门面接口，它也是 apache 最早提供的日志门面接口，用户可以根据喜好选择不同的日志实现框架，而不必改动日志定义<br>Slf4j：Simple Logging Facade for Java，即简单日志门面接口<br>Logback：Slf4j 的原生实现框架，同样也是出自 Log4j 一个人之手，但拥有比 log4j 更多的优点、特性和更做强的性能，现在基本都用来代替 log4j 成为主流</p><ol><li>commons-loggin、slf4j 只是一种日志抽象门面，不是具体的日志框架。</li><li>log4j、logback 是具体的日志实现框架。</li><li>推荐使用 <code>slf4j + logback</code> 还有<code>slf4j + log4j</code> <code>commons-logging + log4j</code> 这两种日志组合框架。</li></ol><ul><li>Python 的 logging 模块提供了通用的日志系统。logging 模块与 log4j 的机制相同，只是具体的实现细节不同。</li></ul><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><div class="table-container"><table><thead><tr><th>日志级别(Java)</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>OFF</td><td style="text-align:left">关闭：最高级别，不输出日志。</td></tr><tr><td>FATAL</td><td style="text-align:left">致命：输出非常严重的可能会导致应用程序终止的错误。</td></tr><tr><td>ERROR</td><td style="text-align:left">错误：输出错误，但应用还能继续运行。</td></tr><tr><td>WARN</td><td style="text-align:left">警告：输出可能潜在的危险状况。</td></tr><tr><td>INFO</td><td style="text-align:left">信息：输出应用运行过程的详细信息。</td></tr><tr><td>DEBUG</td><td style="text-align:left">调试：输出更细致的对调试应用有用的信息。</td></tr><tr><td>TRACE</td><td style="text-align:left">跟踪：输出更细致的程序运行轨迹。</td></tr><tr><td>ALL</td><td style="text-align:left">所有：输出所有级别信息。</td></tr></tbody></table></div><p>Java：ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF<br>Python：NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</p><h2 id="Log4J-的运用"><a href="#Log4J-的运用" class="headerlink" title="Log4J 的运用"></a>Log4J 的运用</h2><p>Log4j 有三个主要的组件：Loggers(记录器)，Appenders(输出源)和 Layouts(布局)，这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出</p><h2 id="logging-的运用"><a href="#logging-的运用" class="headerlink" title="logging 的运用"></a>logging 的运用</h2><p>logging 模块提供 logger、handler、filter、formatter</p><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><p>记录获取到的数据，通过模块的 getLogger(name)函数获得</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger = logging.getLogger(<span class="string">'test'</span>)    <span class="comment"># 获取名为 test 的 logger</span></span><br><span class="line">logger.addHandler(handler)           <span class="comment"># 为 logger 添加 handler</span></span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>setLevel(lvl)</td><td>设置日志级别</td></tr><tr><td>isEnabledFor(lvl)</td><td>检查某级别的日志是否启用</td></tr><tr><td>getEffectiveLevel()</td><td>获取实际的日志级别</td></tr><tr><td>debug/warning/info/error(msg, *args, **kwargs)</td><td>输出对应级别的日志</td></tr><tr><td>log(lvl, msg, *args, **kwargs)</td><td>输出指定级别的日志</td></tr><tr><td>addFilter(filt)/removeFilter(filt)</td><td>添加或删除指定的过滤器</td></tr><tr><td>addHandler(hdlr)/removeHandler(hdlr)</td><td>添加或删除指定的处理器</td></tr></tbody></table></div><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>用于指定日志向哪里输出（文件、终端等等）</p><p>常用的 Handler 有以下几种：</p><ul><li>StreamHandler， 用于向标准输入输出流等输出日志。</li><li>FileHandler，用于向文件输出日志。</li><li>NullHandler，什么也不输出。</li><li>RotatingFileHandler，向文件输出日志，如果文件到达指定大小，创建新文件并继续输出日志。</li></ul><p>相关 handler 类型参考<a href="https://docs.python.org/zh-cn/3/library/logging.handlers.html#module-logging.handlers" target="_blank" rel="noopener">python 官方文档</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler = logging.handlers.RotatingFileHandler(LOG_FILE,axBytes=<span class="number">1024</span>*<span class="number">1024</span>, backupCount = <span class="number">5</span>) <span class="comment"># 实例化 handler</span></span><br></pre></td></tr></table></figure><h3 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h3><p>指定日志记录输出的具体格式，采用的是 %(key)s 的形式<br>formatter 构造方法需要两个参数：消息的格式字符串和日期字符串</p><div class="table-container"><table><thead><tr><th>日志格式</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td>%(name)s</td><td style="text-align:left">生成日志的 Logger 名称</td></tr><tr><td>%(levelno)s</td><td style="text-align:left">数字形式的日志级别，包括 DEBUG, INFO, WARNING, ERROR 和 CRITICAL</td></tr><tr><td>%(levelname)s</td><td style="text-align:left">文本形式的日志级别，包括’DEBUG’、 ‘INFO’、 ‘WARNING’、 ‘ERROR’ 和’CRITICAL’</td></tr><tr><td>%(pathname)s</td><td style="text-align:left">输出该日志的语句所在源文件的完整路径（如果可用）</td></tr><tr><td>%(filename)s</td><td style="text-align:left">文件名</td></tr><tr><td>%(module)s</td><td style="text-align:left">输出该日志的语句所在的模块名</td></tr><tr><td>%(funcName)s</td><td style="text-align:left">调用日志输出函数的函数名</td></tr><tr><td>%(lineno)d</td><td style="text-align:left">调用日志输出函数的语句所在的代码行（如果可用）</td></tr><tr><td>%(created)f</td><td style="text-align:left">日志被创建的时间，UNIX 标准时间格式，表示从 1970-1-1 00:00:00 UTC 计算起的秒数</td></tr><tr><td>%(relativeCreated)d</td><td style="text-align:left">日志被创建时间与日志模块被加载时间的时间差，单位为毫秒</td></tr><tr><td>%(asctime)s</td><td style="text-align:left">日志创建时间。默认格式是 “2003-07-08 16:49:45,896”，逗号后为毫秒数</td></tr><tr><td>%(msecs)d</td><td style="text-align:left">毫秒级别的日志创建时间</td></tr><tr><td>%(thread)d</td><td style="text-align:left">线程 ID（如果可用）</td></tr><tr><td>%(threadName)s</td><td style="text-align:left">线程名称（如果可用）</td></tr><tr><td>%(process)d</td><td style="text-align:left">进程 ID（如果可用）</td></tr><tr><td>%(message)s</td><td style="text-align:left">日志信息</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 日志样例</span><br><span class="line">2019-08-04 23:21:59,682 - log_test.py:16 - test - first info message</span><br><span class="line">2019-08-04 23:21:59,682 - log_test.py:17 - test - first debug message</span><br><span class="line"></span><br><span class="line"># 日志格式</span><br><span class="line">%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出</p><h4 id="config-模块配置日志"><a href="#config-模块配置日志" class="headerlink" title="config 模块配置日志"></a>config 模块配置日志</h4><p>logging.basicConfig()<br>logging</p><h3 id="python-日志示例"><a href="#python-日志示例" class="headerlink" title="python 日志示例"></a>python 日志示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"></span><br><span class="line">LOG_FILE = <span class="string">'test.log'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">'test'</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化handler</span></span><br><span class="line">consoleHandler = logging.StreamHandler()</span><br><span class="line">Filehandler = logging.handlers.RotatingFileHandler(LOG_FILE,axBytes = <span class="number">1024</span>*<span class="number">1024</span>, backupCount = <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化formatter</span></span><br><span class="line">fmt = <span class="string">'%(asctime)s - %(filename)s:%(lineno)s - %(name)s - %(message)s'</span></span><br><span class="line">formatter = logging.Formatter(fmt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 handler 添加 formatter</span></span><br><span class="line">consoleHandler.setFormatter(formatter)</span><br><span class="line">Filehandler。setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加到logger中</span></span><br><span class="line">logger.addHandler(consolehandler)</span><br><span class="line">logger.addHandler(Filehandler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印日志</span></span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.warning(<span class="string">'warn message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical meaasge'</span>)</span><br><span class="line">logger.debug(<span class="string">'%s 自定义信息'</span> % <span class="string">'define message'</span>)</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="https://blog.csdn.net/wud_jiyanhui/article/details/6213443" target="_blank" rel="noopener">https://blog.csdn.net/wud_jiyanhui/article/details/6213443</a><br><a href="https://blog.csdn.net/u011054333/article/details/69215660" target="_blank" rel="noopener">https://blog.csdn.net/u011054333/article/details/69215660</a><br><a href="https://help.aliyun.com/document_detail/28990.html?spm=a2c4g.11186623.6.746.7cfa66d8dwy2XO" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/28990.html?spm=a2c4g.11186623.6.746.7cfa66d8dwy2XO</a><br><a href="https://help.aliyun.com/document_detail/28989.html?spm=a2c4g.11186623.6.745.3ef949faCiQ7PW" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/28989.html?spm=a2c4g.11186623.6.745.3ef949faCiQ7PW</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发时学习书写日志的方法，方便做测试。&lt;br&gt;例举使用 python 和 java 上的日志记录&lt;br&gt;—loading…—&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="python" scheme="https://hyqskevin.github.io/tags/python/"/>
    
      <category term="log" scheme="https://hyqskevin.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>boosting</title>
    <link href="https://hyqskevin.github.io/2019/08/01/boosting/"/>
    <id>https://hyqskevin.github.io/2019/08/01/boosting/</id>
    <published>2019-08-01T01:56:30.000Z</published>
    <updated>2020-11-19T06:56:07.853Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xgboost.ai/" target="_blank" rel="noopener">XgBoost</a> 和 <a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="noopener">LightGBM</a> 官方文档阅读和算法学习<br><code>*</code>号为未解释完全，具体使用方法请参考官方文档</p><a id="more"></a><h2 id="XgBoost"><a href="#XgBoost" class="headerlink" title="XgBoost"></a>XgBoost</h2><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><p><code>booster</code> [default= gbtree ]  基础模型类型，可选参数包括: gbtree、gblinear、dart，其中 gbtree、dart 为树模型、gblinear 为线性函数模型</p><p><code>eta</code> 学习率</p><p><code>tree_method</code> XGBoost 中树的构造算法，可选项包括: auto, exact, approx, hist, gpu_exact, gpu_hist</p><p><code>eval_metric</code> 依据目标函数选择评估指标<br>rmse: 根均方误差<br>mae: 平均绝对值误差<br>logloss: 负的似然函数<br>error: 二分类问题的分类错误率<br>merror: 多分类问题的分类错误率<br>mlogloss: 多分类问题的负似然函数<br>auc: IOC 曲线下面积<br>aucpr: PR 曲线下面积</p><p><code>updater</code> 线性模型的拟合算法<br>shotgun: 基于 shotgun 算法的坐标下降法<br>coord_descent: 普通的坐标下降法<br>feature_selector: 特征选择和排序算法</p><p><code>objective</code> 训练的模型类型和目标函数<br>reg:linear: 线性回归<br>reg:logistic: 逻辑回归<br>binary:logistic: 二分类问题, 输出概率值<br>binary:logitraw: 二分类问题, 输出得分值，需要通过 sigmoid 函数转化成概率值<br>binary:hinge: 二分类问题，使用铰链损失函数,输出 0 或 1，而不是概率值<br>count:poisson: 用于计数问题的泊松分布，输出泊松分布的均值。<br>survival:cox: Cox regression for right censored survival time data<br>multi:softmax: 多分类目标函数, 使用此目标函数，需要设置样本类别数据： num_class<br>multi:softprob: 同 softmax, 但是输出的结果为 ndata * nclass 维的向量，表示样本属于每个类别的概率</p><p><code>cyclic</code>: 循环变量特征<br><code>shuffle</code>: 类型与循环变量特征，但是在每次更新时都会随机打乱特征的顺序<br><code>random</code>: 随机(带替换)的坐标选择器<br><code>greedy</code>: 选择最大梯度的坐标<br><code>thrifty</code>: 近似 greedy 的坐标选择器<br><code>top_k</code>: greedy 算法和 thrifty 算法选择的最优特征数量，0 表示不限制。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><strong>1. 数据结构类，提供数据的构建和处理</strong><br><code>xgboost.DMatrix(data, label=None, missing=None, weight=None, silent=False, feature_names=None, feature_types=None)</code></p><p><code>data</code>数据源或文件路径<br><code>label</code>训练数据的标签<br><code>missing</code>缺省值表示字符，如果没填, 默认值为：np.nan<br><code>weight</code>每个样本的权重<br><code>silent</code>构造数据结构时是否显示日志<br><code>feature_names</code>各个特征的名称<br><code>feature_types</code>各个特征的数据类型<br><code>nthread</code> 加载数据开启的线程数</p><p><strong>2. 模型类，提供了一些基础的函数，如模型加载、保存、评估和预测等方法</strong><br><code>xgboost.Booster(params=None, cache=(), model_file=None)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">load_model(fname)</span><br><span class="line">从文件或内存中加载模型，参数含义如下：</span><br><span class="line"></span><br><span class="line">fname (string <span class="keyword">or</span> a memory buffer) – 模型文件名称或内存缓存对象</span><br><span class="line"><span class="number">2.</span> save_model(fname)</span><br><span class="line">将模型保存到文件中，参数的含义如下：</span><br><span class="line"></span><br><span class="line">fname (string) – 输出文件的名称</span><br><span class="line"><span class="number">3.</span> eval(data, name, iteration)</span><br><span class="line">用给定的数据评估模型好坏，参数的含义如下:</span><br><span class="line"></span><br><span class="line">data (DMatrix) – 用于评估模型的数据</span><br><span class="line"></span><br><span class="line">name (str, 可选) – 用于评估模型的数据集名称</span><br><span class="line"></span><br><span class="line">iteration (int, 可选) –迭代次数</span><br></pre></td></tr></table></figure><p><strong>3. 对模型进行训练</strong><br><code>xgboost.train(params, dtrain, num_boost_round=10, evals=(), obj=None, feval=None, maximize=False, early_stopping_rounds=None, evals_result=None, verbose_eval=True, learning_rates=None, xgb_model=None, callbacks=None)</code></p><p><code>params</code>配置参数<br><code>dtrain</code>训练数据<br><code>num_boost_round</code>生成树的数量<br><code>evals</code>评估数据<br><code>obj</code>自定义的目标函数<br><code>feval</code>自定义的评价函数<br><code>maximize</code>是否最大化评价指标<br><code>early_stopping_rounds</code>错误率 early_stopping_rounds 轮未下降，则停止训练<br><code>evals_result</code>模型评估结果<br><code>learning_rates</code>学习率<br><code>xgb_model</code>在训练前加载之前训练的模型<br><code>callback</code>设置回调函数，比如重新设置学习率</p><p><strong>4. 对数据分类</strong><br><code>xgboost.XGBClassifier(max_depth=3, learning_rate=0.1, n_estimators=100, silent=True, objective=&#39;binary:logistic&#39;, nthread=-1, gamma=0, min_child_weight=1, max_delta_step=0, subsample=1, colsample_bytree=1, colsample_bylevel=1, reg_alpha=0, reg_lambda=1, scale_pos_weight=1, base_score=0.5, seed=0, missing=None)</code></p><p><code>max_depth</code> 最大树深度<br><code>learning_rate</code> 学习率<br><code>n_estimators</code> 树的迭代次数<br><code>gamma</code> 节点分裂需要下降的最小损失<br><code>min_child_weight</code> 节点中样本的最小权重和<br><code>max_delta_step</code> 每轮允许叶子输出值的最大增量<br><code>subsample</code> 每轮训练使用的样本数量等于样本总数乘以采样率<br><code>colsample_bytree</code> 每轮训练使用的特征占比<br><code>colsample_bylevel</code> 每层训练使用的特征占比<br><code>reg_alpha</code> L1 正则<br><code>reg_lambda</code> L2 正则<br><code>scale_pos_weight</code> 用于控制正例和负例均衡的权重<br><code>base_score</code> 初始时各个样本的得分</p><p><strong>5. 数据拟合和预测</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xgboost.fit(X, y, sample_weight=<span class="keyword">None</span>, eval_set=<span class="keyword">None</span>, eval_metric=<span class="keyword">None</span>, early_stopping_rounds=<span class="keyword">None</span>, verbose=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># sample_weight：每个训练样本的权重</span></span><br><span class="line"><span class="comment"># eval_set：设置验证集</span></span><br><span class="line"><span class="comment"># eval_metric：验证的度量指标</span></span><br><span class="line"><span class="comment"># early_stopping_rounds` 指定连续多少轮未改善后停止</span></span><br><span class="line"></span><br><span class="line">xgboost.predict(data, output_margin=<span class="keyword">False</span>, ntree_limit=<span class="number">0</span>, pred_leaf=<span class="keyword">False</span>, pred_contribs=<span class="keyword">False</span>, approx_contribs=Flase, pred_interactions=<span class="keyword">False</span>, validate_features=Flase)`</span><br><span class="line"></span><br><span class="line"><span class="comment"># output_margin 是否输出原始未经转化的值</span></span><br><span class="line"><span class="comment"># ntree_limit 用于预测的树的数量，默认为0，代表使用所有树进行预测</span></span><br><span class="line"><span class="comment"># pred_leaf 指明每条数据分别落到每棵树的哪个叶子节点上</span></span><br><span class="line"><span class="comment"># pred_contribs 指明每个样本的每个特征对预测结果的贡献值</span></span><br><span class="line"><span class="comment"># approx_contribs 是否启用特征贡献大小的预估功能</span></span><br><span class="line"><span class="comment"># pred_interactions 指明两两特征间相互影响的SHAP值</span></span><br><span class="line"><span class="comment"># validate_features首先验证待预测的数据特征名称是否与模型中的特征名称相同，默认情况下，系统认为他们是相同的，不进行验证</span></span><br></pre></td></tr></table></figure><ul><li><code>class xgboost.XGBRegressor()</code>用于回归任务</li></ul><h3 id="XgBoost-示例"><a href="#XgBoost-示例" class="headerlink" title="XgBoost 示例"></a>XgBoost 示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"></span><br><span class="line">train_data = pd.read_csv(<span class="string">'train.csv'</span>)   <span class="comment"># 读取数据</span></span><br><span class="line">y = train_data.pop(<span class="string">'30'</span>).values   <span class="comment"># 用pop方式将训练数据中的标签值y取出来，作为训练目标，这里的‘30’是标签的列名</span></span><br><span class="line">col = train_data.columns</span><br><span class="line">x = train_data[col].values  <span class="comment"># 剩下的列作为训练数据</span></span><br><span class="line">train_x, valid_x, train_y, valid_y = train_test_split(x, y, test_size=<span class="number">0.333</span>, random_state=<span class="number">0</span>)   <span class="comment"># 分训练集和验证集</span></span><br><span class="line"><span class="comment"># 这里不需要Dmatrix</span></span><br><span class="line"></span><br><span class="line">parameters = &#123;</span><br><span class="line">              <span class="string">'max_depth'</span>: [<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>],</span><br><span class="line">              <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.15</span>],</span><br><span class="line">              <span class="string">'n_estimators'</span>: [<span class="number">500</span>, <span class="number">1000</span>, <span class="number">2000</span>, <span class="number">3000</span>, <span class="number">5000</span>],</span><br><span class="line">              <span class="string">'min_child_weight'</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">              <span class="string">'max_delta_step'</span>: [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              <span class="string">'subsample'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.85</span>, <span class="number">0.95</span>],</span><br><span class="line">              <span class="string">'colsample_bytree'</span>: [<span class="number">0.5</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>],</span><br><span class="line">              <span class="string">'reg_alpha'</span>: [<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],</span><br><span class="line">              <span class="string">'reg_lambda'</span>: [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>],</span><br><span class="line">              <span class="string">'scale_pos_weight'</span>: [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">xlf = xgb.XGBClassifier(max_depth=<span class="number">10</span>,</span><br><span class="line">            learning_rate=<span class="number">0.01</span>,</span><br><span class="line">            n_estimators=<span class="number">2000</span>,</span><br><span class="line">            silent=<span class="keyword">True</span>,</span><br><span class="line">            objective=<span class="string">'binary:logistic'</span>,</span><br><span class="line">            nthread=<span class="number">-1</span>,</span><br><span class="line">            gamma=<span class="number">0</span>,</span><br><span class="line">            min_child_weight=<span class="number">1</span>,</span><br><span class="line">            max_delta_step=<span class="number">0</span>,</span><br><span class="line">            subsample=<span class="number">0.85</span>,</span><br><span class="line">            colsample_bytree=<span class="number">0.7</span>,</span><br><span class="line">            colsample_bylevel=<span class="number">1</span>,</span><br><span class="line">            reg_alpha=<span class="number">0</span>,</span><br><span class="line">            reg_lambda=<span class="number">1</span>,</span><br><span class="line">            scale_pos_weight=<span class="number">1</span>,</span><br><span class="line">            seed=<span class="number">1440</span>,</span><br><span class="line">            missing=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有了gridsearch我们便不需要fit函数</span></span><br><span class="line">gsearch = GridSearchCV(xlf, param_grid=parameters, scoring=<span class="string">'accuracy'</span>, cv=<span class="number">3</span>)</span><br><span class="line">gsearch.fit(train_x, train_y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Best score: %0.3f"</span> % gsearch.best_score_)</span><br><span class="line">print(<span class="string">"Best parameters set:"</span>)</span><br><span class="line">best_parameters = gsearch.best_estimator_.get_params()</span><br><span class="line"><span class="keyword">for</span> param_name <span class="keyword">in</span> sorted(parameters.keys()):</span><br><span class="line">    print(<span class="string">"\t%s: %r"</span> % (param_name, best_parameters[param_name]))</span><br></pre></td></tr></table></figure><h2 id="LightGBM"><a href="#LightGBM" class="headerlink" title="LightGBM"></a>LightGBM</h2><h3 id="paramenter-常用参数"><a href="#paramenter-常用参数" class="headerlink" title="paramenter 常用参数"></a>paramenter 常用参数</h3><p><strong>objective</strong>:<br>‘regression’,’regression_l2’,’mean_squared_error’,’mse’,’l2_root’,’root_mean_squred_error’,’rmse’： 表示回归任务，但是使用 L2 损失函数。默认为’regression’<br>‘binary’： 表示二分类任务，使用对数损失函数作为目标函数。<br>‘multiclass’： 表示多分类任务，使用 softmax 函数作为目标函数。必须设置 num_class 参数<br>‘multiclassova’,’multiclass_ova’,’ova’,’ovr’： 表示多分类任务，使用 one-vs-all 的二分类目标函数。必须设置 num_class 参数<br>‘regression_l1’,’mae’,’mean_absolute_error’： 表示回归任务，但是使用 L1 损失函数。<br>‘huber’： 表示回归任务，但是使用 huber 损失函数。<br>‘fair’： 表示回归任务，但是使用 fair 损失函数。<br>‘poisson’： 表示 Poisson 回归任务。<br>‘quantile’： 表示 quantile 回归任务。<br>‘quantile_l2’：表示 quantile 回归任务，但是使用了 L2 损失函数。<br>‘mape’,’mean_absolute_precentage_error’： 表示回归任务，但是使用 MAPE 损失函数<br>‘gamma’： 表示 gamma 回归任务。<br>‘tweedie’： 表示 tweedie 回归任务。<br>‘xentropy’,’cross_entropy’： 目标函数为交叉熵（同时具有可选择的线性权重）。要求标签是[0,1] 之间的数值。<br>‘xentlambda’,’cross_entropy_lambda’： 替代了参数化的 cross_entropy 。要求标签是[0,1] 之间的数值。<br>‘lambdarank’：表示排序任务。</p><p><strong>boosting_type</strong>: // 基学习器模型算法<br>‘gbdt’： 表示传统的梯度提升决策树。默认值为’gbdt’<br>‘rf’： 表示随机森林。<br>‘dart’： 表示带 dropout 的 gbdt<br>‘goss’：表示 Gradient-based One-Side Sampling 的 gbdt</p><p><strong>metric</strong>：//指定度量的指标<br>‘l1’ 或者 mean_absolute_error 或者 mae 或者 regression_l1： 表示绝对值损失<br>‘l2’ 或者 mean_squared_error 或者 mse 或者 regression_l2 或者 regression：表示平方损失<br>‘l2_root’ 或者 root_mean_squared_error 或者 rmse：表示开方损失<br>‘quantile’ 表示 Quantile 回归中的损失<br>‘mape’ 或者 ‘mean_absolute_percentage_error’ 表示 MAPE 损失<br>‘huber’ 表示 huber 损失<br>‘fair’ 表示 fair 损失<br>‘poisson’ 表示 poisson 回归的负对数似然<br>‘gamma’ 表示 gamma 回归的负对数似然<br>‘gamma_deviance’ 表示 gamma 回归的残差的方差<br>‘tweedie’ 表示 Tweedie 回归的负对数似然<br>‘ndcg’ 表示 NDCG<br>‘map’ 或者’mean_average_precision’ 表示平均的精度<br>‘auc’ 表示 AUC<br>‘binary_logloss’或者’binary’ 表示二类分类中的对数损失函数<br>‘binary_error’ 表示二类分类中的分类错误率<br>‘multi_logloss’或者 ‘multiclass’或者 ‘softmax’或者 ‘multiclassova’或者 ‘multiclass_ova’,或者’ova’或者 ‘ovr’ 表示多类分类中的对数损失函数<br>‘multi_error’ 表示多分类中的分类错误率<br>‘xentropy’或者’cross_entropy’ 表示交叉熵<br>‘xentlambda’ 或者’cross_entropy_lambda’ 表示 intensity 加权的交叉熵<br>‘kldiv’或者’kullback_leibler’ 表示 KL 散度</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>1. 数据结构类，提供数据的构建和处理</strong><br><code>lightgbm.Dataset(data, label=None, max_bin=None, reference=None, weight=None, group=None, init_score=None, silent=False, feature_name=&#39;auto&#39;, categorical_feature=&#39;auto&#39;, params=None, free_raw_data=True)</code></p><p><code>label</code> 指定数据的标签列<br><code>max_bin</code> 特征值最大分类数量<br><code>reference</code> 增加评估参照，评估模型时使用，reference=train<br><code>weight</code> 设置权重<br><code>group</code> 设置数据组的大小<br><code>init_score</code> 加入之前的分数<br><code>silent</code> 是否在训练过程中屏蔽输出<br><code>feature_name</code> 特征名字<br><code>categorical_feature</code>设置分类特征<br><code>free_raw_data</code> 创建完后释放数据</p><p><strong>2. 模型类，提供了一些基础的函数，如模型加载、保存、评估和预测等方法</strong><br><code>lightgbm.Booster(params=None, train_set=None, model_file=None, model_str=None, silent=False)</code><br><code>params</code> 一个字典或者 None，给出了 Booster 的参数。默认为 None<br><code>train_set</code> 一个 Dataset 对象或者 None，给出了训练集。 默认为 None<br><code>model_file</code> 一个字符串或者 None，给出了 model file 的路径。 默认为 None<br><code>silent</code> 一个布尔值，指示是否在构建过程中打印消息。默认为 False</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lightgbm.add_valid(data,name) <span class="comment"># 添加一个验证集。</span></span><br><span class="line">lightgbm.current_iteration() <span class="comment"># 返回当前的迭代的index（即迭代的编号）</span></span><br><span class="line">lightgbm.dump_model(num_iteration=<span class="number">-1</span>) <span class="comment"># dump 当前的Booster 对象为json 格式。</span></span><br><span class="line">lightgbm.eval(data,name,feval=<span class="keyword">None</span>) <span class="comment"># 对指定的数据集evaluate</span></span><br><span class="line">lightgbm.eval_train(feval=<span class="keyword">None</span>) <span class="comment"># 对训练集进行evaluate</span></span><br><span class="line">lightgbm.eval_valid(feval=<span class="keyword">None</span>) <span class="comment"># 对验证集进行evaluate</span></span><br><span class="line">lightgbm.feature_importance(importance_type=<span class="string">'split'</span>, iteration=<span class="number">-1</span>) <span class="comment"># 获取特征的importance</span></span><br><span class="line">lightgbm.feature_name() <span class="comment"># 获取每个特征的名字。</span></span><br><span class="line">lightgbm.free_dataset() <span class="comment"># 释放Booster 对象的数据集</span></span><br><span class="line">lightgbm.free_network() <span class="comment"># 释放Booster 对象的Network</span></span><br><span class="line">lightgbm.get_leaf_output(tree_id, leaf_id) <span class="comment"># 获取指定叶子的输出</span></span><br><span class="line">lightgbm.num_feature() <span class="comment"># 获取特征的数量（即由多少列特征）</span></span><br><span class="line">lightgbm.reset_parameter(params) <span class="comment">#重设Booster 的参数。</span></span><br><span class="line">lightgbm.rollback_one_iter() <span class="comment"># 将Booster 回滚一个迭代步</span></span><br><span class="line">lightgbm.save_model(filename,num_iteration=<span class="number">-1</span>) <span class="comment"># 保存Booster 对象到文件中。</span></span><br><span class="line">lightgbm.set_attr(**kwargs) <span class="comment"># 设置Booster 的属性。</span></span><br><span class="line">lightgbm.set_network(machines,local_listen_port=<span class="number">12400</span>,listen_time_out=<span class="number">120</span>,num_machines=<span class="number">1</span>) <span class="comment"># 配置网络</span></span><br><span class="line">lightgbm.set_train_data_name(name) <span class="comment"># 设置训练集的名字</span></span><br><span class="line">lightgbm.update(train_set=<span class="keyword">None</span>, fobj=<span class="keyword">None</span>) <span class="comment"># 更新一个迭代步</span></span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><strong>1. <code>lightgbm.train()</code>执行训练</strong></p><p><code>lightgbm.train(params, train_set, num_boost_round=100, valid_sets=None, valid_names=None, fobj=None, feval=None, init_model=None, feature_name=&#39;auto&#39;, categorical_feature=&#39;auto&#39;, early_stopping_rounds=None, evals_result=None, verbose_eval=True, learning_rates=None, keep_training_booster=False, callbacks=None)</code></p><p><code>params</code> 相关参数配置，另外导入字典<br><code>train_set</code> 训练数据<br><code>num_boost_round</code> boost 迭代次数<br><code>valid_sets</code>，<code>valid_names</code> 设置训练时用于评估的数据集 <em><br><code>fobj</code> 自定义目标函数 preds, train_data -&gt; grad,hess </em><br><code>feval</code> 自定义评估函数 preds, train<em>data -&gt; eval_name, eval_result, is_higher_better </em><br><code>init_model</code> 导入之前训练数据<br><code>feature_name</code> 指定特征名字，数据源为 pandas DataFrame 会使用里面的 column<em>names<br><code>categorical_feature</code> 指定分类特征<br><code>early_stopping_rounds</code> 指定连续多少轮未改善后停止<br><code>evals_result</code> 指定字典存储 valid_sets 中验证的结果 </em><br><code>verbose_eval</code> 设置打印评估的间隔，可设置每个提升阶段打印或间隔<code>verbose_eval</code>个阶段打印<br><code>learning_rates</code> 设置学习率<br><code>keep_training_booster</code> 设置训练得到的 booster 是否继续训练<br><code>callbacks</code> 设置每次迭代后需要执行的函数</p><p>最后返回 booster 实例</p><p><strong>2. <code>lightgbm.cv()</code> 执行交叉检验</strong></p><p><code>lightgbm.cv(params, train_set, num_boost_round=10, folds=None, nfold=5, stratified=True, shuffle=True, metrics=None, fobj=None, feval=None, init_model=None, feature_name=&#39;auto&#39;,categorical_feature=&#39;auto&#39;, early_stopping_rounds=None, fpreproc=None, verbose_eval=None, show_stdv=True, seed=0, callbacks=None)</code></p><p><code>folds</code>：一个生成器、一个迭代器、或者 None <em><br><code>nfold</code>：指定交叉检验的数量。默认为 5<br><code>stratified</code>：指示是否进行分层拆分<br><code>shuffle</code>：指示是否在拆分之前先混洗数据<br><code>metrics</code>：指定评估度量标准，在 params 中设置<br><code>fpreproc</code>：设置预处理函数，在训练开始之前进行 </em><br><code>show_stdv</code>：在训练过程中展示标准差信息<br><code>seed</code>：一个整数，给出了生成 fold 的随机数种子 *</p><p>最后以字典的形式返回检验结果的均值和标准差</p><h3 id="scikit-learn-API"><a href="#scikit-learn-API" class="headerlink" title="scikit-learn API"></a>scikit-learn API</h3><p><strong>1. LGBMMOdel</strong><br>实现 lightgbm 在 scikir-learn 中的接口，详见分类和回归任务</p><p><strong>2. LGBMClassifier: LGBMModel 的子类，用于分类任务</strong></p><p><code>lightgbm.LGBMClassifier(boosting_type=&#39;gbdt&#39;, num_leaves=31, max_depth=-1, learning_rate=0.1, n_estimators=10, max_bin=255, ubsample_for_bin=200000, objective=None, min_split_gain=0.0, in_child_weight=0.001, min_child_samples=20, subsample=1.0, subsample_freq=1, colsample_bytree=1.0, reg_alpha=0.0, reg_lambda=0.0, random_state=None, n_jobs=-1, silent=True, **kwargs)</code></p><p><code>boosting_type</code>： 指定学习器的算法’gbdt, rf, dart, goss’<br><code>num_leaves</code>：一棵树上的叶子数<br><code>max_depth</code>：树模型的最大深度<br><code>learning_rate</code>：学习率<br><code>n_estimators</code>：提升树的数量<br><code>max_bin</code>： 每个特征的最大分支数量<br><code>class_weight</code>：给出了每个类别的权重占比<br><code>subsample_for_bin</code>：构建直方图的样本的数量 <em><br><code>objective</code>：问题类型以及对应的目标函数，对于 LGBMRegressor 为’regression’；对于 LGBMClassifier 为’binary’ 或者’multiclass’；对于 LGBMRanker 为’lambdarank’<br><code>min_split_gain</code>：执行切分的最小增益<br><code>min_child_weight</code>：一个叶子节点上的最小权重之和，默认为 1e-3<br><code>min_child_samples</code>： 一个叶子节点上包含的最少样本数量<br><code>subsample</code>： 表示训练样本的采样比例，取值范围为[0.0,1.0]。如果小于 1.0，则 lightgbm 会在每次迭代中随机选择部分样本来训练（非重复采样）<br><code>subsample_freq</code>：表示训练样本的采样频率<br><code>colsample_bytree</code>：表示特征的采样比例，取值范围为[0.0,1.0]。如果小于 1.0，则 lightgbm 会在每次迭代中随机选择部分特征<br><code>reg_alpha</code>：L1 正则化系数<br><code>reg_lambda</code>：L2 正则化系数<br><code>random_state</code>：随机数种子 </em><br><code>n_jobs</code>：并行线程数量<br><code>silent</code>：是否在训练过程中屏蔽输出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line">gbm = lgb.LGBMClassifier()</span><br><span class="line">gbm.n_features_：<span class="comment"># 给出了特征的数量</span></span><br><span class="line">gbm.classes_：<span class="comment"># 样本的标签</span></span><br><span class="line">gbm.n_classes_：<span class="comment"># 类别的数量</span></span><br><span class="line">gbm.best_score_：<span class="comment"># 训练完毕模型的最好的score</span></span><br><span class="line">gbm.best_iteration_：<span class="comment"># 训练完毕模型的最好的迭代数</span></span><br><span class="line">gbm.objective_：<span class="comment"># 训练模型的目标函数</span></span><br><span class="line">gbm.booster_：<span class="comment"># 底层的Booster 对象</span></span><br><span class="line">gbm.evals_result_：<span class="comment"># 模型评估结果</span></span><br><span class="line">gbm.feature_importances_： <span class="comment"># 特征的重要性</span></span><br></pre></td></tr></table></figure><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gbm.fit(X, y, sample_weight=<span class="keyword">None</span>, init_score=<span class="keyword">None</span>, eval_set=<span class="keyword">None</span>, eval_names=<span class="keyword">None</span>, eval_sample_weight=<span class="keyword">None</span>, eval_init_score=<span class="keyword">None</span>, eval_metric=<span class="string">'logloss'</span>, early_stopping_rounds=<span class="keyword">None</span>, verbose=<span class="keyword">True</span>, feature_name=<span class="string">'auto'</span>, categorical_feature=<span class="string">'auto'</span>, callbacks=<span class="keyword">None</span>)`</span><br><span class="line"><span class="comment"># sample_weight：每个训练样本的权重</span></span><br><span class="line"><span class="comment"># init_score：每个训练样本的初始分数</span></span><br><span class="line"><span class="comment"># group：每个训练样本的分组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eval_set：设置验证集</span></span><br><span class="line"><span class="comment"># eval_names：设置验证集的名字</span></span><br><span class="line"><span class="comment"># eval_sample_weight：验证集中每个样本的权重</span></span><br><span class="line"><span class="comment"># eval_init_score：每个验证集中，每个样本的init score</span></span><br><span class="line"><span class="comment"># eval_group：每个验证集中，每个样本的分组</span></span><br><span class="line"><span class="comment"># eval_metric：验证的方法</span></span><br><span class="line"></span><br><span class="line">gbm.predict(data, num_iteration=<span class="number">-1</span>, raw_score=<span class="keyword">False</span>, pred_leaf=<span class="keyword">False</span>, pred_contrib=<span class="keyword">False</span>, data_has_header=<span class="keyword">False</span>, is_reshape=<span class="keyword">True</span>, pred_parameter=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># num_iteration`：设置在预测时，使用多少个子树</span></span><br><span class="line"><span class="comment"># raw_score`：是否输出raw score</span></span><br><span class="line"><span class="comment"># pred_leaf： 输出每个样本在每个子树的哪个叶子上</span></span><br><span class="line"><span class="comment"># pred_contrib：输出每个特征对每个样本预测结果的贡献程度</span></span><br><span class="line"><span class="comment"># data_has_header：指示数据集是否含有标题</span></span><br><span class="line"><span class="comment"># is_reshape：是否reshape</span></span><br><span class="line"><span class="comment"># pred_parameter：给出其它的参数</span></span><br><span class="line"></span><br><span class="line">gbm.predict_proba(X, raw_score=<span class="keyword">False</span>, num_iteration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>LGBMRegressor 是 LGBMModel 的子类，它用于回归任务</li><li>LGBMRanker 是 LGBMModel 的子类，它用于排序任务，详见排序学习算法</li></ul><h3 id="绘图-API"><a href="#绘图-API" class="headerlink" title="绘图 API"></a>绘图 API</h3><h3 id="booster-API"><a href="#booster-API" class="headerlink" title="booster API"></a>booster API</h3><h3 id="LightGBM-示例"><a href="#LightGBM-示例" class="headerlink" title="LightGBM 示例"></a>LightGBM 示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> GridSearchCV  <span class="comment"># Perforing grid search</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">train_data = pd.read_csv(<span class="string">'train.csv'</span>)   <span class="comment"># 读取数据</span></span><br><span class="line">y = train_data.pop(<span class="string">'30'</span>).values   <span class="comment"># 用pop方式将训练数据中的标签值y取出来，作为训练目标，这里的‘30’是标签的列名</span></span><br><span class="line">col = train_data.columns</span><br><span class="line">x = train_data[col].values  <span class="comment"># 剩下的列作为训练数据</span></span><br><span class="line">train_x, valid_x, train_y, valid_y = train_test_split(x, y, test_size=<span class="number">0.333</span>, random_state=<span class="number">0</span>)   <span class="comment"># 分训练集和验证集</span></span><br><span class="line">train = lgb.Dataset(train_x, train_y)</span><br><span class="line">valid = lgb.Dataset(valid_x, valid_y, reference=train)</span><br><span class="line"></span><br><span class="line">parameters = &#123;</span><br><span class="line">              <span class="string">'max_depth'</span>: [<span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>],</span><br><span class="line">              <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.15</span>],</span><br><span class="line">              <span class="string">'feature_fraction'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>, <span class="number">0.95</span>],</span><br><span class="line">              <span class="string">'bagging_fraction'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>, <span class="number">0.95</span>],</span><br><span class="line">              <span class="string">'bagging_freq'</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>],</span><br><span class="line">              <span class="string">'reg_alpha'</span>: [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>],</span><br><span class="line">              <span class="string">'reg_lambda'</span>: [<span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">40</span>],</span><br><span class="line">              <span class="string">'cat_smooth'</span>: [<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">35</span>]</span><br><span class="line">&#125;</span><br><span class="line">gbm = lgb.LGBMClassifier(boosting_type=<span class="string">'gbdt'</span>,</span><br><span class="line">                         objective = <span class="string">'binary'</span>,</span><br><span class="line">                         metric = <span class="string">'auc'</span>,</span><br><span class="line">                         verbose = <span class="number">0</span>,</span><br><span class="line">                         learning_rate = <span class="number">0.01</span>,</span><br><span class="line">                         num_leaves = <span class="number">35</span>,</span><br><span class="line">                         feature_fraction=<span class="number">0.8</span>,</span><br><span class="line">                         bagging_fraction= <span class="number">0.9</span>,</span><br><span class="line">                         bagging_freq= <span class="number">8</span>,</span><br><span class="line">                         reg_alpha= <span class="number">0.6</span>,</span><br><span class="line">                         reg_lambda= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">gsearch = GridSearchCV(gbm, param_grid=parameters, scoring=<span class="string">'accuracy'</span>, cv=<span class="number">3</span>)</span><br><span class="line">gsearch.fit(train_x, train_y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Best score: %0.3f"</span> % gsearch.best_score_)</span><br><span class="line">print(<span class="string">"Best parameters set:"</span>)</span><br><span class="line">best_parameters = gsearch.best_estimator_.get_params()</span><br><span class="line"><span class="keyword">for</span> param_name <span class="keyword">in</span> sorted(parameters.keys()):</span><br><span class="line">    print(<span class="string">"\t%s: %r"</span> % (param_name, best_parameters[param_name]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://xgboost.ai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XgBoost&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/Microsoft/LightGBM&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LightGBM&lt;/a&gt; 官方文档阅读和算法学习&lt;br&gt;&lt;code&gt;*&lt;/code&gt;号为未解释完全，具体使用方法请参考官方文档&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="boosting" scheme="https://hyqskevin.github.io/tags/boosting/"/>
    
  </entry>
  
  <entry>
    <title>scikit-learn 文档学习笔记(1)</title>
    <link href="https://hyqskevin.github.io/2019/07/30/scikit-learn-note/"/>
    <id>https://hyqskevin.github.io/2019/07/30/scikit-learn-note/</id>
    <published>2019-07-30T01:31:47.000Z</published>
    <updated>2020-11-19T06:55:33.582Z</updated>
    
    <content type="html"><![CDATA[<p><strong>—loading …—</strong><br>scikit-learn 基于 Python 语言,建立在 NumPy ，SciPy 和 matplotlib 上,是简单高效的数据挖掘和数据分析工具<br>文章记录 scikit-learn API 的使用方法，包括监督学习、无监督学习，模型的选择和评估，数据集的加载和转换<br>学习笔记(1) 为监督学习的内容，解决回归和分类问题。包括线性回归，逻辑回归，梯度下降，最近邻，贝叶斯，决策树，支持向量机，集成方法，半监督学习等<br>API 只给出函数结构，参数具体使用参考<a href="https://scikit-learn.org/stable/user_guide.html" target="_blank" rel="noopener">scikit-learn 官方文档</a></p><a id="more"></a><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h3><p>目标值 y 是输入变量 x 的线性组合 $y(w,x) = w_0 +w_1x_1 + … + w_px_p$ 其中 w 为系数(coef) $w_0$ 为截距(intercept)。</p><p><strong>1. 普通最小二乘法 LinearRegression</strong><br>拟合一个带有系数 $w = (w_1, …, w_p)$ 的线性模型，使得数据集实际观测数据和预测数据（估计值）之间的残差平方和最小。<br>$\underset{w}{min\,} {|| X w - y||_2}^2$</p><p><code>sklearn.linear_model.LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=None)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">reg = LinearRegression().fit(X,y) <span class="comment"># 模型拟合</span></span><br><span class="line">reg.cof_  <span class="comment"># 得到系数矩阵</span></span><br><span class="line">reg.intercept_ <span class="comment"># 得到截距矩阵</span></span><br><span class="line">reg.score(X,y) <span class="comment"># 误差</span></span><br><span class="line">reg.predict(X) <span class="comment"># 预测</span></span><br></pre></td></tr></table></figure><p><strong>2. 岭回归 Ridge</strong><br>回归通过对系数的大小<strong>施加惩罚</strong>来解决普通最小二乘法的一些问题。 岭系数最小化的是带罚项的残差平方和。<br>$\underset{w}{min\,} {||X w - y||_2^2 + \alpha ||w||_2^2}$，其中$\alpha \geq 0$ 是控制系数收缩量的复杂性参数(超参数)</p><p><code>sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True, normalize=False, copy_X=True, max_iter=None, tol=0.001, solver=’auto’, random_state=None)</code></p><p>// alpha 可以设超参数大小<br>// tol 设置迭代最小边界<br>// solver : {‘auto’, ‘svd’, ‘cholesky’, ‘lsqr’, ‘sparse_cg’, ‘sag’, ‘saga’} 设置求解器，拟合数据时使用的算法</p><ul><li><code>sklearn.linear_model.RidgeCV( )</code> 内置对$\alpha$的交叉验证实现岭回归</li></ul><p><strong>3. 套索回归 Lasso</strong><br>用于拟合<strong>稀疏系数</strong>的线性模型，使用了 coordinate descent （坐标下降算法）来拟合系数，罚项 为 L1 范数。<br>$\underset{w}{min\,} { \frac{1}{2n_{samples}} ||X w - y||_2 ^ 2 + \alpha ||w||_1}$</p><p><code>sklearn.linear_model.Lasso(alpha=1.0, fit_intercept=True, normalize=False, precompute=False, copy_X=True, max_iter=1000, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’)</code></p><ul><li><code>sklearn.linear_model.LassoCV()</code> // 对超参数$\alpha$采用交叉验证</li><li><code>sklearn.linear_model.LassoLars()</code> // 采用的是最小角回归法，而不是坐标下降法进行优化</li><li><code>sklearn.linear_model.LassoLarsCV()</code> //同时采用不同的验证和优化方法</li><li><p><code>sklearn.linear_model.LassoLarsIC()</code> //对超参数$\alpha$采用 Akaike 信息准则(AIC)和贝叶斯信息准则(BIC),需要假设模型是正确的，对大样本（渐近结果）进行导出</p></li><li><p>LassoLarsCV 在寻找 $\alpha$ 参数值上更具有优势，而且如果样本数量比特征数量少得多时，通常 LassoLarsCV 比 LassoCV 要快</p></li></ul><p><strong>4. 弹性网络 ElasticNet</strong><br>Lasso 和 Ridge 结合，对普通的线性回归做了正则化，但是它的损失函数既不全是 L1 的正则化，也不全是 L2 的正则化，而是用一个权重参数 ρ 来平衡 L1 和 L2 正则化的比重<br>适合只有少量参数是非零稀疏的模型<br>$\underset{w}{min\,} { \frac{1}{2n_{samples}} ||X w - y||_2 ^ 2 + \alpha \rho ||w||_1 +\frac{\alpha(1-\rho)}{2} ||w||_2 ^ 2}$</p><p><code>sklearn.linear_model.ElasticNet(alpha=1.0, l1_ratio=0.5, fit_intercept=True, normalize=False, precompute=False, max_iter=1000, copy_X=True, tol=0.0001, warm_start=False, positive=False, random_state=None, selection=’cyclic’)</code></p><ul><li><code>ElasticNetCV()</code> 可以通过交叉验证来设置参数 $\alpha$ 和 $\rho$</li></ul><p><strong>5. Multitask 多任务</strong><br>可以实现多元回归稀疏模型的预测，即多个线性模型共同拟合<br>有<code>MultiTaskLasso()</code>,<code>MultiTaskLassoCV()</code>,<code>MultiTaskElasticNet()</code>,<code>MultiTaskElasticNetCV()</code></p><p><strong>6. 正交匹配追踪法（OMP）</strong><br><code>OrthogonalMatchingPursuit( )</code><br><code>OrthogonalMatchingPursuitCV( )</code></p><p><strong>7. 贝叶斯回归</strong></p><p><strong>8. 稳健回归</strong></p><p><strong>9. 多项式回归</strong></p><h3 id="logistic-线性分类模型"><a href="#logistic-线性分类模型" class="headerlink" title="logistic 线性分类模型"></a>logistic 线性分类模型</h3><p>解决分类问题的线性模型，将单次实验的结果输出为概率进行分类<br>$C \sum_{i=1}^n \log(\exp(- y_i (X_i^T w + c)) + 1) $<br>可以选择 L1，L2 或 Elastic-Net 正则化进行约束</p><p><code>sklearn.linear_model.LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=’warn’, max_iter=100, multi_class=’warn’, verbose=0, warm_start=False, n_jobs=None, l1_ratio=None)</code><br>// penalty 参数可以设置正则化参数<br>// C 用$1/{\lambda}$表示的正则化强度参数<br>// solver : str, {‘newton-cg’, ‘lbfgs’, ‘liblinear’, ‘sag’, ‘saga’} 选择优化算法，详细使用说明见官方文档<br>// class_weight 可以设置各类型的权重<br>// l1_ration 设置 Elastic-Net 中 ρ 控制正则化 L1 与正则化 L2 的强度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">reg = LogisticRegression().fit(X,y) <span class="comment"># 模型拟合</span></span><br><span class="line">reg.cof_  <span class="comment"># 得到系数矩阵</span></span><br><span class="line">reg.intercept_ <span class="comment"># 得到截距矩阵</span></span><br><span class="line">reg.score(X,y) <span class="comment"># 误差</span></span><br><span class="line">reg.predict(X) <span class="comment"># 得到预测的分类矩阵</span></span><br><span class="line">reg.predict_proba(X) <span class="comment"># 得到预测的概率</span></span><br></pre></td></tr></table></figure><ul><li><code>LogisticRegressionCV( )</code> 实现了内置交叉验证，可以找出最优的 C 和 l1_ratio 参数</li></ul><h3 id="SGD-随机梯度下降"><a href="#SGD-随机梯度下降" class="headerlink" title="SGD 随机梯度下降"></a>SGD 随机梯度下降</h3><p>可以拟合线性的回归和分类模型，在样本量很大时尤为有用，选择和函数时要避免过拟合。<br><code>SGDClassifier()</code> 和 <code>SGDRegressor()</code> 分别用于拟合分类问题和回归问题的线性模型，可使用不同的（凸）损失函数，支持不同的惩罚项。</p><h3 id="最近邻"><a href="#最近邻" class="headerlink" title="最近邻"></a>最近邻</h3><p>能够应用于决策边界非常不规则的分类情景</p><p>NearestNeighbors<br>BallTree<br>KDTree</p><p>最近邻分类属于<strong>基于实例的学习</strong>或<strong>非泛化学习</strong>：它不会去构造一个泛化的内部模型，而是简单地存储训练数据的实例。</p><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>决策树便于理解和解释，能够处理数值型数据和分类数据；但是容易产生一个过于复杂的模型，泛化性能会很差，结果不稳定，可以通过决策树的集成来得到缓解。如果某些类在问题中占主导地位会使得创建的决策树有偏差，建议在拟合前先对数据集进行平衡。</p><p>分类标准为最小化交叉熵（ID3），熵增益（C4.5）或基尼系数（Cart）</p><p><code>sklearn.tree.DecisionTreeClassifier(criterion=’gini’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, class_weight=None, presort=False)</code><br>// criterion 选择分类标准，可以使用”gini”或者”entropy”<br>// splitter 设置特征划分标准<br>// max_feature 划分的最大特征数<br>// max_depth 选择树的最大深度<br>// min_sample_split 设置最小样本分类<br>// min_sample_leaf 设置最小样本叶子数<br>// max_leaf_nodes 最大叶子节点数<br>// class_weight 设置类别权重<br>// presort 设置数据预排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">clf = DecisionTreeClassifier().fit(X,y)</span><br><span class="line">clf.n_class_ <span class="comment"># 分类数量</span></span><br><span class="line">clf.n_features_ <span class="comment"># 特征数量</span></span><br><span class="line">clf.n_outputs_ <span class="comment"># 输出数量</span></span><br><span class="line">clf.tree_ <span class="comment"># 得到分类树</span></span><br><span class="line">clf.get_depth() <span class="comment"># 得到分类深度</span></span><br><span class="line">clf.get_n_leaves() <span class="comment"># 得到叶子节点数</span></span><br><span class="line">clf.predict(X) <span class="comment"># 返回预测矩阵</span></span><br><span class="line">clf.predict_proba(X) <span class="comment"># 返回预测的概率</span></span><br><span class="line">clf.score(X,y) <span class="comment"># 返回训练分数</span></span><br></pre></td></tr></table></figure><ul><li><p>决策树回归模型 <code>sklearn.tree.DecisionTreeRegressor()</code> （不常用）</p></li><li><p>可以使用 export_graphviz 导出器以 Graphviz 格式导出决策树,结果保存为 pdf；Jupyter notebook 也可以自动内联式渲染这些绘制节点</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line">dot_data = tree.export_graphviz(clf, out_file=<span class="keyword">None</span>,\</span><br><span class="line">                    feature_names=iris.feature_names,\</span><br><span class="line">                    class_names=iris.target_names,  \</span><br><span class="line">                    filled=<span class="keyword">True</span>, rounded=<span class="keyword">True</span>,  \</span><br><span class="line">                    special_characters=<span class="keyword">True</span>)</span><br><span class="line">graph = graphviz.Source(dot_data)</span><br><span class="line">graph.render(<span class="string">"classification_result"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show in Jupyter</span></span><br><span class="line">graph</span><br></pre></td></tr></table></figure><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>可用于分类，回归和异常检测，在高维空间中非常高效，<br>SVC, NuSVC 和 LinearSV</p><p>内核岭回归<br>核函数</p><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p>GaussianNB<br>MultinomialNB<br>ComplementNB<br>BernoulliNB</p><h3 id="集成方法"><a href="#集成方法" class="headerlink" title="集成方法"></a>集成方法</h3><p><strong>1. Bagging</strong><br>在原始训练集的随机子集上构建一类黑盒估计器的多个实例，然后把这些估计器的预测结果结合起来形成最终的预测结果，在构建模型的过程中引入随机性，来减少基估计器的方差。</p><p><code>sklearn.ensemble.BaggingClassifier(base_estimator=None, n_estimators=10, max_samples=1.0, max_features=1.0, bootstrap=True, bootstrap_features=False, oob_score=False, warm_start=False, n_jobs=None, random_state=None, verbose=0)</code><br>// base_estimator 设置分类估计器，默认为决策树，可设置其它分类模型<br>// n_estimators 设置估计器的数量<br>// bootstrap 设置样例抽取是否放回<br>// bootstrap_features 设置特征抽取是否有放回<br>// oob_score 设置是否用额外的样本来评估泛化精度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line">clf = BaggingClassifier().fit(X,y)</span><br><span class="line">clf.predict(X)</span><br><span class="line">predict_proba(X)</span><br><span class="line">score(X, y)</span><br></pre></td></tr></table></figure><p><strong>2. 随机森林</strong><br>随机森林中的每棵树构建时的样本都是由训练集经过有放回抽样得到。在构建树的过程中进行结点分割时，选择的分割点不再是所有特征中最佳分割点，而是特征的一个随机子集中的最佳分割点，偏差通常会有略微的增大；但由于取了平均，总体上模型的泛化能力会更好。</p><p><code>sklearn.ensemble.RandomForestClassifier(n_estimators=’warn’, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False, class_weight=None)</code><br>// n_estimators 调整森林里树的数量<br>// max_features 分割节点时考虑的特征的随机子集的大小。使用 max_features = sqrt(n_features)是比较好的默认值<br>// max_depth = None 和 min_samples_split = 2 结合可以生成完全树</p><ul><li>极限随机树 <code>ExtraTreesClassifier()</code></li><li>完全随机树构成森林 <code>RandomTreesEmbedding()</code></li></ul><p><strong>2. 梯度提升回归树(GBRT)</strong><br>GBRT 保证迭代的每一个阶段中选择损失最小的决策树，达到全局的最小损失<br>$F<em>m(x) = F</em>{m-1}(x) + \arg\min<em>{h} \sum</em>{i=1}^{n} L(y<em>i,F</em>{m-1}(x_i) - h(x))$<br>GBRT 具有强大的预测能力和鲁棒性，但是扩展性不够好</p><p><code>GradientBoostingClassifier(loss=’deviance’, learning_rate=0.1, n_estimators=100, subsample=1.0, criterion=’friedman_mse’, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_depth=3, min_impurity_decrease=0.0, min_impurity_split=None, init=None, random_state=None, max_features=None, verbose=0, max_leaf_nodes=None, warm_start=False, presort=’auto’, validation_fraction=0.1, n_iter_no_change=None, tol=0.0001)</code><br>// loss 设置损失函数，默认为 deviance（$-log_2$ 似然损失函数）<br>// learning_rate 设置学习步长<br>// subsample 设置每次子训练集的采样，1 为全采样，一般可设置为 0.5</p><p><strong>3. AdaBoost</strong><br>通过反复修改数据权重来训练一些弱学习器，由这些弱学习器的预测结果通过加权投票(或加权求和)的方式组合, 得到最终的预测结果。<br>$F<em>m(x) = F</em>{m-1}(x) + \gamma<em>m \sum</em>{i=1}^{n} \nabla<em>F L(y_i, F</em>{m-1}(x<em>i))$<br>$\gamma_m$代表学习步长，通过计算损失最小的梯度下降$\gamma_m = \arg\min</em>{\gamma} \sum<em>{i=1}^{n} L(y_i, F</em>{m-1}(x<em>i) - \gamma \frac{\partial L(y_i, F</em>{m-1}(x<em>i))}{\partial F</em>{m-1}(x_i)})$得出</p><p>初始化时，将所有弱学习器的权重都设置为 $w_i = 1/N$ ,接下来的连续迭代中，样本的权重逐个地被修改。上一轮迭代中被预测为错误结果的样本的权重将会被增加，而那些被预测为正确结果的样本的权重将会被降低。通过不断得到最快梯度下降的权重来减小损失函数。</p><p><code>sklearn.ensemble.AdaBoostClassifier(base_estimator=None, n_estimators=50, learning_rate=1.0, algorithm=’SAMME.R’, random_state=None)</code><br>// base_estimator 设置弱学习器，默认 DecisionTreeClassifier(max_depth=1)<br>// n_estimator 设置最大集成数量<br>// learning_rate 设置学习速率</p><p><strong>4. 投票分类器</strong></p><hr><hr><ul><li>最小角回归（LARS）：逐步寻找与响应最有关联的预测。当有很多预测有相同的关联时，它并不会继续利用相同的预测，而是在这些预测中找出应该等角的方向。高效但对噪声敏感。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;—loading …—&lt;/strong&gt;&lt;br&gt;scikit-learn 基于 Python 语言,建立在 NumPy ，SciPy 和 matplotlib 上,是简单高效的数据挖掘和数据分析工具&lt;br&gt;文章记录 scikit-learn API 的使用方法，包括监督学习、无监督学习，模型的选择和评估，数据集的加载和转换&lt;br&gt;学习笔记(1) 为监督学习的内容，解决回归和分类问题。包括线性回归，逻辑回归，梯度下降，最近邻，贝叶斯，决策树，支持向量机，集成方法，半监督学习等&lt;br&gt;API 只给出函数结构，参数具体使用参考&lt;a href=&quot;https://scikit-learn.org/stable/user_guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scikit-learn 官方文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="repo" scheme="https://hyqskevin.github.io/categories/repo/"/>
    
    
      <category term="python" scheme="https://hyqskevin.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>科幻/奇幻书库（top100）</title>
    <link href="https://hyqskevin.github.io/2019/05/21/fantasy-top100/"/>
    <id>https://hyqskevin.github.io/2019/05/21/fantasy-top100/</id>
    <published>2019-05-21T02:00:20.000Z</published>
    <updated>2020-12-16T06:41:22.133Z</updated>
    
    <content type="html"><![CDATA[<p>个人书库，收集科幻类和奇幻类的书籍，不定期更新。</p><a id="more"></a><ul><li><p>[x] 1.《魔戒之王》（奇幻）——J.R.R. 托尔金</p><pre><code>所有奇幻文学的鼻祖，当然，赢得了我们最顶端的位置。除了全然独立创造了奇幻文学类型和影响了几代作家之外，托肯恩的传说讲述了一个宏大的故事。</code></pre><p>2.《Amber 历代志》（奇幻）——罗杰．泽拉兹内<br>Amber（琥珀）是惟一真实的世界。所有其他的世界，包括地球，只不过是幻像。柯文王子，Amber 王座合法的继承者，必须征服这些交错的真实，反抗恶魔的压迫，并且还要在他自己残酷的家族体系中存活下来去赢得王冠。</p><p>3.《安德的游戏》（奇幻）——奥森．斯科特．卡德<br>仅仅八岁，安德．威金斯就成为地球上最优秀的军事天才。面临着战争的现实，安德选择了离开军队而成为了一名“言灵者”、一名顾问、真理的搜寻者和在需要咨询的家族中做仲裁人。不幸地是，上天赋予了他另外的任务。</p><p>4.《神经漫游者》（科幻）——威廉．吉布森<br>一个耗尽了好运的黑客、同时也是一个做梦都想敛财的家伙发现了一名新生 AI 的秘密。网际庞克第一次被提出的著作，也是吉布森众多作品的第一部。</p><p>5.《异教徒汤玛斯．寇文能历代记》（奇幻）——史蒂芬．R.．唐纳森<br>一个真实世界的麻疯病人，汤玛斯．寇文能被传送到一个由污浊的、邪恶的力量包围的幻想世界。只有用他随身所携之“离奇魔术”签订的契约才能解救这个世界，但是他并不相信这个幻想世界的存在。</p></li><li><p>[x] 6.《基地》（科幻）——艾萨克．阿西莫夫</p><pre><code>陷入衰落的银河帝国和控制了杀伤性机械的科学家神秘社会的史诗故事。</code></pre><p>7.《沙丘》（科幻）——弗兰克．哈伯特<br>沙丘系列的第一部讲述了宇宙中最强大的灵媒，波尔．阿特雷兹的事迹，他在学习应对政治上的阴谋和沙漠行星阿拉吉斯环境上的荒凉的同时也在平衡着自己不断增长的力量。</p><p>8.《艾尔瑞克》（奇幻）——迈克尔．摩考克<br>一名白子战士/巫师在一次死亡竞赛中找到一柄吸魂剑而且在“秩序”和“混乱”之间的终极打击下拾起了它。</p><p>9.《高堡中的男人》（科幻）——菲利浦．k.．迪克<br>充满了偏执狂和复杂真实的游戏，这种“假如纳粹德国获胜”的剧情是曾经被写过的最非主流的历史。</p></li><li><p>[x] 10.《1984》（科幻）——乔治．奥维尔</p><pre><code>真诚的讲你会喜欢这本书的。它是一本你要独自看的书；没有其他人在身边。你会在每天晚餐后花上二个小时看这本书；“荧光屏”能确保这一点。老大哥会成为你的朋友。</code></pre><p>11.《休伯利安》（科幻）——丹．西蒙丝<br>伯劳鸟：一种用思想来停止时间的终极杀人机器。霸权/人工智能同盟：一个支配整个银河的帝国。驱逐者：经过万年进化、决心推翻霸权的猿人。将这些综合在一起你就会得到一场世界末日善恶的决战。</p><p>12.《星星，我的目的地》（科幻）——阿尔弗雷德．贝斯特<br>当格雷．福伊尔熬过了螺旋陷阱、发下报复的誓言时，他将自己改造成了一个有穿梭宇宙能力的全能的准超人。</p><p>13.《泰格纳》（奇幻）——盖伊．盖瑞尔．凯<br>为了报仇，一名强大的巫师将泰格纳王国从现实中清除了。但是一小群英雄依靠着他们故国的记忆，寻求将泰格纳再一次重现在它原来的地方。</p><p>14.《弗兰肯斯坦》（科幻）——玛莉．雪莱<br>一个疯狂科学家的创造物、一个用死人身体部分拼合的怪物和怪物争取世人承认他人类身份而进行抗争的经典故事。</p><p>15.《机器人会不会梦到电子羊？》（科幻）——菲利普．k.．迪克<br>一位银翼杀手警察被分配去追捕佯装成人的机器人而且在这一过程中寻究 “人类” 的定义。</p><p>16.《莎拉娜之剑》（奇幻）——泰瑞．布鲁克斯<br>“莎拉娜”系列的第一本将施．欧姆斯福德置于反对邪恶的法术士王和他的骷髅随从的争斗中。在通俗化的现代奇幻文学中这本书是很关键的。</p><p>17.《阿努比斯之门》（科幻）——提姆．鲍尔斯<br>一位现代学者实现了时间旅行，变更了身份、神气活现并且享受着 1810 年伦敦的魅力。如同查理斯．狄更斯遇到了印地安那．琼斯。</p><p>18.《电光》（科幻）——迪恩．库恩兹<br>一位来自过去的时间旅行者试图阻止纳粹德国对现在的改变。</p><p>19.《提升三部曲》（科幻）——大卫．布林<br>横跨银河的——包括有感觉力的海豚和黑猩猩——所有其它种族都通过基因改造或者 “提升”获得了智力并且要为他们的恩人献出他们的一生。人类却不是这样，他们把自己留在宇宙图腾的最底部，反对着科学高层者和时常怀有敌意的种族。</p><p>20.《环形世界》（科幻）——拉里．尼文<br>一支星际远征队迫降到一个直径 1.9 亿英里形如呼啦圈的人造行星上。幸存者必须与最初建设者留下的蛮族后代作战，方能穿越环形世界找到答案。</p><p>21.《时间机器》（科幻）——H.G.威尔斯<br>一个时间旅客在西元 802701 年目击了一场温顺又美丽的伊洛人和居住在地下无情的莫洛克人之间的战争。</p><p>22.《法夫哈德和老练的搜寻者》（奇幻）——弗瑞兹．雷伯<br>一个野蛮人和老练的小偷搭伴而行，笨手笨脚地历经了一些暗杀者公会、致命的巫师和诡计多端的神制造的意外。</p><p>23.《火星公主》（科幻）——艾德加．赖斯．伯洛夫斯<br>“约翰．卡特”系列的第一部，一个盟军士兵发现自己被传送到了火星，并在那里赢得了战士的荣誉。</p></li><li><p>[x] 24.《银河旅行者指南》（科幻）——道格拉斯．亚当斯</p><pre><code>这本书开创了一个由五本书组成的系列。亚瑟．登特仅仅在地球因银河高速公路而被摧毁之前被搭救。他和他的同伴福特．普瑞菲特偶会一个偏执的机器人、拜访了撒法人的世界并且勇敢地面对了沃根星球的威胁。</code></pre><p>25.《末日逼近》——斯蒂芬．金<br>一种病毒毁灭了世界上大部份人口。当仅有的一小群人挣扎着重建文明时，恶魔的力量威胁着美洲的幸存者们。</p><p>26.《亚瑟王和他的圆桌骑士》（奇幻）——汤姆斯．马罗礼爵士<br>亚瑟王故事的最可靠的选集——从兰斯洛特的背叛到莫德雷德的出生到影子骑士。</p></li><li><p>[x] 27.《我，机器人》（科幻）——艾萨克．阿西莫夫</p><pre><code>科幻小说中为智能机器人设定了标准的短篇故事。最著名的是设定出现在被公认的机器人三定律。</code></pre><p>28.《月亮是一个严厉的妇人》（科幻）——罗伯特．海因莱茵<br>月亮是成为一个被铁腕政权统治的严酷的殖民地。市民想获得自由，于是求助于一台有自我意识的计算机展开反抗计划。</p><p>29.《水洼》——理查德．亚当斯<br>完全从一只兔子的眼光来看待搜寻新的家园和为生存而竞争。一本独特的取材于《出埃及记》的圣经故事。</p><p>30.《华氏 451》（科幻）——雷．布雷德伯里<br>在盖伊．蒙太哥生活的世界里，消防员不用读书；他们焚烧书籍。盖伊喜欢他的工作。十年的消防员生涯，他从没问过隐藏在焚烧书籍背后或者它给他带来乐趣的原因……直到一个 17 岁的女孩告诉他，过去这里的人们并不惧怕阅读。</p></li><li><p>[x] 31.《霍比特人》（奇幻）——J.R.R. 托尔金</p><pre><code>霍比特矮人比尔博．巴金斯，巫师甘道夫和 13 个矮人着手到大孤山中探索并取回矮人的宝物。侏儒、小妖精、巨大的蜘蛛和罪恶的龙，Smaug，遍布他们的旅途中。</code></pre><p>32.《赫利康尼亚》（科幻）——布莱恩．奥尔迪斯<br>在一颗他们的一年相当于我们 3000 年并且冬天如同冰河纪的行星上，文明兴衰轮回。</p><p>33.《新日之书》（奇幻）——吉尼．渥尔夫<br>有多少个系列丛书以拷打者为主角呢？这本书中一名年轻的拷打者学徒毕业了，成为一个完全的刽子手，他朝着世界的统治者前进，成为人类的救星，当然，最终，不免一死。</p></li><li><p>[x] 34.《格利佛游记》（奇幻）——乔纳森．斯韦夫特</p><pre><code>一个船只遇难的生还者偶遇到除了在一系列政治讽刺小说中所拥有的事物以外，还有微型人、巨人和超智人、会说话的马人。</code></pre><p>35.《记忆杀手》（科幻）——斯比德．鲁滨逊<br>当你发现某个人能清除记忆时你会怎么做？记忆杀手——死亡杀手的第一部中篇小说 ── 追踪了两个人的旅程。他们被他们生命中难以抗拒的秘密所吸引，最终在一个谜一般的组织里会合，这个组织负责开发一种可以让人单纯的快乐而死的技术。这同时也是第一种洗脑的永久兴方法。主角们决定要阻止这个企业，尽管他们知道这个会送了他们的命。第一次读这本小说的时候，你会觉得它是本恐怖的神秘小说。第二次，你会发现它提供了丰富的人物描写，然后你会问：是什么使得人生值得一活？</p><p>36.《血里的音乐》（科幻）——格鲁格．贝尔<br>一个天才的研究员发明出生物芯片——智慧细胞——而且将它们注射到自己体内。它们像疾病一样扩散起来，带来了《启示录》般的结果。</p><p>37.《绿里》——斯蒂芬．金<br>令人毛骨悚然的死亡侵入囚犯中间，令他们仿佛面对电椅一般。</p><p>38.《夜访吸血鬼》（奇幻）——安妮．赖斯<br>将有关吸血鬼的哥德式的神秘带进现代旧金山的夜晚的小说。</p><p>39.《星际船伞兵》（科幻）——罗伯特．海因莱茵<br>一个未来的新兵通过了宇宙中的最残酷的海军新兵训练基地的锤炼——并且投入反抗人类最致命敌人的战争之中。忘掉电影去读书吧。</p></li><li><p>[x] 40.《纳尼亚年代记》（奇幻）——C.S.路易斯</p><pre><code>这个系列包含《狮子》、《巫婆》和《衣橱》，系列中最有名的一本，英格兰某地的四个孩子走进一个衣橱，里面浮现出一个有魔力的纳尼亚大陆，这个大陆上有半人半羊的农牧神和会说话的海狸，整个大陆处于由白魔女施下的永恒的冬天的规则和符咒之下。</code></pre><p>41.《启示录三部曲》——罗伯特．施和罗伯特．安顿．威尔逊<br>启示录系列的三本书只有部分是想像的著作。它们全面解决了我们这个时代中的谜团，从到底是谁射杀了肯尼迪到为什么一美元钞票上有金字塔。</p><p>42.《看守者》（科幻）——迪恩．库恩兹<br>基因实验创造出二只超智生物。一只是疯狂的邪恶生物，逃走了。另一个能阻止他的是他的“兄弟”——一只被命名为爱因斯坦的被驯养的狗。</p><p>43.《被毁的人》（科幻）——阿尔弗雷德．贝斯特<br>一个毛骨悚然的谋杀/悬疑故事，回答了这样一个问题，“在 24 世纪的精神感应流行的社会中该怎样定义谋杀？”</p><p>44.《埃姆菲瑞尔》——杰克．万斯<br>在行星哈默上，统治者将机械化和大生产视为违法，藉以限制工人的产量来使得他们贫穷潦倒。吉尔．塔沃克，一名雕刻师的儿子，为推翻传统体系和为工人阶级赢得公平待遇而工作。</p><p>45.《奥兹法师》（奇幻）——L.弗兰克．鲍姆<br>桃乐丝寻找回家路途时和她的朋友们游历了一个奇幻世界。这是奥兹系列的第一部，比那部经典电影包含多得多的内容，例如与丑陋的锤头的偶遇和铁皮人的由来。唉，然而没有飞天猴子。</p><p>46.《世界大战》（科幻）——H.G.威尔斯<br>经典的外星人入侵故事，有高度发达科技的火星征服者却带有巨大的致命弱点。</p><p>47.《传说中的森林》（奇幻）——罗伯特．霍德斯托克<br>凯尔特人和古英语的神话来源自富有生气的原始森林地带，那里会从人们无意识中产生活生生的“幽灵”。</p><p>48.《动物农场》（科幻）——乔治．奥威尔<br>暴动的农场家畜们逃离了它们的压迫者建立起一个家畜乌托邦。</p><p>49.《公主新娘》（奇幻）——威廉．高曼<br>一个活灵活现的浪漫又刺激的故事……加上非同寻常大小的老鼠。</p><p>50.《时光之轮》（奇幻）——罗伯特．乔丹<br>一个世代终结了，另一个世代又兴起。命运之网在每一个轮回里让那些古英雄们和反面角色得以重生，并由此展开一系列故事。在漫长的年代更迭中，黑暗之王被沙约尔．弗尔施法囚禁在他的山脉监狱中。他渴望逃脱，并且把所有从他手心逃掉的家伙全部杀掉，同时他的爪牙在大陆上暗中破坏、操纵并用其它方法促成他邪恶的愿望。一个农夫的孩子，安特．兰德．al\’Thor，对于他所在的小村庄外的事情一无所知。但是当一个神秘的女人到来使他看到了正在逼近的邪恶时，兰德和他的伙伴出发去寻求永久改变世界的办法。你知道，兰德是再生的龙，当时最强大的男法师。他拥有强大的力量可以举起整个城市、可以改写历史、可以挑战黑暗之王——但这种力量慢慢的使他发了疯。</p><p>51.《死光》——斯蒂芬．金<br>一支专门捕食虚弱的人、易受伤害的人、放荡的人的生物。一只成为你最可怕的梦魇的生物。</p><p>52.《发条橙》（科幻）——安东尼．伯吉斯<br>当 ultraviolent．亚历克斯被捕后，他接受了将他反社会的冲动置于人工控制的治疗。没有了自由的意志还能够是一个善良的人吗？</p><p>53.《时间柱》（科幻）——格雷戈里．本福德<br>不久的将来科学家将信息及时地送回 1962 年以拯救行星。</p><p>54.《波恩》（奇幻）——安妮．麦卡芙瑞<br>人类骑士与善良的、飞机大小的龙进行意识连接，去对抗所有贪婪的斯瑞德.赫尔。</p><p>55.《五号屠场》（科幻）——库尔特．冯内古特<br>战争的恐怖成为一个人在两种现实——从二战的德雷斯顿到囚禁在外星球 Tralfamadore——之间来回转换的体验。</p><p>56.《吉兆》——内尔．吉曼和泰瑞．普拉特切特<br>在这个奇异的、世界终结的喜剧中，哈米吉多顿（世界末日善恶决战的战场）出现了，然而天使和恶魔都没有准备好面对它。</p><p>57.《菲奥尼瓦》（奇幻）——盖伊．盖乌瑞尔．凯<br>一群现代学生被神秘地传送到一个处于危险之中的幻想世界。当一个恶毒的魔王从千年的监禁中释放出来时，学生们发现他们的命运与那些菲奥尼瓦纠缠在一起。</p><p>58.《地海法师》（奇幻）——厄休拉．K.．勒吉恩<br>一个名为盖德的男孩研究怎样成为男巫，并且最终被视为帮助重建了宇宙的平衡：光和暗、男人和女人、生存和死亡、法术和它的终极价值。</p></li><li><p>[x] 59.《2001》（科幻）——阿瑟 C.克拉克</p><pre><code>我们是如何得知我们是什么的？这个系列回答了一个人类基本的问题。它开始于我们的猿类祖先和对生存的竞争之间联系的确立。我们被其它行星的生命视为无可救药的虚弱和数量众多。一种外部的力量通过一块巨大的黑色“独块巨石”的方式播种下了真正智慧的种子。这些第一次概念上的想法开启了一系列使我们进入未来的事件。未来的开发中，我们的好奇心引导着我们在月球上发现了另外一个这样的盒子——它是一项铁证，证明了我们不是宇宙中惟一的指挥文明！这也是一项对于我们来说无法理解的发现，如同我们千百万年以来的生存问题一样。接着，人类不断地探寻，只是在木星附近发现了另一个盒子，它带给人类更多至为重要的事件。3001 年：最后的奥德赛，系列中提到过多次的问题——不管是凶是吉——得到了最终的回答。</code></pre><p>60.《异种生殖》——奥克塔维亚．巴特勒<br>外星人欧安卡利拯救了地球。作为代价，欧安卡利的幸存者需要稳定的基因的交换……而且我们是交配的原料。</p><p>61.《深渊之火》（科幻）——弗纳．维格<br>来自另一个宇宙的似神的人工智能体威胁着这个宇宙。一个群体拥有阻止它的知识，但他们被困在一颗灵长类动物的行星，那里没有空间航行或者联络的科技手段。</p><p>62.《柯南》（奇幻）——罗伯特．E.．霍华德<br>终极的野蛮英雄挫败了大量的邪恶法师，将大批恶毒的畸形怪物象垃圾一样清除，并且搭救了行星上每一位美丽的公主。然后他大吃起早餐。</p><p>63.《火星》（科幻）——金．斯坦利．罗宾逊<br>2026 年，一对百名探险家起程拓殖火星并将其地球化。不过，并不是每个人都想那样做。</p><p>64.《灵魂之井的午夜》——杰克．L.．查克<br>大部份的宇宙实际上由一个远古的死亡种族建造的并由一台庞大的计算机控制着。无论是谁控制了计算机都等于拥有了终极力量。</p><p>65.《变色龙的符咒》——皮尔斯．安东尼<br>在仙丝，每个人都有他们自己惟一的特殊魔术力量。不幸的是，布林克出生时却没有独特的法术，他怎么办？ 66.《缝隙》（科幻）——史蒂芬．R.．唐纳德森<br>来自遥远的禁断空间的边界，埃姆昵恩，一个倾向恐怖暴行的外星种族，需要某种人类无法形容的东西——而且他们会以某些无法想象的程度来得到它。</p><p>67.《亚瑟王法庭中的康涅狄格美国佬》（科幻）——马克．吐温<br>一个 19 世纪的男人被传送回圆桌会议发生地，在那里他通过介绍许多诸如铁路和电话等现代工具而被任命为亚瑟王的帮手。</p><p>68.《不锈钢鼠历险记》（科幻）——哈里．哈德森<br>吉姆．迪格兹是银河中最有才气的欺诈艺术家和小偷。当他最后被捕获时，执法者只有一个选择——让他成为他们中的一员——因为要用这只老鼠去捉另一只。</p><p>69.《火星编年史》（科幻）——雷．布雷德伯里<br>一本聚焦在人类在红色行星上以及与那些怪诞的原住民间偶遇的短篇故事集。它开始于第一次的接触和从那里的搬移。每个故事都贴上了布雷德伯里怪诞的标签。</p><p>70.《黑暗精灵》（奇幻）——R.A. 萨尔瓦多<br>游戏相关小说最好的系列之一，介绍了崔斯特．杜垩登，一个黑暗精灵，他一出生便拥有其他精灵所不具备的或不能提供的品质：同情心。他的家乡，地下城市魔索布莱城，是一个粗暴的地方，而且他的家族通过坚守城市的金箴规则：“不留活口”而取得了它的权力位置。当崔斯特成年时，魔索布莱城中越来越多的人开始讨厌他，而且他也无法做他的社会所需要的那些邪恶行为。最后，他惹恼他的家族，成为了母系社会中的一名男性，对他的处罚就是死亡。他没有选择只有逃到到地表世界，但那里不会善待黑暗精灵，因为他们有着嗜杀者的恶名。崔斯特寻求 “善行” 社会的接受和摆脱他的过去，这导致了许多次冒险和战斗。</p><p>71.《伊甸园之西》（科幻）——哈里．哈德森<br>地球被智能恐龙所统治；他们发现了美洲大陆，利用工具移民石器时代的人。于是血腥的战斗爆发了。</p><p>72.《美好的秘密所在》——彼得．S.．比戈<br>一个永恒的经典浪漫史，发生在两个必须通过打斗来记起曾经的生命和爱的鬼魂之间。</p></li><li><p>[x] 73.《海底两万里》（科幻）——儒勒．凡尔纳</p><pre><code>尼摩船长在大洋中的历险和为了他们的控制权而发生的战斗。凡尔纳的鹦鹉螺号早于真正的潜水艇。</code></pre><p>74.《内心垂死》——罗勃特．西尔弗伯格<br>一个老去的有精神感应的人开始失去控制他的精神力量。一次进入某个被赋予了不同寻常力量的男人思想内部的迷人旅程。</p><p>75.《龙枪》（奇幻）——玛格丽特．魏丝和崔西．西克曼<br>传说中的生物，龙，回来了——伴随着他们的是黑暗和破坏。只有一队探险者能够拯救世界……只要他们没有从内部被出卖。</p><p>76.《透镜人》（科幻）——E.E.．史密斯”博士”<br>经典的太空歌剧，讲述了男童子军般纯朴的英雄和无情的邪恶坏蛋为潮湿行星的“世界末日装置”的控制而战斗。</p><p>77.《坏东西这样来》——雷．布雷德伯里<br>也许这是曾经被写过的最精妙的惊骇故事。狂欢节允诺实现你最大的希望，但要为此承担最高的价格。 这本书中的情景会在你的余生里经常见到。</p><p>78.《上帝眼中的微尘》——拉里．尼文和杰瑞．波内尔<br>西元 3017 年是人类在宇宙的一个死水区域中发现智慧外星生物的一年；我们是应该迎接他们还是把他们炸成碎块？</p><p>79.《异乡异客》（科幻）——罗伯特．海因莱茵<br>陌生人是瓦伦丁．迈克尔．史密斯，陌生的土地是地球。史密斯出生于火星，是我们第一支去那里的远征队中惟一的人类幸存者。他被火星人养大，然后被 25 年后的第二支远征队所“搭救”。他认为自己是火星人并且使用看上去与他们没有什么不同的火星人能力——悬浮术。现在，向被狼在荒野中养大的孩子一样，他必须学会怎样做人……而且同时，教他的新朋友如何看待一个火星人。他发现了性和自由性爱的乐趣（这是 60 年代那一代人令这本书非常流行的部分原因），而且试着用他火星知识来调解地球宗教许多互相冲突的教义。读者不仅看到史密斯的成长，而且得知了一系列未来地球的情况和人类社会所有的弱点。</p><p>80.《空间三部曲》（科幻）——C.S.．路易斯<br>火星生命泛滥。水覆盖下的金星移居来一些漂浮的居住用的“岛屿”。如同地球上亚瑟王对抗整个英国的地方。</p><p>81.《隐身人》（科幻）——H.G. 威尔斯<br>一个科学家的心智和道德是他不可见的道德准则的价值。</p><p>82.《带特殊音乐的枪》（科幻）——乔纳森．莱塞姆<br>一个私家侦探在不远的、黑暗的未来侦破一件棘手的谋杀疑案，那时残留的人类和动物生活在一起，这些动物是类似枪袋鼠那样经过增强基因达到了接近人类的智力。近乎苛刻的黑暗色调，非常搞笑。</p><p>83.《里昂内斯》（奇幻）——杰克．万斯<br>超自然小说，充斥着仙子、巫婆和颠覆王国的阴谋——而这一切全部是在英吉利海峡下发生的。</p><p>84.《傀儡》（科幻）——琼．维格<br>计算机朋克，谋杀秘密和政治上的阴谋扭结在这一本书中，它讲述了一只猫的故事，一个心理意义上的半人，被强给他最憎恨的人做保镖。</p><p>85.《水晶快递》（科幻）——布鲁斯．斯特灵<br>人类最终为了空间抛弃了地球而且像哲学上那样把生物分为了两个集团。形态论者利用基因和生物工程技术改造了他们的身体去适应空间，而机械论者把信心放在制造高级人类使用的控制论增强器上。</p><p>86.《最后的独角兽》（奇幻）——彼得．S.．贝格尔<br>当一只独角兽收到其它已经消失的独角兽的音信时，她踏上了寻找她失踪的同伴的路途。她因一个草率的时代差点死去，而且她是惟一热爱人类比较久的独角兽。</p><p>87.《走向你们散落的身体》——弗利普．何塞．法默<br>任何人都曾经死去过——你、我、希特勒、马克．吐温——死在一个陌生的外星世界。“河上世界”系列的第一本书讲述了一个孤独的探索者试图解出奇异的“来世”的秘密。</p></li><li><p>[x] 88.《沉默的羔羊》——托马斯．哈里斯</p><pre><code>一名 FBI 侦探必须谋求一个嗜血成性的连环杀人犯的帮助来追捕到另一名连环杀人犯。</code></pre><p>89.《深潜站》——C.J. 切立夫<br>人类已经能够驾驶亚光速飞船探索几百光年外的宙域，这么长的距离足够在一些遥远的太阳系的两个轨道站之间建设贸易航线。深潜站处于航线的关键位置，也是通向地球防卫圈的门户。地球主管当局担心亚光速通信的间歇——有时会长达十年甚至更多——会给他们遥远的殖民地和暴发户商人的飞船带来太多的自由，但是当地球最终采取制裁措施时，一切已经太晚了：在遥远的赛汀上的科学家们已建造了第一艘超光速空间航行器，并且赛汀成为一个名为联邦的新生力量的中心。尽管深潜站已宣称自己中立，它还是夹在地球、联邦和商团武装之间，注定成为冲突的中心。</p><p>90.《献给埃基尔侬的花》（科幻）——丹尼尔．基斯<br>一个心理上弱智的小管理员接受了一项具有突破性意义的外科手术，使得其智商提高了三倍。他拥有了天才的头脑，但却只有孩童的情感。</p><p>91.《遥远地球之歌》（科幻）——阿瑟．C.．克拉克<br>人类了解到太阳正走向爆炸，于是在地球被毁灭之前将它的基因种子进入宇宙。这是带有合理可行的空间旅行方法的硬科幻小说。</p><p>92.《钻石的四大统治者》（科幻）——杰克．查克<br>一名间谍将他的思想复制到四个不同的身体之内，以便渗入到四个敌人的世界中并刺杀他们的统治者。</p><p>93.《剑》（奇幻）——弗瑞德．萨伯海根<br>神武坎制造了精美的刀剑，每一把都拥有特殊的无法阻挡的力量，并且能在未曾猜想到的世界里释放它们。一开始，人类就用这些剑杀死了神。随即，事态变得狂烈起来。</p><p>94.《中转站》（科幻）——克利福德．西马克<br>一个普通人被银河联邦雇用看守一个他们在地球上秘密安置的中转站。他能平衡对自己种族、对雇主的诚信并阻止一场核子战争吗？</p><p>95.《海怪苏醒》——约翰．怀海姆<br>一个不寻常的“海下入侵” 假设将产生“你疯了”想法的主角波尔和杰梅紧密联系在一起。</p><p>96.《雪崩》（科幻）——内尔．斯蒂芬森<br>第一本以网络人格和虚拟现实的初步暗示为特色的塞伯朋克小说。另外，你会喜欢上那个叫 Hiro Protagonist（日本名）的主人公，他是一名黑客、日本武士兼披萨饼快递员。</p><p>97.《满天飞翔的十字军》（科幻）——波尔．安德森<br>黑暗时代的骑士驾驶一艘宇宙飞船征服银河，一路上将外星人教化成基督徒。</p><p>98.《穿越镜面》（奇幻）——路易斯．卡罗尔<br>小说中讲述了爱丽丝在奇境里的故事，年轻的爱丽丝寻找归家之路，在这期间，探索了一块疯狂的、被施过魔法的大陆并且巧妙地躲过了试图伤害她的人。</p><p>99.《腐尸安慰者》（奇幻）——丹．西蒙斯<br>一个超自然吸血鬼的社会导致其他人的痛苦并和人类头脑斗智。</p><p>100.《邮差》（科幻）——大卫．布林<br>你曾看过一部电影关于一个人在美国邮递启示录过程中坚持自己的理念的故事。现在读一下这本书，它会更好些。</p></li></ul><hr><ul><li>黑暗物质三部曲</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人书库，收集科幻类和奇幻类的书籍，不定期更新。&lt;/p&gt;
    
    </summary>
    
      <category term="repo" scheme="https://hyqskevin.github.io/categories/repo/"/>
    
    
      <category term="book" scheme="https://hyqskevin.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>Flask Web 学习笔记2 -- URL与视图函数映射</title>
    <link href="https://hyqskevin.github.io/2019/04/11/flask-learning2/"/>
    <id>https://hyqskevin.github.io/2019/04/11/flask-learning2/</id>
    <published>2019-04-11T08:28:44.000Z</published>
    <updated>2020-11-19T06:55:57.968Z</updated>
    
    <content type="html"><![CDATA[<p>-学习笔记-<br>通过 URL 传递参数，接收参数，利用试图函数实现参数到 URL 转换，自定义 URL 转换</p><a id="more"></a><p>URL 是 Uniform Resource Locator 的简写，统一资源定位符。<br>一个 URL 由以下几部分组成：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">scheme://host:port/path/?query-string=xxx#anchor</span><br></pre></td></tr></table></figure><ul><li>scheme：代表的是访问的协议，一般为 http 或者 https 以及 ftp 等。</li><li>host：主机名，域名，比如www.baidu.com。</li><li>port：端口号。当你访问一个网站的时候，浏览器默认使用 80 端口。</li><li>path：查找路径。比如：www.jianshu.com/trending/now，后面的trending/now就是path。</li><li>query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。</li><li>anchor：锚点，后台一般不用管，前端用来做页面定位的。</li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>传递参数的语法是：<code>/&lt;参数名&gt;/</code>。然后在视图函数中，也要定义同名的参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="meta">@app.route('/list/')</span></span><br><span class="line"><span class="meta">@app.route('/p/&lt;float:article_id&gt;')</span></span><br><span class="line"><span class="meta">@app.route('/u/&lt;uuid:user_id&gt;/')</span></span><br><span class="line"><span class="meta">@app.route('/&lt;any(blog,article):url_path&gt;/&lt;id&gt;/')</span></span><br></pre></td></tr></table></figure><p>参数的数据类型</p><ol><li>如果没有指定具体的数据类型，那么默认就是使用<code>string</code>数据类型。</li><li><code>int</code>数据类型只能传递<code>int</code>类型。</li><li><code>float</code>数据类型只能传递<code>float</code>类型。</li><li><code>path</code>数据类型和<code>string</code>有点类似，都是可以接收任意的字符串，但是<code>path</code>可以接收路径，也就是说可以包含斜杠。</li><li><code>uuid</code>数据类型只能接收符合<code>uuid</code>的字符串。<code>uuid</code>是一个全宇宙都唯一的字符串，一般可以用来作为表的主键。</li><li><code>any</code>数据类型可以在一个<code>url</code>中指定多个路径。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/&lt;any(blog,article):url_path&gt;/&lt;id&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(url_path,id)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> url_path == <span class="string">'blog'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'博客详情：%s'</span> % id</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'博客详情：%s'</span> % id</span><br></pre></td></tr></table></figure><h3 id="接收用户传递的参数"><a href="#接收用户传递的参数" class="headerlink" title="接收用户传递的参数"></a>接收用户传递的参数</h3><ol><li>第一种：使用<code>path</code>的形式（将参数嵌入到路径中），就是上面讲的。</li><li>第二种：使用查询字符串的方式，就是通过<code>?key=value</code>的形式传递的。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/d/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">()</span>:</span></span><br><span class="line">    wd = request.args.get(<span class="string">'wd'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'参数是：%s'</span> % wd</span><br></pre></td></tr></table></figure><h3 id="URL-转换器"><a href="#URL-转换器" class="headerlink" title="URL 转换器"></a>URL 转换器</h3><p><code>url_for</code>将<strong>视图函数</strong>名字后面的参数传递给<code>url</code>。<br>如果传递的参数之前在<code>url</code>中已经定义了，那么这个参数就会被当成<code>path</code>的形式给<code>url</code>。如果这个参数之前没有在<code>url</code>中定义，那么将变成查询字符串的形式放到<code>url</code>中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,request</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/list/&lt;page&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_list</span><span class="params">(page)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'my list'</span></span><br><span class="line"></span><br><span class="line">print(url_for(<span class="string">'my_list'</span>,page=<span class="number">1</span>,count=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># page作为path，count作为查询字符串</span></span><br><span class="line"><span class="comment"># 构建出来的url：/my_list/1/?count=2</span></span><br></pre></td></tr></table></figure><ul><li>url_for 优势</li></ul><ol><li>将来如果修改了<code>URL</code>，但没有修改该 URL 对应的函数名，就不用到处去替换 URL 了</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/post/list/&lt;page&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_list</span><span class="params">(page)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'my list'</span></span><br><span class="line">url = url_for(<span class="string">'my_list'</span>，page=<span class="number">1</span>,count=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 原来的url：/my_list/1/?count=2</span></span><br><span class="line"><span class="comment"># 新构建出来的url：/post/my_list/1/?count=2</span></span><br></pre></td></tr></table></figure><ol><li>url_for 会自动的处理那些特殊的字符，不需要手动去处理。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/login/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'login'</span></span><br><span class="line"></span><br><span class="line">url = url_for(<span class="string">'login'</span>,next=<span class="string">'/'</span>)</span><br><span class="line"><span class="comment"># 会自动的将`/`编码，不需要手动去处理。</span></span><br><span class="line"><span class="comment"># url=/login/?next=%2F</span></span><br></pre></td></tr></table></figure><h3 id="自定义-URL-转换器"><a href="#自定义-URL-转换器" class="headerlink" title="自定义 URL 转换器"></a>自定义 URL 转换器</h3><p>URL 参数的数据类型通过<code>routing.py</code>中的<code>Unicode/Float/Any/Path/Number Converter</code>等类指定，使用了默认转换器</p><p>可以自定义类型 URL 转换器和运算符 URL 转换器</p><ul><li>自定义方法</li></ul><ol><li>实现一个类，继承自<code>BaseConverter</code>。</li><li>在自定义的类中，重写<code>regex</code>，也就是这个变量的正则表达式。</li><li>将自定义的类，映射到<code>app.url_map.converters</code>上。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for</span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> BaseConverter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义手机号码的变量URL转换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneConveter</span><span class="params">(BaseConverter)</span>:</span></span><br><span class="line">  regex = <span class="string">r'1[85734]\d'</span></span><br><span class="line">app.url_map.converters[<span class="string">'tel'</span>] = TelephoneConverter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的数据类型</span></span><br><span class="line"><span class="meta">@app.route('/telephone/&lt;tel:my_tel&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_tel</span><span class="params">(my_tel)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'您的手机号码是：%s'</span> % my_tel</span><br><span class="line"></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义+号运算符解析</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpratorConverter</span><span class="params">(BaseConverter)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 这个方法的返回值，将会传递到view函数中作为参数</span></span><br><span class="line">    <span class="keyword">return</span> value.split(<span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 在调用url_for函数的时候生成符合要求的URL形式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"+"</span>.join(value)</span><br><span class="line">    <span class="comment"># return "hello"</span></span><br><span class="line">app.url_map.converters[<span class="string">'oprator+'</span>] = OpratorConverter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义+</span></span><br><span class="line"><span class="meta">@app.route('/posts/&lt;oprator+:boards&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">posts</span><span class="params">(boards)</span>:</span></span><br><span class="line">    print(boards)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"您提交的板块是：%s"</span> % boards</span><br></pre></td></tr></table></figure><h3 id="URL-重定向"><a href="#URL-重定向" class="headerlink" title="URL 重定向"></a>URL 重定向</h3><p>重定向在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面。比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面。</p><ol><li>永久性重定向：<code>http</code>的状态码是<code>301</code>，多用于旧网址被废弃了要转到一个新的网址确保用户的访问。</li><li>暂时性重定向：<code>http</code>的状态码是<code>302</code>，表示页面的暂时性跳转。比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面，这种情况下，应该用暂时性重定向。</li></ol><p><code>flask</code>中有一个函数叫做<code>redirect</code>，可以重定向到指定的页面。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request,redirect,url_for</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/login/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'这是登录页面'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/profile/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">'name'</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'个人中心页面'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># redirect 重定向</span></span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'login'</span>))</span><br></pre></td></tr></table></figure><h3 id="视图函数的响应"><a href="#视图函数的响应" class="headerlink" title="视图函数的响应"></a>视图函数的响应</h3><ol><li>可以返回字符串：flask 会创建 werkzeug、wrappers、Response 对象，状态码 200，MIME 类型<code>test/html</code>，然后返回 Response 对象</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Response</span><br><span class="line">...</span><br><span class="line"><span class="meta">@app.route('/list/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">()</span>:</span></span><br><span class="line">    Response(<span class="string">'Hello World!'</span>)</span><br><span class="line"><span class="comment"># Response('Hello World!',status=200,mimetype='text/html')</span></span><br></pre></td></tr></table></figure><p>还可以通过 make_response 进行创建</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">form flask <span class="keyword">import</span> make_response</span><br><span class="line"><span class="meta">@app.route('/list/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> make_response(<span class="string">'list page.'</span>)</span><br></pre></td></tr></table></figure><ol><li>可以返回元组：元组的形式是(Response,Status,header)<br>不一定三个都要写，写两个也是可以的，status 返回 200，header 为列表或字典。返回的元组，其实在底层也是包装成了一个<code>Response</code>对象。<br><code>return &#39;list&#39;,200,{&#39;NAME&#39;:&#39;kevin&#39;}</code></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.errorheader(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_found</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'not found'</span>,<span class="number">404</span></span><br></pre></td></tr></table></figure><ol><li>直接返回合法的响应对象</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp = Response(<span class="string">'list'</span>)</span><br><span class="line">resp.set_cookie(<span class="string">'country'</span>,<span class="string">'china'</span>)</span><br><span class="line"><span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><ol><li>以上条件不满足，则进行自定义响应</li></ol><p>继承自<code>Response</code>类。<br>实现方法<code>force_type(cls,response,environ=None)</code>。<br>指定<code>app.response_class</code>为你自定义的<code>Response</code>对象。<br>如果视图函数返回的数据，不是字符串，也不是元组，也不是 Response 对象，那么就会将返回值传给<code>force_type</code>，然后再将<code>force_type</code>的返回值返回给前端。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myResponse</span><span class="params">(Response)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">force_type</span><span class="params">(cls, response, environ=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'return error.'</span>)</span><br><span class="line"></span><br><span class="line">app.response_class = myResponse</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用jsonify将返回的格式转换成json格式</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myResponse</span><span class="params">(Response)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">force_type</span><span class="params">(cls, response, environ=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(response,dict):</span><br><span class="line">        <span class="comment"># jsonify除了将字典转换成json对象，还将改对象包装成了一个Response对象</span></span><br><span class="line">        response = jsonify(response)</span><br><span class="line">    <span class="comment"># 调用父类</span></span><br><span class="line">    <span class="keyword">return</span> super(myResponse, cls).force_type(response, environ)</span><br><span class="line"></span><br><span class="line">app.response_class = myResponse</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-学习笔记-&lt;br&gt;通过 URL 传递参数，接收参数，利用试图函数实现参数到 URL 转换，自定义 URL 转换&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="flask" scheme="https://hyqskevin.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>c++中的智能指针</title>
    <link href="https://hyqskevin.github.io/2019/04/05/ptr/"/>
    <id>https://hyqskevin.github.io/2019/04/05/ptr/</id>
    <published>2019-04-05T11:33:58.000Z</published>
    <updated>2020-11-19T06:55:34.623Z</updated>
    
    <content type="html"><![CDATA[<p>由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，用智能指针便可以有效缓解这类问题。</p><p>对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。</p><a id="more"></a><p>访问智能指针包含的裸指针则可以用 get() 函数</p><p>智能指针包含了 reset() 方法，如果不传递参数（或者传递 NULL），则智能指针会释放当前管理的内存。如果传递一个对象，则智能指针会释放当前对象，来管理新传入的对象。</p><ul><li>编写测试类来辅助分析</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Simple(<span class="keyword">int</span> param = <span class="number">0</span>) &#123;</span><br><span class="line">    number = param;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  ~Simple() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Simple: "</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrintSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PrintSomething: "</span> &lt;&lt; info_extend.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> info_extend;</span><br><span class="line">  <span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h2><p>包含头文件 <code>#include&lt;memory&gt;</code> 便可以使用<br><code>std::auto_ptr</code> 能够方便的管理单个堆内存对象</p><p>用法一：<br><code>std::auto_ptr&lt;MyClass&gt;m_example(new MyClass());</code></p><p>用法二：<br><code>std::auto_ptr&lt;MyClass&gt;m_example;</code><br><code>m_example.reset(new MyClass());</code></p><p>用法三（指针的赋值操作）：<br><code>std::auto_ptr&lt;MyClass&gt;m_example1(new MyClass());</code><br><code>std::auto_ptr&lt;MyClass&gt;m_example2(new MyClass());</code><br><code>m_example2=m_example1;</code></p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));   <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;             <span class="comment">// 判断智能指针是否为空</span></span><br><span class="line">    my_memory-&gt;PrintSomething();  <span class="comment">// 使用 operator-&gt; 调用智能指针对象中的函数</span></span><br><span class="line">    my_memory.get()-&gt;info_extend = <span class="string">"Addition"</span>; <span class="comment">// 使用 get() 返回裸指针，然后给内部对象赋值</span></span><br><span class="line">    my_memory-&gt;PrintSomething();               <span class="comment">// 再次打印，表明上述赋值成功</span></span><br><span class="line">    (*my_memory).info_extend += <span class="string">" other"</span>;      <span class="comment">// 使用 operator 返回智能指针内部对象，然后用“.”调用智能指针对象中的函数</span></span><br><span class="line">    my_memory-&gt;PrintSomething();               <span class="comment">// 再次打印，表明上述赋值成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;                          <span class="comment">// my_memory 栈对象即将结束生命期，析构堆对象 Simple(1)</span></span><br></pre></td></tr></table></figure><ul><li>执行结果为：<br>Simple: 1<br>PrintSomething:<br>PrintSomething: Addition<br>PrintSomething: Addition other<br>~Simple: 1</li></ul><h3 id="不能使用-操作符"><a href="#不能使用-操作符" class="headerlink" title="不能使用 = 操作符"></a>不能使用 = 操作符</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory2;   <span class="comment">// 创建一个新的 my_memory2 对象</span></span><br><span class="line">    my_memory2 = my_memory;             <span class="comment">// 复制旧的 my_memory 给 my_memory2</span></span><br><span class="line">    my_memory2-&gt;PrintSomething();       <span class="comment">// 输出信息，复制成功</span></span><br><span class="line">    my_memory-&gt;PrintSomething();        <span class="comment">// 崩溃</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>my_memory2 = my_memory</code>这行代码，my_memory2 完全夺取了 my_memory 的内存管理所有权，导致 my_memory 悬空，最后使用时导致崩溃。</p><h3 id="release-函数问题"><a href="#release-函数问题" class="headerlink" title="release() 函数问题"></a>release() 函数问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    my_memory.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                          <span class="comment">//最终执行结果为 Simple：1，没有被析构，导致内存泄露</span></span><br></pre></td></tr></table></figure><p>调用 release() 函数释放内存，不会释放对象，仅仅归还所有权，要自己 delete 或使用 reset()函数销毁对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码修正</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAutoPtr3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Simple&gt; my_memory(<span class="keyword">new</span> Simple(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (my_memory.get()) &#123;</span><br><span class="line">    Simple* temp_memory = my_memory.release();</span><br><span class="line">    <span class="keyword">delete</span> temp_memory;</span><br><span class="line">    <span class="comment">// 或者直接 my_memory.reset();  释放 my_memory 内部管理的内存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项<br>使用 std::auto_ptr 时，<strong>绝对不能使用“operator=”操作符</strong>，这会夺取内存管理所有权<br>std::auto_ptr 的 release() 函数不会释放对象，仅仅归还所有权。<br>std::auto_ptr 最好不要当成参数传递（读者可以自行写代码确定为什么不能）。<br>std::auto_ptr 的“operator=”问题，有其管理的对象不能放入 std::vector 等容器中。<br>C++11 中，std::auto_ptr 已经被弃用</li></ul><hr><p>自 C++11 起，C++标准提供两大类型的智能指针：shared_ptr 和 unique_ptr</p><hr><h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>shared_ptr 实现共享式拥有（shared ownership）概念。<strong>多个智能指针可以指向相同对象</strong>，该对象和其相关资源会在“最后一个引用（reference）被销毁”时候释放。为了在结构复杂的情境中执行上述工作，标准库提供了 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</p><p>shared_ptr 本身提供默认内存释放器（default deleter），调用的是 delete，也可以自定义释放器</p><p>默认内存释放器并<strong>不能释放数组内存空间</strong>，要我们自己提供内存释放器</p><ul><li><p>成员函数<br>use_count 返回引用计数的个数<br>unique 返回是否是独占所有权( use_count 为 1)<br>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少<br>get 返回内部对象(指针)</p></li><li><p>示例</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp0(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp0);               <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp1);               <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp2);               <span class="comment">// 11</span></span><br><span class="line">sp1.swap(sp0);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp0);               <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp1);               <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp2);               <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp3(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">22</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp4 = sp3;     <span class="comment">// 或 auto sp4 = sp3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp3);               <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *sp4);               <span class="comment">// 22</span></span><br><span class="line">sp3.reset();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp3.use_count());    <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp4.use_count());    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sp3);                <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li>注意事项<br>shared_ptr 会因循环引用造成无法释放资源<br>与 weak_ptr 一起工作时, weak_ptr 在使用前需要检查合法性<br>shared_ptr 不支持数组, 如果使用数组, 需要自定义删除器</li></ul><h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</p><p>weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象. 注意, weak_ptr 在使用前需要检查合法性。</p><p>weak_ptr 支持拷贝或赋值, 但不会影响对应的 shared_ptr 内部对象的计数。</p><ul><li><p>成员函数<br>expired 用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false<br>lock 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同。<br>use_count 返回与 shared_ptr 共享的对象的引用计数.<br>reset 将 weak_ptr 置空.</p></li><li><p>使用 weak_ptr 解决 shared_ptr 因循环不能释放资源的问题<br>使用 shared_ptr 时, shared_ptr 为强引用, 如果存在循环引用, 将导致内存泄露. 而 weak_ptr 为弱引用, 可以避免此问题</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CA()&#123;&#125;</span><br><span class="line">    ~CA()&#123;PRINT_FUN();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;CB&gt; m_spb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CB()&#123;&#125;;</span><br><span class="line">    ~CB()&#123;PRINT_FUN();&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CA&gt; m_spa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CA&gt; spa(<span class="keyword">new</span> CA);  <span class="comment">// 通过调用weak_ptr，释放CA内存时不影响CB</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CB&gt; spb(<span class="keyword">new</span> CB);</span><br></pre></td></tr></table></figure><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（resourece leak）——例如“以 new 创建对象后因为发生异常而忘记调用 delete”——特别有用。</p><p>unique_ptr 不支持拷贝和赋值，但是可以调用 release 或 reset 将指针的所有权从一个(非 const) unique_ptr 转移到另一个<br><code>std::unique_ptr&lt;A&gt; up1(new A(5));</code><br><code>std::unique_ptr&lt;A&gt; up2(up1);</code> // 错误, unique_ptr 不支持拷贝<br><code>std::unique_ptr&lt;A&gt; up2 = up1;</code> // 错误, unique_ptr 不支持赋值<br><code>std::unique_ptr&lt;int&gt; up2(up1.release());</code> // 正确</p><p>unique_ptr 不支持拷贝, 但是可以从函数中返回, 甚至返回局部对象</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt; Clone(<span class="keyword">const</span> Ty&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">　<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt; temp = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Ty&gt;(<span class="keyword">new</span> Ty(obj));</span><br><span class="line">　<span class="keyword">return</span> temp;</span><br><span class="line">  <span class="comment">// 或直接 return std::unique_ptr&lt;Ty&gt;(new Ty(obj))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique_ptr 支持管理数组</p><ul><li><p>成员函数<br>get 获得内部对象的指针<br>release 放弃内部对象的所有权，将内部指针置为空, 返回所内部对象的指针, 此指针需要手动释放<br>reset 销毁内部对象并接受新的对象的所有权(如果使用缺省参数的话，也就是没有任何对象的所有权, 此时仅将内部对象释放, 并置为空)<br>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br>std::move(name) 所有权转移(通过移动语义), 所有权转移后，变成“空指针”</p></li><li><p>防内存泄漏代码改进</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// 内存泄露</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">// ptr成空悬指针</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">delete</span> ptr;  <span class="comment">// 释放内存</span></span><br><span class="line">  ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 unique_ptr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="boost-scoped-ptr"><a href="#boost-scoped-ptr" class="headerlink" title="boost::scoped_ptr"></a>boost::scoped_ptr</h2><h2 id="boost-shared-ptr"><a href="#boost-shared-ptr" class="headerlink" title="boost::shared_ptr"></a>boost::shared_ptr</h2><h2 id="boost-scoped-array"><a href="#boost-scoped-array" class="headerlink" title="boost::scoped_array"></a>boost::scoped_array</h2><h2 id="boost-shared-array"><a href="#boost-shared-array" class="headerlink" title="boost::shared_array"></a>boost::shared_array</h2><h2 id="boost-weak-ptr"><a href="#boost-weak-ptr" class="headerlink" title="boost::weak_ptr"></a>boost::weak_ptr</h2><h2 id="boost-intrusive-ptr"><a href="#boost-intrusive-ptr" class="headerlink" title="boost:: intrusive_ptr"></a>boost:: intrusive_ptr</h2><p>参考资料：<br><a href="https://blog.csdn.net/xt_xiaotian/article/details/5714477" target="_blank" rel="noopener">https://blog.csdn.net/xt_xiaotian/article/details/5714477</a><br><a href="https://www.cnblogs.com/xiehongfeng100/p/4645555.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiehongfeng100/p/4645555.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930361.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930361.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930372.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930372.html</a><br><a href="https://www.cnblogs.com/diysoul/p/5930388.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5930388.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete，用智能指针便可以有效缓解这类问题。&lt;/p&gt;
&lt;p&gt;对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&amp;gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="c++" scheme="https://hyqskevin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Flask Web 学习笔记1 -- 环境</title>
    <link href="https://hyqskevin.github.io/2019/03/31/flask-learning1/"/>
    <id>https://hyqskevin.github.io/2019/03/31/flask-learning1/</id>
    <published>2019-03-31T08:25:28.000Z</published>
    <updated>2020-11-19T06:55:57.056Z</updated>
    
    <content type="html"><![CDATA[<p>-学习笔记-<br>flask 前期准备，在目录下建立 flask 虚拟环境，开启调试模式和书写配置文档</p><a id="more"></a><p>flask = werkzeug(web 服务)+sqlalchemy(数据库)+jinja2(框架模板)</p><h2 id="flask-运行环境"><a href="#flask-运行环境" class="headerlink" title="flask 运行环境"></a>flask 运行环境</h2><p><code>pip install pipenv</code><br>使用 <code>pipenv</code> 隔离虚拟环境，防止不同项目环境冲突</p><p>命令行切换到目标目录下<br><code>pipenv shell</code> 进入虚拟环境<br><code>pipenv install flask</code> 安装 flask<br><code>pipenv graph</code> 打印所有依赖<br><code>exit</code> 退出虚拟环境</p><p><a href="github.com/pypa/pipenv">pipenv doc</a></p><p>python 必须重启服务器才生效</p><ul><li>默认模板</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从flask这个包中导入Flask这个类</span></span><br><span class="line"><span class="comment"># Flask这个类是项目的核心，以后很多操作都是基于这个类的对象</span></span><br><span class="line"><span class="comment"># 注册url、注册蓝图等都是基于这个类的对象</span></span><br><span class="line">__author__ = <span class="string">'kevin'</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Flask对象，传递__name__参数进去</span></span><br><span class="line"><span class="comment"># __name__参数的作用：</span></span><br><span class="line"><span class="comment"># 1. 可以规定模版和静态文件的查找路径</span></span><br><span class="line"><span class="comment"># 2. 以后一些Flask插件，比如Flask-migrate、Flask-SQLAlchemy如果报错了，那么Flask可以通过这个参数找到具体的错误位置</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.route：是一个装饰器</span></span><br><span class="line"><span class="comment"># @app.route('/')就是将url中的/映射到hello_world这个视图函数上面</span></span><br><span class="line"><span class="comment"># 以后你访问我这个网站的/目录的时候，会执行hello_world这个函数，然后将这个函数的返回值返回给浏览器。</span></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello,World.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果这个文件是作为一个主文件运行，那么就执行app.run()方法，遍历运行</span></span><br><span class="line"><span class="comment"># 只在开发时使用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'127.0.0.1'</span>,port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><h3 id="debug-模式"><a href="#debug-模式" class="headerlink" title="debug 模式"></a>debug 模式</h3><p>开启了 DEBUG 模式，那么在代码中如果抛出了异常，在浏览器的页面中可以看到具体的错误信息，以及具体的错误代码位置。方便开发者调试。</p><p>如果开启了 DEBUG 模式，那么以后在<code>Python</code>代码中修改了任何代码，只要按<code>ctrl+s</code>，<code>flask</code>就会自动的重新记载整个网站。不需要手动点击重新运行。</p><ol><li>在<code>app.run()</code>中传递一个参数<code>debug=True</code>就可以开启<code>DEBUG</code>模式</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><ol><li>给<code>app.deubg=True</code>也可以开启<code>debug</code>模式。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><ol><li>通过配置参数的形式设置 DEBUG 模式：<code>app.config.update(DEBUG=True)</code>。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置配置参数的形式</span></span><br><span class="line"><span class="comment"># DEBUG必须要大写，不能小写</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.update(DEBUG=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><ol><li>通过配置文件的形式设置 DEBUG 模式：<code>app.config.from_object(config)</code></li></ol><p>导入<code>import config</code><br>使用<code>app.config.from_object(config)</code><br>新建<code>config.py</code>文件，写入<code>DEBUG=true</code></p><h3 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h3><ol><li>导入<code>import config</code>，使用<code>app.config.from_object(config)</code>,新建<code>config.py</code>文件，写入<code>DEBUG=true</code></li><li><code>app.config.from_pyfile(&#39;config.py,silence=True)</code>,新建<code>config.py</code>文件，写入<code>DEBUG=true</code><br>可以传递<code>silent=True</code>，那么这个静态文件没有找到的时候，不会抛出异常</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-学习笔记-&lt;br&gt;flask 前期准备，在目录下建立 flask 虚拟环境，开启调试模式和书写配置文档&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="flask" scheme="https://hyqskevin.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>c++ 面向对象的一些特性</title>
    <link href="https://hyqskevin.github.io/2019/03/25/cpp-oop/"/>
    <id>https://hyqskevin.github.io/2019/03/25/cpp-oop/</id>
    <published>2019-03-25T11:35:15.000Z</published>
    <updated>2020-11-19T06:56:05.765Z</updated>
    
    <content type="html"><![CDATA[<p>-基础笔记-(loading…)<br>C++面向对象编程知识点复习梳理，包括类、继承、重载、多态、数据抽象、数据封装、接口</p><a id="more"></a><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h3><p>public<br>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值</p><p>private<br>私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员<br>默认情况下，类的所有成员都是私有的<br>一般会在私有区域定义数据，在公有区域定义相关的函数</p><p>protected<br>保护成员在派生类（即子类）中是可访问的</p><h3 id="构造函数-拷贝构造函数和析构函数"><a href="#构造函数-拷贝构造函数和析构函数" class="headerlink" title="构造函数,拷贝构造函数和析构函数"></a>构造函数,拷贝构造函数和析构函数</h3><p>创建、初始化和删除所创建的对象时调用<br>构造函数的名称与类的名称是完全相同的，不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值<br>拷贝构造函数是一种特殊的构造函数，在创建对象时，是使用同一类中之前创建的对象来<strong>初始化新创建的对象</strong>。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数<br>析构函数的名称与类的名称是完全相同的，不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Classname();  <span class="comment">//构造函数</span></span><br><span class="line">  Classname(<span class="keyword">const</span> Classname &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">  ~Classname();  <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Classname::Classname()&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  *ptr = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//指针分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Classname::Classname(<span class="keyword">const</span> Classname &amp;obj)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用拷贝构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  *ptr = *obj.ptr;  <span class="comment">//指针分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CLassname::~Classname()&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"释放内存"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类如果有多个字段 X、Y、Z 等需要进行初始化，可以使用如下语法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Classname::objname( <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): X(a), Y(b), Z(c)</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>浅拷贝：如果没有拷贝构造函数，编译器自动产生一个“默认拷贝构造函数”，使用“老对象”的数据成员的值对“新对象”的数据成员进行赋值<br>当对象存在动态成员，那么浅拷贝就会出问题，在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，出现错误</p><p>深拷贝：对象中动态成员重新动态分配空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Classname()&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  Classname(<span class="keyword">const</span> Classname&amp; r)&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);  <span class="comment">//重新分配动态空间</span></span><br><span class="line">    *p = *(r.p);  <span class="comment">//指针分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line">  ~Classname()&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>定义在类外部，用来访问类的 private 和 protected 成员<br>可以不使用范围解析运算符 <code>::</code> 定义该函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Classname</span>;</span>  <span class="comment">//友元类</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">objname</span><span class="params">()</span></span>;  <span class="comment">//友元函数</span></span><br></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码，即把该函数的代码副本放置在每个调用该函数的地方<br>类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符</p><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p>每一个对象都能通过 <code>this</code> 指针来访问自己的地址<br>友元函数没有 <code>this</code> 指针，因为友元不是类的成员</p><h3 id="类指针"><a href="#类指针" class="headerlink" title="类指针"></a>类指针</h3><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 <code>-&gt;</code>，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     func()&#123;&#125;</span><br><span class="line">     ...</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Box *ptrBox;</span><br><span class="line">ptrBox-&gt;func();</span><br></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>变量和函数都可以被声明为静态的</p><ol><li><p>声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员在类的所有对象中是共享的<br>不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化</p></li><li><p>把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。<br>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> objectCount;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> objectCount;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化类 Box 的静态成员</span></span><br><span class="line"><span class="keyword">int</span> Box::objectCount = <span class="number">0</span>;</span><br><span class="line">output = Box::getCount()</span><br></pre></td></tr></table></figure><h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前</p><ol><li><p>auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符</p></li><li><p>register(C++ 11 弃用) 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）</p></li><li><p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</p></li><li><p>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p></li></ol><p>当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。</p><ol><li><p>mutable 说明符仅适用于类的对象，它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p></li><li><p>thread_local 说明符声明的变量仅可在它在其上创建的线程上访问，变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p></li></ol><p>thread_local 说明符可以与 static 或 extern 合并。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p><p>当创建一个类时，不需要重新编写新的<strong>数据成员和成员函数</strong>，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p><p>派生类可以访问基类中所有的<strong>非私有成员</strong>。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p><p><code>class derived-class: (public/protected/private) base-class</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性，C++ 类可以从多个类继承成员</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="虚继承：解决多继承中出现的问题"><a href="#虚继承：解决多继承中出现的问题" class="headerlink" title="虚继承：解决多继承中出现的问题"></a>虚继承：解决多继承中出现的问题</h3><p>从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。</p><p>虚继承在创建对象的时候会创建一个虚表，从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。</p><p>这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类:</span> <span class="keyword">virtual</span> 方式<span class="number">1</span> 基类<span class="number">1</span>，<span class="keyword">virtual</span> 方式<span class="number">2</span> 基类<span class="number">2</span>，...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">...<span class="comment">//派生类成员声明</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> D&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A&#123;.....&#125;;</span><br></pre></td></tr></table></figure><h3 id="派生类无法从基类继承"><a href="#派生类无法从基类继承" class="headerlink" title="派生类无法从基类继承"></a>派生类无法从基类继承</h3><p>基类的构造函数、析构函数和拷贝构造函数<br>基类的重载运算符<br>基类的友元函数</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p><p>编译器通过把使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>重定义或重载大部分 C++ 内置的运算符，使用自定义类型的运算符。</p><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p><p><code>Box operator+(const Box&amp; b); // 重载+运算符</code></p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一个类中，声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"整数为: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>  f)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"浮点数为: "</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串为: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>4.2“覆盖”是指派生类函数覆盖基类函数，特征是：<br>（1）不同的范围（分别位于派生类与基类）；<br>（2）函数名字相同；<br>（3）参数相同；<br>（4）基类函数必须有 virtual 关键字。</p><p>4.3“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，特征是：</p><p>（1）如果派生类的函数与基类的函数同名，但是参数不同，此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。<br>（2）如果派生类的函数与基类的函数同名，但是参数相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p><h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><hr><p>参考资料：<br><a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">http://c.biancheng.net/cplus/</a><br>w3school</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;-基础笔记-(loading…)&lt;br&gt;C++面向对象编程知识点复习梳理，包括类、继承、重载、多态、数据抽象、数据封装、接口&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="https://hyqskevin.github.io/categories/study/"/>
    
    
      <category term="c++" scheme="https://hyqskevin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的相关操作</title>
    <link href="https://hyqskevin.github.io/2019/03/24/bintree/"/>
    <id>https://hyqskevin.github.io/2019/03/24/bintree/</id>
    <published>2019-03-24T02:33:15.000Z</published>
    <updated>2020-11-19T06:56:09.923Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的笔记 loading…</p><a id="more"></a><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h2 id="四种遍历方法"><a href="#四种遍历方法" class="headerlink" title="四种遍历方法"></a>四种遍历方法</h2><h2 id="二叉树静态实现"><a href="#二叉树静态实现" class="headerlink" title="二叉树静态实现"></a>二叉树静态实现</h2><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="一般意义上的树"><a href="#一般意义上的树" class="headerlink" title="一般意义上的树"></a>一般意义上的树</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的笔记 loading…&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="https://hyqskevin.github.io/categories/code/"/>
    
    
      <category term="algorithm" scheme="https://hyqskevin.github.io/tags/algorithm/"/>
    
  </entry>
  
</feed>
